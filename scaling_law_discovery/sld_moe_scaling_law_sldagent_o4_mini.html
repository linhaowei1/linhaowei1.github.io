<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLD - MoE Scaling Law - SLDAgent + o4-mini</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --accent-primary: #2563eb;
        --accent-secondary: #3b82f6;
        --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
        --text-primary: #1f2937;
        --text-secondary: #4b5563;
        --border-subtle: rgba(0, 0, 0, 0.1);
        --glass-bg: rgba(0, 0, 0, 0.02);
        --success: #10b981;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          "Sora",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
      }

      .bg-pattern {
        display: none;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--accent-primary);
        text-decoration: none;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
        transition: color 0.2s;
      }

      .back-link:hover {
        color: var(--accent-secondary);
      }

      .header {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .meta-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .meta-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .r2-badge {
        display: inline-block;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", monospace;
      }

      .section-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .runs-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .run-card {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        overflow: hidden;
        transition: border-color 0.2s;
      }

      .run-card:hover {
        border-color: rgba(99, 102, 241, 0.3);
      }

      .run-card.best-run {
        border-color: var(--success);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
      }

      .run-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        transition: background 0.2s;
      }

      .run-header:hover {
        background: rgba(255, 255, 255, 0.04);
      }

      .run-info {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .run-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-secondary);
      }

      .run-badge.best-badge {
        background: var(--success);
        color: white;
      }

      .run-label {
        font-weight: 500;
        color: var(--text-primary);
      }

      .expand-icon {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: transform 0.2s;
      }

      .run-header.expanded .expand-icon {
        transform: rotate(180deg);
      }

      .run-content {
        border-top: 1px solid var(--border-subtle);
      }

      .code-container {
        overflow: hidden;
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.25rem;
        background: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid var(--border-subtle);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .copy-btn {
        padding: 0.35rem 0.75rem;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--accent-primary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-container pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        background: transparent !important;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid var(--border-subtle);
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .footer a {
        color: var(--accent-primary);
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .meta-row {
          flex-direction: column;
          gap: 0.75rem;
        }

        .run-info {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <a href="index.html" class="back-link"> ← Back to Leaderboard </a>

      <div class="header">
        <h1>MoE Scaling Law</h1>
        <div class="meta-row">
          <div class="meta-item">
            <span class="meta-label">Agent:</span>
            <span class="meta-value">SLDAgent</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Model:</span>
            <span class="meta-value">o4-mini</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Best R²:</span>
            <span class="r2-badge" style="background-color: #006400; color: white"> 0.960856 </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Mean R²:</span>
            <span class="meta-value">0.958019</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Min R²:</span>
            <span class="meta-value">0.953694</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Runs:</span>
            <span class="meta-value">5</span>
          </div>
        </div>
      </div>

      <h2 class="section-title">All Runs (sorted by R²)</h2>

      <div class="runs-container">
        <div class="run-card best-run">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge best-badge">Best</span>
              <span class="run-label">Run 4</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.960856 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: block">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-0">&quot;&quot;&quot;
6-parameter joint‐saturating scaling law for MoE:
  loss ≈ C + (A·d^α + B) / (1 + e^γ + d^δ)
where
  d = dense_parameter_count / 1e8,
  e = num_experts / 64.
Parameters: [A, α, B, γ, δ, C].
&quot;&quot;&quot;
import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    E = X[:, 0]  # num_experts
    D = X[:, 1]  # dense_parameter_count
    # normalize
    d = D / 1e8
    e = E / 64.0
    # ensure shape (K,6)
    p = np.atleast_2d(np.asarray(params, dtype=float))
    if p.shape[1] != 6:
        raise ValueError(&quot;Expected 6 parameters [A, α, B, γ, δ, C]&quot;)
    A, alpha, B, gamma, delta, C = p.T
    # expand for broadcasting
    d_mat = d[:, None]         # (N,1)
    e_mat = e[:, None]         # (N,1)
    # numerator and denominator
    num = A[None, :] * (d_mat ** alpha[None, :]) + B[None, :]
    den = 1.0 + e_mat ** gamma[None, :] + d_mat ** delta[None, :]
    pred = C[None, :] + num / den
    # if only one param‐set, return shape (N,)
    return pred[:, 0] if pred.shape[1] == 1 else pred

def fit_scaling_law(data_points, loss_values):
    X = np.asarray(data_points, dtype=float)
    y = np.asarray(loss_values, dtype=float).ravel()
    E = X[:, 0]
    D = X[:, 1]
    d = D / 1e8
    e = E / 64.0

    # objective in raw space: [logA, α, logB, logγ, δ, C]
    def _mse(raw):
        logA, alpha, logB, logG, delta, C = raw
        A = np.exp(logA)
        B = np.exp(logB)
        gamma = np.exp(logG)
        pred = C + (A * (d ** alpha) + B) / (1.0 + e ** gamma + d ** delta)
        return np.mean((pred - y) ** 2)

    # multiple sensible starting points
    C0 = np.mean(y)
    inits = [
        np.array([ 0.0, 1.0,  0.0, 1.0, 1.0, C0]),
        np.array([-1.0, 0.5, -1.0, 0.5, 0.5, C0]),
        np.array([ 1.0, 2.0,  1.0, 2.0, 2.0, C0])
    ]

    bounds = [
        (-10, 10),  # logA
        (-5, 5),    # α
        (-10, 10),  # logB
        (-5, 5),    # logγ
        (-5, 5),    # δ
        (None, None)# C
    ]

    best_raw = None
    best_val = np.inf
    for init in inits:
        res = minimize(_mse, init, method=&#x27;L-BFGS-B&#x27;, bounds=bounds)
        if res.success and res.fun &lt; best_val:
            best_val = res.fun
            best_raw = res.x

    # fallback to first init if no run succeeded
    if best_raw is None:
        best_raw = inits[0]

    logA, alpha, logB, logG, delta, C = best_raw
    return np.array([
        np.exp(logA),
        alpha,
        np.exp(logB),
        np.exp(logG),
        delta,
        C
    ])</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#2</span>
              <span class="run-label">Run 5</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.960419 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-1"># EVOLVE-BLOCK-START
&quot;&quot;&quot;
6‐parameter saturating mixing scaling law for MoE:
  loss ≈ C + (A * (d_norm^α) + B) / (E^γ + d_norm^δ)
where d_norm = dense_parameter_count / 1e8.

Parameters: [A, α, B, γ, δ, C]
&quot;&quot;&quot;
import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points))
    E = X[:, 0]                      # num_experts
    D = X[:, 1]                      # dense_parameter_count
    d = D / 1e8                      # normalized dense scale

    p = np.asarray(params)
    if p.ndim == 1:
        p = p[None, :]
    assert p.shape[1] == 6, &quot;Expected 6 params [A, α, B, γ, δ, C]&quot;

    A, alpha, B, gamma, delta, C = p.T
    E_mat = E[:, None]
    d_mat = d[:, None]

    # numerator: A*d^α + B
    num = A[None, :] * (d_mat**alpha[None, :]) + B[None, :]
    # denominator: E^γ + d^δ
    den = (E_mat**gamma[None, :]) + (d_mat**delta[None, :])
    pred = C[None, :] + num / den

    return pred[:, 0] if pred.shape[1] == 1 else pred

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points))
    y = np.asarray(loss_values).ravel()
    E = X[:, 0]
    D = X[:, 1]
    d = D / 1e8

    def objective(raw):
        # raw = [logA, α, logB, logγ, δ, C]
        logA, alpha, logB, logGamma, delta, C = raw
        A     = np.exp(logA)
        B     = np.exp(logB)
        gamma = np.exp(logGamma)
        pred = C + (A * (d**alpha) + B) / (E**gamma + d**delta)
        return np.mean((pred - y)**2)

    # initialize near A≈1, B≈1, γ≈1, δ≈1, α≈1, C≈mean loss
    init = np.array([0.0, 1.0, 0.0, 0.0, 1.0, np.mean(y)])
    bounds = [
        (-10, 10),   # logA
        (-5, 5),     # α
        (-10, 10),   # logB
        (-5, 5),     # logγ
        (-5, 5),     # δ
        (None, None) # C
    ]
    res = minimize(objective, init, bounds=bounds, method=&#x27;L-BFGS-B&#x27;)
    raw_opt = res.x if res.success else init

    logA, alpha, logB, logGamma, delta, C = raw_opt
    return np.array([
        np.exp(logA),
        alpha,
        np.exp(logB),
        np.exp(logGamma),
        delta,
        C
    ])
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#3</span>
              <span class="run-label">Run 1</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.958958 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-2"># EVOLVE-BLOCK-START
&quot;&quot;&quot;
6-parameter saturating mixing law for MoE with hybrid MSE+MAE objective:
  loss ≈ C + (A·(D/1e8)^α + B) / (E^γ + (D/1e8)^δ)
Parameters: [A, α, B, γ, δ, C]
&quot;&quot;&quot;
import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    X = np.asarray(data_points, float)
    if X.ndim == 1: X = X[None, :]
    E, D = X[:,0], X[:,1]
    A, alpha, B, gamma, delta, C = params
    d = D / 1e8
    return C + (A * d**alpha + B) / (E**gamma + d**delta)

def fit_scaling_law(data_points, loss_values):
    X = np.asarray(data_points, float)
    if X.ndim == 1: X = X[None, :]
    E, D = X[:,0], X[:,1]
    d = D / 1e8
    y = np.asarray(loss_values, float).ravel()

    # Hybrid loss: MSE + 0.5 * MAE
    def objective(raw):
        logA, alpha, logB, logG, delta, C = raw
        A, B, G = np.exp(logA), np.exp(logB), np.exp(logG)
        pred = C + (A * d**alpha + B) / (E**G + d**delta)
        r = pred - y
        return np.mean(r*r) + 0.5 * np.mean(np.abs(r))

    # bounds &amp; init
    init = [0.0, 1.0, 0.0, 1.0, 1.0, np.mean(y)]
    bounds = [(-10,10), (-5,5), (-10,10), (-5,5), (-5,5), (None,None)]
    res = minimize(objective, init, method=&#x27;L-BFGS-B&#x27;, bounds=bounds)

    if res.success:
        logA, alpha, logB, logG, delta, C = res.x
    else:
        logA, alpha, logB, logG, delta, C = init

    return np.array([np.exp(logA), alpha, np.exp(logB), np.exp(logG), delta, C], dtype=float)
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#4</span>
              <span class="run-label">Run 2</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.956167 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-3">import numpy as np
from scipy.optimize import minimize

# EVOLVE-BLOCK-START
&quot;&quot;&quot;
Refined MoE scaling law with a saturating expert‐term to capture diminishing returns.
Model form (6 params):
   loss ≈ A1 * D_norm^α * E_norm^(−γ)
        + A2 * (1 − exp(−β * E_norm))
        + C

where
   D_norm = dense_parameter_count / 1e8
   E_norm = num_experts / 64

Parameters = [A1, α, γ, A2, β, C]
&quot;&quot;&quot;
def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    E = X[:, 0]                     # num_experts
    D = X[:, 1]                     # dense_parameter_count
    # fixed‐scale normalization (no input‐dependent stats)
    Dn = D / 1e8
    En = E / 64.0

    p = np.asarray(params, dtype=float)
    if p.ndim == 1:
        p = p[None, :]             # shape (1,6)
    # unpack columns
    A1, alpha, gamma, A2, beta, C = p.T

    # broadcast to compute (N × T)
    Dm = Dn[:, None]
    Em = En[:, None]

    term1 = A1[None, :] * (Dm ** alpha[None, :]) * (Em ** (-gamma[None, :]))
    term2 = A2[None, :] * (1.0 - np.exp(-beta[None, :] * Em))
    preds = term1 + term2 + C[None, :]

    # if a single parameter vector was passed, return shape (N,)
    return preds[:, 0] if preds.shape[1] == 1 else preds


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit [A1, α, γ, A2, β, C] by minimizing mean absolute log‐error
    via multi‐start L‐BFGS‐B in a mixed raw/log space.
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.asarray(loss_values, dtype=float).ravel()
    E = X[:, 0]
    D = X[:, 1]

    # same fixed normalization
    Dn = D / 1e8
    En = E / 64.0
    eps = 1e-12

    # unpack raw vector → actual params
    def unpack(raw):
        logA1, alpha, logγ, logA2, logβ, C = raw
        return (np.exp(logA1),
                alpha,
                np.exp(logγ),
                np.exp(logA2),
                np.exp(logβ),
                C)

    # objective: mean absolute log‐error
    def objective(raw):
        A1, alpha, γ, A2, β, C = unpack(raw)
        pred = (A1 * (Dn ** alpha) * (En ** (-γ))
                + A2 * (1.0 - np.exp(-β * En))
                + C)
        pred = np.maximum(pred, eps)
        return np.mean(np.abs(np.log(pred) - np.log(y + eps)))

    # bounds for raw parameters:
    #   logA1 ∈ [-5,5], α ∈ [-2,2], logγ ∈ [-5,5],
    #   logA2 ∈ [-5,5], logβ ∈ [-5,5], C ∈ [0,5]
    bounds = [
        (-5, 5),
        (-2, 2),
        (-5, 5),
        (-5, 5),
        (-5, 5),
        (0, 5),
    ]

    # prepare multi‐start initial guesses
    y0 = np.mean(y)
    inits = [
        np.array([ 0.0,  0.5,  0.0,   0.0,  1.0, y0]),
        np.array([-1.0,  1.0,  0.5,  -1.0,  0.5, y0]),
        np.array([ 1.0, -0.5,  1.0,   1.0, -0.5, y0])
    ]
    # add a couple of random perturbations (deterministic seed)
    rng = np.random.RandomState(0)
    for _ in range(2):
        raw = np.array([
            rng.uniform(-2,2),      # logA1
            rng.uniform(-1,1),      # α
            rng.uniform(-1,1),      # logγ
            rng.uniform(-2,2),      # logA2
            rng.uniform( 0,2),      # logβ
            y0
        ])
        inits.append(raw)

    best_fun = np.inf
    best_raw = inits[0]
    for raw0 in inits:
        res = minimize(
            objective,
            raw0,
            method=&#x27;L-BFGS-B&#x27;,
            bounds=bounds,
            options={&#x27;maxiter&#x27;: 500, &#x27;ftol&#x27;: 1e-9}
        )
        if res.success and res.fun &lt; best_fun:
            best_fun, best_raw = res.fun, res.x

    # recover optimal parameters
    A1_opt, alpha_opt, γ_opt, A2_opt, β_opt, C_opt = unpack(best_raw)
    return np.array([A1_opt, alpha_opt, γ_opt, A2_opt, β_opt, C_opt])
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#5</span>
              <span class="run-label">Run 3</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.953694 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-4"># EVOLVE-BLOCK-START
&quot;&quot;&quot;
6-parameter MoE scaling law with combined expert-log damping:
  loss ≈ A·(D/1e8)^α / [(E·log₁₊E)^γ]  +  B / (log₁₊E)^β  +  C

– First term captures joint scaling of dense params and experts,
  damping experts by both E and log(1+E).
– Second term captures long-tail expert-only diminishing returns.
– Fits in three stages: 
    1) Exponents α,γ,β via L-BFGS-B with closed-form A,B,C.
    2) Closed-form solve for A,B,C.
    3) Joint L-BFGS-B refine all six in log-space for stability.
&quot;&quot;&quot;
import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    data_points: (N,2) array [num_experts E, dense_param_count D]
    params: [A, α, γ, B, β, C]
    returns: (N,) predicted validation losses
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, float))
    E = X[:, 0]
    D_norm = X[:, 1] / 1e8
    p = np.asarray(params, float)
    if p.ndim == 1:
        p = p[None, :]
    assert p.shape[1] == 6, &quot;Expected 6 params [A,α,γ,B,β,C]&quot;
    A, alpha, gamma, B, beta, C = p.T
    L = np.log1p(E)
    pred = A * (D_norm ** alpha) / ((E * L) ** gamma) + B / (L ** beta) + C
    return pred.ravel()

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fits the 6-parameter model by:
      Stage 1: Optimize exponents [α,γ,β] via L-BFGS-B, solving [A,B,C] by LS.
      Stage 2: Solve [A,B,C] in closed form with chosen exponents.
      Stage 3: Jointly refine [logA,α,logγ,logB,β,C] via L-BFGS-B.
    Returns optimized [A, α, γ, B, β, C].
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, float))
    E = X[:, 0]
    D_norm = X[:, 1] / 1e8
    y = np.asarray(loss_values, float).ravel()
    L = np.log1p(E)

    # Stage 1: optimize exponents α,γ,β
    def obj_exps(raw):
        alpha, gamma, beta = raw
        x1 = D_norm**alpha / ((E * L)**gamma)
        x2 = 1.0 / (L**beta)
        M = np.vstack([x1, x2, np.ones_like(x1)]).T
        coeffs, *_ = np.linalg.lstsq(M, y, rcond=None)
        pred = M.dot(coeffs)
        return np.mean((pred - y) ** 2)

    init_exps = np.array([0.5, 0.5, 1.0])
    bounds_exps = [(-2, 2), (-5, 5), (0, 5)]
    res_exps = minimize(obj_exps, init_exps, bounds=bounds_exps, method=&#x27;L-BFGS-B&#x27;)
    alpha0, gamma0, beta0 = res_exps.x if res_exps.success else init_exps

    # Stage 2: closed-form solve for A, B, C
    x1 = D_norm**alpha0 / ((E * L)**gamma0)
    x2 = 1.0 / (L**beta0)
    M = np.vstack([x1, x2, np.ones_like(x1)]).T
    coeff0, *_ = np.linalg.lstsq(M, y, rcond=None)
    A0, B0, C0 = coeff0

    # Stage 3: joint refine all six parameters
    def obj_full(raw):
        logA, alpha, logG, logB, beta, C = raw
        A = np.exp(logA)
        gamma = np.exp(logG)
        B = np.exp(logB)
        pred = A * (D_norm ** alpha) / ((E * L) ** gamma) + B / (L ** beta) + C
        return np.mean((pred - y) ** 2)

    init_raw = np.array([
        np.log(max(A0, 1e-8)),
        alpha0,
        np.log(max(gamma0, 1e-8)),
        np.log(max(B0, 1e-8)),
        beta0,
        C0
    ])
    bounds_full = [
        (-10, 10),  # logA
        (-2, 2),    # α
        (-10, 10),  # logγ
        (-10, 10),  # logB
        (0, 5),     # β
        (None, None)# C
    ]
    res_full = minimize(obj_full, init_raw, bounds=bounds_full, method=&#x27;L-BFGS-B&#x27;)
    raw_opt = res_full.x if res_full.success else init_raw

    logA, alpha, logG, logB, beta, C = raw_opt
    A_opt = np.exp(logA)
    gamma_opt = np.exp(logG)
    B_opt = np.exp(logB)

    return np.array([A_opt, alpha, gamma_opt, B_opt, beta, C])
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> |
          <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a>
        </p>
      </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      function toggleRun(header) {
        const content = header.nextElementSibling;
        const isExpanded = content.style.display === "block";
        content.style.display = isExpanded ? "none" : "block";
        header.classList.toggle("expanded", !isExpanded);
      }

      function copyCode(event, codeId) {
        event.stopPropagation();
        const code = document.getElementById(codeId).textContent;
        navigator.clipboard.writeText(code).then(() => {
          const btn = event.target;
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 2000);
        });
      }

      Prism.highlightAll();
    </script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLD - Domain Mixture Scaling Law - SLDAgent + GPT-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --accent-primary: #2563eb;
            --accent-secondary: #3b82f6;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-subtle: rgba(0, 0, 0, 0.1);
            --glass-bg: rgba(0, 0, 0, 0.02);
            --success: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Sora', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .bg-pattern {
            display: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--accent-secondary);
        }
        
        .header {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .meta-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .meta-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .meta-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .r2-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .runs-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .run-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .run-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .run-card.best-run {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.02);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .run-header:hover {
            background: rgba(255, 255, 255, 0.04);
        }
        
        .run-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .run-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        
        .run-badge.best-badge {
            background: var(--success);
            color: white;
        }
        
        .run-label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .expand-icon {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .run-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .run-content {
            border-top: 1px solid var(--border-subtle);
        }
        
        .code-container {
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .copy-btn {
            padding: 0.35rem 0.75rem;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .copy-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }
        
        .code-container pre {
            margin: 0;
            padding: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-x: auto;
            background: transparent !important;
        }
        
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .meta-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .run-info {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <a href="sld_index.html" class="back-link">
            ← Back to Leaderboard
        </a>
        
        <div class="header">
            <h1>Domain Mixture Scaling Law</h1>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Agent:</span>
                    <span class="meta-value">SLDAgent</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Model:</span>
                    <span class="meta-value">GPT-5</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best R²:</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        0.989346
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Mean R²:</span>
                    <span class="meta-value">0.909668</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Min R²:</span>
                    <span class="meta-value">0.870736</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Runs:</span>
                    <span class="meta-value">5</span>
                </div>
            </div>
        </div>
        
        <h2 class="section-title">All Runs (sorted by R²)</h2>
        
        <div class="runs-container">
            
        <div class="run-card best-run">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge best-badge">Best</span>
                    <span class="run-label">Run 3</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.989346
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: block;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-0"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

# Bounded exponent mapping for numerical stability
_LO, _HI = 0.2, 2.5
_EPS = 1e-8
_LN5 = np.log(5.0)

def _sigmoid(x):
    return 1.0 / (1.0 + np.exp(-x))

def _map_exp(q):
    return _LO + (_HI - _LO) * _sigmoid(q)

def _inv_map_exp(x):
    t = (float(x) - _LO) / (_HI - _LO)
    t = np.clip(t, 1e-6, 1 - 1e-6)
    return np.log(t / (1 - t))

def _features(X, gp, aS, bS, kap, go, T):
    p = np.clip(np.asarray(X, float), 0.0, 1.0)
    N, F = p.shape
    T = int(min(T, F))
    pj = p[:, :T]

    # Cross-domain statistics (normalized for scale stability)
    sA = (np.sum(p ** aS, axis=1, keepdims=True) / max(F, 1))  # normalized generalized Herfindahl
    Hn = (-np.sum(p * np.log(p + _EPS), axis=1, keepdims=True) / _LN5)  # normalized entropy in [0,1+]

    # Per-output feature blocks (6 per domain, param-efficient and expressive)
    X0 = np.ones((N, T))                                        # intercept
    X1 = pj ** gp                                               # self-mass exponent
    X2 = np.log(pj + _EPS) - np.log(1.0 - pj + _EPS)           # logit(p_j) for edge sensitivity
    X3 = (sA ** bS).repeat(T, axis=1)                           # global concentration (adaptive power)
    X4 = (np.maximum(Hn, 0.0) ** kap).repeat(T, axis=1)         # global diversity (adaptive power)
    X5 = (1.0 - pj) ** go                                       # other-mass exponent
    return X0, X1, X2, X3, X4, X5

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, float))
    q = np.asarray(params, float).ravel()
    if q.size &lt; 5 + 6:
        return np.full((X.shape[0], 5), 3.0)

    gp = _map_exp(q[0]); aS = _map_exp(q[1]); bS = _map_exp(q[2]); kap = _map_exp(q[3]); go = _map_exp(q[4])
    rem = q.size - 5
    if rem % 6 != 0:
        rem = (rem // 6) * 6
    T = max(1, min(5, rem // 6))
    W = q[5:5 + 6 * T].reshape(T, 6)

    X0, X1, X2, X3, X4, X5 = _features(X, gp, aS, bS, kap, go, T)
    pred = (W[:, 0][None, :] * X0 + W[:, 1][None, :] * X1 + W[:, 2][None, :] * X2 +
            W[:, 3][None, :] * X3 + W[:, 4][None, :] * X4 + W[:, 5][None, :] * X5)
    if pred.shape[1] &lt; 5:
        pred = np.concatenate([pred, np.repeat(pred[:, [-1]], 5 - pred.shape[1], axis=1)], axis=1)
    return pred

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, float))
    Y = np.asarray(loss_values, float)
    Y2 = Y if Y.ndim == 2 else Y[:, None]
    N, F = X.shape
    T = min(Y2.shape[1], F, 5)

    lam = 1e-4 + 1e-2 / max(N, 1)  # small adaptive ridge on linear heads

    def solve_W(gp, aS, bS, kap, go):
        X0, X1, X2, X3, X4, X5 = _features(X, gp, aS, bS, kap, go, T)
        W = np.zeros((T, 6))
        reg = np.array([0.0, lam, lam, lam, lam, lam])         # leave intercept unregularized
        D = np.sqrt(reg); Dmat = np.diag(D); Dmat[0, 0] = 0.0
        zeros = np.zeros(6)
        for j in range(T):
            A = np.column_stack([X0[:, j], X1[:, j], X2[:, j], X3[:, j], X4[:, j], X5[:, j]])
            A_aug = np.vstack([A, Dmat])
            b_aug = np.concatenate([Y2[:, j], zeros])
            W[j], *_ = np.linalg.lstsq(A_aug, b_aug, rcond=None)
        return W

    # Gentle priors to avoid pathological exponents: center near (gp=1, aS=2, bS=1, kap=1, go=1)
    reg_theta = 1e-4
    def obj(theta_raw):
        gp = _map_exp(theta_raw[0]); aS = _map_exp(theta_raw[1]); bS = _map_exp(theta_raw[2])
        kap = _map_exp(theta_raw[3]); go = _map_exp(theta_raw[4])
        W = solve_W(gp, aS, bS, kap, go)
        X0, X1, X2, X3, X4, X5 = _features(X, gp, aS, bS, kap, go, T)
        pred = (W[:, 0][None, :] * X0 + W[:, 1][None, :] * X1 + W[:, 2][None, :] * X2 +
                W[:, 3][None, :] * X3 + W[:, 4][None, :] * X4 + W[:, 5][None, :] * X5)
        err = pred - Y2[:, :T]
        pen = reg_theta * ((gp - 1.0) ** 2 + (aS - 2.0) ** 2 + (bS - 1.0) ** 2 + (kap - 1.0) ** 2 + (go - 1.0) ** 2)
        return float(np.mean(err * err) + pen)

    starts_vals = [
        (0.9, 2.0, 1.0, 1.0, 1.0),
        (1.1, 1.8, 0.8, 0.9, 1.2),
        (0.8, 2.2, 1.2, 1.1, 0.9),
        (1.2, 1.6, 1.3, 0.8, 1.3),
        (1.0, 2.0, 1.0, 1.2, 1.0),
        (0.7, 2.3, 0.9, 1.1, 0.8),
        (1.3, 1.7, 1.1, 0.9, 1.1)
    ]
    starts = [np.array([_inv_map_exp(a), _inv_map_exp(b), _inv_map_exp(c), _inv_map_exp(d), _inv_map_exp(e)])
              for a, b, c, d, e in starts_vals]

    best_x, best_val = None, np.inf
    for s in starts:
        try:
            res = minimize(obj, s, method=&quot;L-BFGS-B&quot;)
            val = res.fun if res.success else obj(s)
            if val &lt; best_val:
                best_val, best_x = val, (res.x if res.success else s)
        except Exception:
            continue
    if best_x is None:
        best_x = np.array([_inv_map_exp(1.0), _inv_map_exp(2.0), _inv_map_exp(1.0), _inv_map_exp(1.0), _inv_map_exp(1.0)])

    gp = _map_exp(best_x[0]); aS = _map_exp(best_x[1]); bS = _map_exp(best_x[2]); kap = _map_exp(best_x[3]); go = _map_exp(best_x[4])
    W = solve_W(gp, aS, bS, kap, go)
    return np.concatenate([[_inv_map_exp(gp), _inv_map_exp(aS), _inv_map_exp(bS), _inv_map_exp(kap), _inv_map_exp(go)], W.reshape(-1)])
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#2</span>
                    <span class="run-label">Run 5</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.938720
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-1"># EVOLVE-BLOCK-START
&quot;&quot;&quot;
Compositional scaling law with additive log-ratio (ALR) features.
Params (&lt;=35): W(5x4)=20, c(5), d(5), b(5)  -&gt; total 35.
y = alr(p) @ W.T + conc * c + ent * d + b
Features:
- alr(p)_i = log(p_i / p_5) for i=1..4 (simplex-aware, removes redundancy)
- conc = sum(p^2) captures concentration
- ent = -sum(p*log p) captures diversity/curvature
Fit via closed-form ridge regression over [alr(4), conc(1), ent(1), bias(1)].
&quot;&quot;&quot;
import numpy as np
_EPS = 1e-8

def _unpack_params(params):
    p = np.asarray(params, dtype=float).ravel()
    if p.size &lt; 35: p = np.pad(p, (0, 35 - p.size))
    if p.size &gt; 35: p = p[:35]
    W = p[:20].reshape(5, 4); c = p[20:25]; d = p[25:30]; b = p[30:35]
    return W, c, d, b

def _features(X):
    P = np.clip(np.atleast_2d(np.asarray(X, float)), _EPS, 1.0)
    P /= np.maximum(P.sum(1, keepdims=True), _EPS)
    alr = np.log(P[:, :4] / P[:, [4]])                 # (N,4)
    conc = np.sum(P*P, 1, keepdims=True)               # (N,1)
    ent = -np.sum(P*np.log(P), 1, keepdims=True)       # (N,1)
    return alr, conc, ent

def scaling_law_func(data_points, params):
    W, c, d, b = _unpack_params(params)
    alr, conc, ent = _features(data_points)
    return alr @ W.T + conc @ c[None, :] + ent @ d[None, :] + b[None, :]

def fit_scaling_law(data_points, loss_values):
    Y = np.asarray(loss_values, float)
    if Y.ndim == 1: Y = Y[:, None]
    alr, conc, ent = _features(data_points)
    Z = np.concatenate([alr, conc, ent, np.ones((alr.shape[0], 1))], 1)  # (N,7)
    lam = 1e-3
    ZTZ = Z.T @ Z + lam * np.eye(7)
    ZTY = Z.T @ Y
    try:
        Theta = np.linalg.solve(ZTZ, ZTY)  # (7,5)
    except np.linalg.LinAlgError:
        Theta, *_ = np.linalg.lstsq(ZTZ, ZTY, rcond=None)
    W = Theta[:4, :].T
    c = Theta[4, :]
    d = Theta[5, :]
    b = Theta[6, :]
    return np.concatenate([W.ravel(), c, d, b])
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#3</span>
                    <span class="run-label">Run 4</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.874813
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-2"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def _softplus(x):
    z = np.clip(np.asarray(x, dtype=float), -40.0, 40.0)
    return np.log1p(np.exp(-np.abs(z))) + np.maximum(z, 0.0)

def _sigmoid(x):
    z = np.clip(np.asarray(x, dtype=float), -40.0, 40.0)
    return 1.0 / (1.0 + np.exp(-z))

def _pad5(X):
    X = np.atleast_2d(np.asarray(X, dtype=float))
    n, f = X.shape
    if f &lt; 5: X = np.hstack([X, np.zeros((n, 5 - f))])
    elif f &gt; 5: X = X[:, :5]
    return X

def _unpack_params(params):
    p = np.asarray(params, dtype=float).ravel()
    if p.size &lt; 35: p = np.pad(p, (0, 35 - p.size))
    elif p.size &gt; 35: p = p[:35]
    i = 0
    raw_a = p[i:i+5]; i += 5
    raw_p = p[i];     i += 1
    raw_q = p[i];     i += 1
    W     = p[i:i+8].reshape(4, 2); i += 8
    U     = p[i:i+10].reshape(2, 5); i += 10
    b     = p[i:i+5]; i += 5
    d     = p[i:i+5]
    a = _softplus(raw_a)
    p_exp = 0.3 + 2.2 * _sigmoid(raw_p)
    q_exp = 0.3 + 2.2 * _sigmoid(raw_q)
    return a, p_exp, q_exp, W, U, b, d, (raw_a, raw_p, raw_q)

def _build_Z(X, a, p_exp, q_exp):
    eps = 1e-8
    Xc = np.clip(X, eps, 1.0)
    z0 = np.power(Xc @ a + eps, p_exp)
    z1 = np.sum(Xc * Xc, axis=1)
    z2 = -(Xc * np.log(Xc)).sum(axis=1)
    z3 = np.sum(np.power(Xc, q_exp), axis=1)
    return np.stack([z0, z1, z2, z3], axis=1)

def scaling_law_func(data_points, params):
    X = _pad5(data_points)
    a, p_exp, q_exp, W, U, b, d, _ = _unpack_params(params)
    S = np.tanh(_build_Z(X, a, p_exp, q_exp) @ W)
    return b[None, :] + S @ U + X * d[None, :]

def fit_scaling_law(data_points, loss_values):
    X = _pad5(data_points)
    Y = np.asarray(loss_values, dtype=float)
    if Y.ndim == 1: Y = Y[:, None]
    if Y.shape[1] != 5:
        Y = Y[:, :5] if Y.shape[1] &gt; 5 else np.pad(Y, ((0,0),(0,5 - Y.shape[1])), mode=&#x27;edge&#x27;)
    N = X.shape[0]
    y_mean = np.mean(Y, axis=0)

    def inv_sigmoid_target(t):
        t = np.clip(t, 1e-6, 1 - 1e-6)
        return np.log(t / (1.0 - t))
    target = (1.0 - 0.3) / 2.2
    raw_a = np.zeros(5)
    raw_p = np.array([inv_sigmoid_target(target)])
    raw_q = np.array([inv_sigmoid_target(target)])

    a0, p0, q0 = _softplus(raw_a), 0.3 + 2.2 * _sigmoid(raw_p), 0.3 + 2.2 * _sigmoid(raw_q)
    Z0 = _build_Z(X, a0, p0, q0)
    M = np.hstack([Z0, X, np.ones((N, 1))])
    lam = 5e-4
    D = np.diag([1]*9 + [0])
    MTM = M.T @ M + lam * D + 1e-8 * np.eye(M.shape[1])
    MTY = M.T @ Y
    try:
        B = np.linalg.solve(MTM, MTY)
    except np.linalg.LinAlgError:
        B = np.linalg.lstsq(MTM, MTY, rcond=None)[0]
    A_Z = B[:4, :]
    A_X = B[4:9, :]
    b_init = B[9, :]
    U_svd, S_svd, Vt = np.linalg.svd(A_Z, full_matrices=False)
    r = 2
    W_init = U_svd[:, :r] * np.sqrt(S_svd[:r][None, :])
    U_init = (np.sqrt(S_svd[:r])[:, None]) * Vt[:r, :]
    d_init = np.mean(A_X, axis=1)
    theta = np.concatenate([raw_a, raw_p, raw_q, W_init.ravel(), U_init.ravel(), b_init, d_init])

    def huber(res, delta=0.25):
        a = np.abs(res)
        return np.where(a &lt;= delta, 0.5 * res * res, delta * (a - 0.5 * delta))

    def objective(th):
        pred = scaling_law_func(X, th)
        loss = np.mean(huber(pred - Y))
        a, p_exp, q_exp, W, U, b, d, raws = _unpack_params(th)
        reg = 8e-4 * (np.sum(W*W) + np.sum(U*U) + np.sum(d*d))
        reg += 4e-4 * ((p_exp - 1.0)**2 + (q_exp - 1.0)**2) + 8e-4 * np.sum(raws[0]**2)
        reg += 8e-4 * np.sum((b - y_mean)**2)
        return loss + reg

    def _update_linear(th, lam=5e-4):
        a, p_exp, q_exp, W, _, _, _, _ = _unpack_params(th)
        S = np.tanh(_build_Z(X, a, p_exp, q_exp) @ W)
        M = np.hstack([S, X, np.ones((N, 1))])
        Dm = np.diag([1,1] + [1]*5 + [0])
        MTM = M.T @ M + lam * Dm + 1e-8 * np.eye(M.shape[1])
        MTY = M.T @ Y
        try:
            B = np.linalg.solve(MTM, MTY)
        except np.linalg.LinAlgError:
            B = np.linalg.lstsq(MTM, MTY, rcond=None)[0]
        U_new = B[0:2, :]
        d_new = np.mean(B[2:7, :], axis=1)
        b_new = B[7, :]
        out = th.copy()
        out[15:25] = U_new.ravel()
        out[25:30] = b_new
        out[30:35] = d_new
        return out

    def pack_nl(th): return np.concatenate([th[:5], th[5:7], th[7:15]])
    def unpack_nl(nl, th):
        out = th.copy()
        out[:5] = nl[:5]; out[5:7] = nl[5:7]; out[7:15] = nl[7:15]
        return out
    def objective_nl(nl, fixed):
        th = unpack_nl(nl, fixed)
        th[15:25] = fixed[15:25]; th[25:30] = fixed[25:30]; th[30:35] = fixed[30:35]
        return objective(th)

    theta = _update_linear(theta)
    rng = np.random.default_rng(42)
    best = theta.copy()
    best_val = objective(best)

    for _ in range(3):
        nl = pack_nl(best) + rng.normal(0.0, 0.05, size=15)
        res = minimize(lambda v: objective_nl(v, best), nl, method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 300})
        nl_opt = res.x if res.success else nl
        cand = unpack_nl(nl_opt, best)
        cand = _update_linear(cand)
        res2 = minimize(objective, cand, method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 200})
        cand2 = res2.x if res2.success else cand
        val = objective(cand2)
        if val &lt; best_val:
            best_val, best = val, cand2

    for _ in range(2):
        start = best + rng.normal(0.0, 0.02, size=best.size)
        res = minimize(objective, start, method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 200})
        cand = res.x if res.success else start
        val = objective(cand)
        if val &lt; best_val:
            best_val, best = val, cand

    return best
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#4</span>
                    <span class="run-label">Run 1</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.874726
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-3"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

_RANK=2; _DOMS=5; _DEL=1e-6; _L2=1e-3; _HUB=0.5

def _softplus(x):
    return np.log1p(np.exp(-np.abs(x)))+np.maximum(x,0.0)

def scaling_law_func(data_points, params):
    X=np.atleast_2d(np.asarray(data_points)); N,F=X.shape; assert F==_DOMS
    p=np.asarray(params).ravel(); r=_RANK; i=0
    U=p[i:i+F*r].reshape(F,r); i+=F*r
    V=p[i:i+_DOMS*r].reshape(_DOMS,r); i+=_DOMS*r
    c=p[i:i+_DOMS]; i+=_DOMS
    rho=p[i] if i&lt;p.size else -6.9; i+=1
    beta=p[i:i+_DOMS] if i+_DOMS&lt;=p.size else np.zeros(_DOMS)
    eps=_softplus(rho)+_DEL
    X=np.clip(X,0.0,1.0); Xlog=np.log(X+eps); z=Xlog@U
    h=-(X*(np.log(X+eps))).sum(axis=1)
    return z@V.T+c+h[:,None]*beta

def fit_scaling_law(data_points, loss_values):
    X=np.atleast_2d(np.asarray(data_points)); Y=np.atleast_2d(np.asarray(loss_values))
    N,F=X.shape; C=Y.shape[1]; assert F==_DOMS and C==_DOMS; r=_RANK
    eps0=1e-3; Xc=np.clip(X,0.0,1.0); Xlog0=np.log(Xc+eps0)
    W,_,_,_=np.linalg.lstsq(Xlog0,Y,rcond=None)
    A,S,Bt=np.linalg.svd(W,full_matrices=False)
    U0=A[:,:r]*np.sqrt(S[:r]); V0=Bt[:r,:].T*np.sqrt(S[:r])
    z0=Xlog0@U0; c0=Y.mean(axis=0)-z0.mean(axis=0)@V0.T
    h0=-(Xc*np.log(Xc+eps0)).sum(axis=1); denom=(h0@h0)+1e-8
    R0=Y-(z0@V0.T+c0); beta0=np.array([(h0@R0[:,d])/denom for d in range(C)])
    rho0=np.log(np.exp(eps0)-1.0)
    init=np.concatenate([U0.ravel(),V0.ravel(),c0.ravel(),[rho0],beta0])

    def obj_grad(p):
        i=0
        U=p[i:i+F*r].reshape(F,r); i+=F*r
        V=p[i:i+C*r].reshape(C,r); i+=C*r
        c=p[i:i+C]; i+=C
        rho=p[i]; i+=1
        beta=p[i:i+C]
        eps=_softplus(rho)+_DEL
        Xp=Xc+eps; Xlog=np.log(Xp); z=Xlog@U
        h=-(Xc*np.log(Xp)).sum(axis=1)
        Yhat=z@V.T+c+h[:,None]*beta
        E=Yhat-Y
        s=np.sqrt(1.0+(E/_HUB)**2)
        coef=1.0/(N*C)
        loss=( (_HUB**2)*(s-1.0) ).sum()*coef +0.5*_L2*((U**2).sum()+(V**2).sum()+(beta**2).sum())
        gY=coef*E/s
        dV=gY.T@z+_L2*V
        dc=gY.sum(axis=0)
        dz=gY@V
        dU=Xlog.T@dz+_L2*U
        dbeta=(gY*h[:,None]).sum(axis=0)+_L2*beta
        invXp=1.0/Xp
        S_eps=invXp@U
        dh_deps=-(Xc*invXp).sum(axis=1)
        drho=((dz*S_eps).sum() + ( (gY@beta)*dh_deps ).sum())*(1.0/(1.0+np.exp(-rho)))
        grad=np.concatenate([dU.ravel(),dV.ravel(),dc.ravel(),[drho],dbeta])
        return loss,grad

    res=minimize(lambda p: obj_grad(p)[0], init, jac=lambda p: obj_grad(p)[1], method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;:500})
    return res.x if res.success else init
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#5</span>
                    <span class="run-label">Run 2</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.870736
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-4"># EVOLVE-BLOCK-START
import numpy as np

_P_LEN = 35  # p(5), q(5), a(5), g(5), d(5), eta(5), b(5)

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))
    if X.shape[1] != 5:
        raise ValueError(&quot;Expected 5 domain proportion features.&quot;)
    p = np.asarray(params, dtype=np.float64)
    if p.ndim == 2:
        p = p[0]
    if p.size != _P_LEN:
        raise ValueError(f&quot;Expected {_P_LEN} parameters, got {p.size}.&quot;)
    off = 0
    pv = p[off:off+5]; off += 5
    qv = p[off:off+5]; off += 5
    av = p[off:off+5]; off += 5
    gv = p[off:off+5]; off += 5
    dv = p[off:off+5]; off += 5
    et = p[off:off+5]; off += 5
    b  = p[off:off+5]
    s = X @ pv
    z = (X @ av) ** 2
    s2 = np.sum(X * X, axis=1)
    return b[None, :] + X * dv[None, :] + np.outer(s, qv) + np.outer(z, gv) + s2[:, None] * et[None, :]

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))
    Y = np.atleast_2d(np.asarray(loss_values, dtype=np.float64))
    N, F = X.shape
    if F != 5 or Y.shape != (N, 5):
        raise ValueError(&quot;Shapes must be (N,5) for both data_points and loss_values.&quot;)
    s2 = np.sum(X * X, axis=1)
    ones = np.ones(N, dtype=np.float64)

    # Output weighting for balanced fit
    var = np.var(Y, axis=0) + 1e-8
    w_out = (1.0 / var)
    w_out /= np.mean(w_out)

    # PCA-like init on centered simplex
    Xc = X - 0.2
    U, _, Vt = np.linalg.svd(Xc, full_matrices=False)
    p = Vt[0].astype(np.float64) if Vt.shape[0] &gt; 0 else np.array([1,-1,0,0,0.], dtype=np.float64)
    a = Vt[1].astype(np.float64) if Vt.shape[0] &gt; 1 else np.array([0,1,-1,0,0.], dtype=np.float64)
    for v in (p, a):
        v -= v.mean()
        nrm = np.linalg.norm(v); v /= (nrm if nrm &gt; 1e-12 else 1.0)
    a = a - p * float(np.dot(a, p))
    a -= a.mean()
    a /= max(np.linalg.norm(a), 1e-12)

    alpha = 1e-3
    I5 = np.eye(5)

    def fit_linear_blocks(pv, av):
        s = X @ pv
        z = (X @ av) ** 2
        B = np.empty(5); D = np.empty(5); Q = np.empty(5); G = np.empty(5); E = np.empty(5)
        for o in range(5):
            Phi = np.column_stack((ones, X[:, o], s, z, s2))
            XtX = Phi.T @ Phi
            # stabilized ridge using diagonal of XtX
            theta = np.linalg.solve(XtX + alpha * (np.diag(np.diag(XtX)) + I5), Phi.T @ Y[:, o])
            B[o], D[o], Q[o], G[o], E[o] = theta
        return B, D, Q, G, E

    def wmse(pv, av, B, D, Q, G, E):
        s = X @ pv
        z = (X @ av) ** 2
        pred = B[None, :] + X * D[None, :] + np.outer(s, Q) + np.outer(z, G) + s2[:, None] * E[None, :]
        return np.mean(((pred - Y) ** 2) * w_out[None, :])

    B, D, Q, G, E = fit_linear_blocks(p, a)
    best = wmse(p, a, B, D, Q, G, E)

    for _ in range(80):
        # Closed-form update for p with output weights
        z = (X @ a) ** 2
        R = Y - (B[None, :] + X * D[None, :] + np.outer(z, G) + s2[:, None] * E[None, :])
        Qw = Q * w_out
        qtq = float(np.dot(Qw, Qw)) + 1e-12
        C = qtq * (X.T @ X) + 1e-4 * I5
        r = (X * (R @ Qw)[:, None]).sum(axis=0)
        p_new = np.linalg.solve(C, r)
        p_new -= p_new.mean()
        p_new /= max(np.linalg.norm(p_new), 1e-12)

        # Gradient update for a with projection and backtracking
        s = X @ p_new
        pred_lin = B[None, :] + X * D[None, :] + np.outer(s, Q) + s2[:, None] * E[None, :]
        ax = X @ a
        z = ax ** 2
        Rfull = pred_lin + np.outer(z, G) - Y
        dz = (2.0 / (N * 5)) * ((Rfull * w_out[None, :]) @ G)
        grad_a = ((dz * 2.0 * ax)[:, None] * X).sum(axis=0)
        # project gradient
        grad_a = grad_a - p_new * float(np.dot(grad_a, p_new))
        grad_a -= grad_a.mean()

        t = 0.8
        a_new = a.copy()
        base = best
        for _ls in range(12):
            cand = a - t * grad_a
            cand -= cand.mean()
            cand = cand - p_new * float(np.dot(cand, p_new))
            cand /= max(np.linalg.norm(cand), 1e-12)
            Bc, Dc, Qc, Gc, Ec = fit_linear_blocks(p_new, cand)
            cur = wmse(p_new, cand, Bc, Dc, Qc, Gc, Ec)
            if cur &lt;= base - 1e-10:
                a_new = cand
                B, D, Q, G, E = Bc, Dc, Qc, Gc, Ec
                best = cur
                break
            t *= 0.5
        else:
            # If no improvement, still refit with updated p
            B, D, Q, G, E = fit_linear_blocks(p_new, a)
            best = wmse(p_new, a, B, D, Q, G, E)
            a_new = a

        a = a_new
        p = p_new
        if t &lt; 1e-4 or best &lt; 1e-12:
            break

    return np.concatenate([p, Q, a, G, D, E, B])
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        </div>
        
        <footer class="footer">
            <p>SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> | <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a></p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleRun(header) {
            const content = header.nextElementSibling;
            const isExpanded = content.style.display === 'block';
            content.style.display = isExpanded ? 'none' : 'block';
            header.classList.toggle('expanded', !isExpanded);
        }
        
        function copyCode(event, codeId) {
            event.stopPropagation();
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }
        
        Prism.highlightAll();
    </script>
</body>
</html>
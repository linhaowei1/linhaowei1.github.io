<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLD - Domain Mixture Scaling Law - SLDAgent + GPT-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --accent-primary: #2563eb;
        --accent-secondary: #3b82f6;
        --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
        --text-primary: #1f2937;
        --text-secondary: #4b5563;
        --border-subtle: rgba(0, 0, 0, 0.1);
        --glass-bg: rgba(0, 0, 0, 0.02);
        --success: #10b981;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          "Sora",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
      }

      .bg-pattern {
        display: none;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--accent-primary);
        text-decoration: none;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
        transition: color 0.2s;
      }

      .back-link:hover {
        color: var(--accent-secondary);
      }

      .header {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .meta-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .meta-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .r2-badge {
        display: inline-block;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", monospace;
      }

      .section-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .runs-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .run-card {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        overflow: hidden;
        transition: border-color 0.2s;
      }

      .run-card:hover {
        border-color: rgba(99, 102, 241, 0.3);
      }

      .run-card.best-run {
        border-color: var(--success);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
      }

      .run-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        transition: background 0.2s;
      }

      .run-header:hover {
        background: rgba(255, 255, 255, 0.04);
      }

      .run-info {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .run-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-secondary);
      }

      .run-badge.best-badge {
        background: var(--success);
        color: white;
      }

      .run-label {
        font-weight: 500;
        color: var(--text-primary);
      }

      .expand-icon {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: transform 0.2s;
      }

      .run-header.expanded .expand-icon {
        transform: rotate(180deg);
      }

      .run-content {
        border-top: 1px solid var(--border-subtle);
      }

      .code-container {
        overflow: hidden;
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.25rem;
        background: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid var(--border-subtle);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .copy-btn {
        padding: 0.35rem 0.75rem;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--accent-primary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-container pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        background: transparent !important;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid var(--border-subtle);
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .footer a {
        color: var(--accent-primary);
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .meta-row {
          flex-direction: column;
          gap: 0.75rem;
        }

        .run-info {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <a href="index.html" class="back-link"> ← Back to Leaderboard </a>

      <div class="header">
        <h1>Domain Mixture Scaling Law</h1>
        <div class="meta-row">
          <div class="meta-item">
            <span class="meta-label">Agent:</span>
            <span class="meta-value">SLDAgent</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Model:</span>
            <span class="meta-value">GPT-5</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Best R²:</span>
            <span class="r2-badge" style="background-color: #006400; color: white"> 0.998312 </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Mean R²:</span>
            <span class="meta-value">0.996213</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Min R²:</span>
            <span class="meta-value">0.990296</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Runs:</span>
            <span class="meta-value">5</span>
          </div>
        </div>
      </div>

      <h2 class="section-title">All Runs (sorted by R²)</h2>

      <div class="runs-container">
        <div class="run-card best-run">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge best-badge">Best</span>
              <span class="run-label">Run 3</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.998312 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: block">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-0"># EVOLVE-BLOCK-START
import numpy as np

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, float))
    N, F = X.shape
    p = np.asarray(params, float).ravel()
    L = p.size
    Xc = np.clip(X, 1e-12, 1.0)
    # Preferred: per-output alpha, layout L = T*(F+2) =&gt; [b(T), W(T*F), a(T)]
    if L &gt; 0 and L % (F + 2) == 0:
        T = L // (F + 2)
        b = p[:T]
        W = p[T:T + T * F].reshape(T, F)
        a = p[-T:]
        Z = Xc[:, None, :] ** a[None, :, None]
        return (Z * W[None]).sum(2) + b
    # Shared alpha: L = (F+1)*T + 1
    if L &gt; 1 and (L - 1) % (F + 1) == 0:
        T = (L - 1) // (F + 1)
        b = p[:T]; W = p[T:T + T * F].reshape(T, F); a = float(p[-1])
        return (Xc ** a) @ W.T + b
    # Linear fallback: L = (F+1)*T
    if L &gt; 0 and L % (F + 1) == 0:
        T = L // (F + 1)
        B = p.reshape(T, F + 1)
        ZA = np.concatenate([np.ones((N, 1)), X], 1)
        return ZA @ B.T
    T = min(5, L if L &gt; 0 else 1)
    return np.tile(p[:T][None, :], (N, 1))


def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, float))
    Y = np.asarray(loss_values, float)
    if Y.ndim == 1: Y = Y[:, None]
    N, F = X.shape; T = Y.shape[1]
    Xc = np.clip(X, 1e-12, 1.0)
    lam_b = 1e-8
    lam_grid = np.array([1e-6, 3e-6, 1e-5, 3e-5, 1e-4, 3e-4], float)
    a_min, a_max = 0.2, 3.0
    phi = (1 + 5 ** 0.5) / 2

    def nmse_cols(y, yhat):
        v = np.var(y, axis=0, ddof=0) + 1e-12
        return np.mean(((yhat - y) ** 2) / v)

    def solve_scaled(Z, Ymat, lam):
        s = np.sqrt((Z ** 2).mean(0)) + 1e-12
        Zs = Z / s
        ZA = np.concatenate([np.ones((N, 1)), Zs], 1)
        A = ZA.T @ ZA
        A[0, 0] += lam_b
        A[1:, 1:] += lam * np.eye(F)
        try:
            B = np.linalg.solve(A, ZA.T @ Ymat)
        except np.linalg.LinAlgError:
            B = np.linalg.lstsq(A + 1e-12 * np.eye(F + 1), ZA.T @ Ymat, rcond=None)[0]
        b = B[0, :]
        W = (B[1:, :].T) / s
        return W, b

    def best_ridge(Z, Ymat):
        best, Wb = np.inf, None
        for lam in lam_grid:
            W, b = solve_scaled(Z, Ymat, lam)
            val = nmse_cols(Ymat, Z @ W.T + b)
            if val &lt; best:
                best, Wb = val, (W, b)
        return best, Wb

    def shared_obj(a):
        Z = Xc ** float(a)
        v, _ = best_ridge(Z, Y)
        return v

    # Shared alpha (multi-output) via coarse grid + golden section
    grid = np.linspace(0.3, 2.5, 9)
    a_shared = grid[np.argmin([shared_obj(a) for a in grid])]
    Lb, Ub = max(a_min, a_shared - 0.7), min(a_max, a_shared + 0.7)
    c = Ub - (Ub - Lb) / phi
    d = Lb + (Ub - Lb) / phi
    vc, vd = shared_obj(c), shared_obj(d)
    for _ in range(22):
        if vc &lt; vd:
            Ub, d, vd = d, c, vc
            c = Ub - (Ub - Lb) / phi
            vc = shared_obj(c)
        else:
            Lb, c, vc = c, d, vd
            d = Lb + (Ub - Lb) / phi
            vd = shared_obj(d)
    a_shared = c if vc &lt; vd else d

    # Per-output refinement with coupling penalty to a_shared and lam selection
    rho = 1e-3
    bs, Ws, alphas = [], [], []

    def fit_for_alpha(y, a):
        Z = Xc ** float(a)
        best, Wb = np.inf, None
        for lam in lam_grid:
            W, b = solve_scaled(Z, y, lam)
            pred = Z @ W.T + b
            v = float(np.var(y, ddof=0) + 1e-12)
            nm = float(np.mean((pred - y) ** 2) / v)
            if nm &lt; best:
                best, Wb = nm, (b[0], W[0])
        return best, Wb

    for t in range(T):
        y = Y[:, t:t+1]
        # coarse search
        vals = [fit_for_alpha(y, a) for a in grid]
        idx = np.argmin([nm + rho * (a - a_shared) ** 2 for (nm, _), a in zip(vals, grid)])
        a0 = grid[idx]
        # refine by golden section
        Lb, Ub = max(a_min, a0 - 0.7), min(a_max, a0 + 0.7)
        c = Ub - (Ub - Lb) / phi; d = Lb + (Ub - Lb) / phi
        nc, Bc = fit_for_alpha(y, c); vc = nc + rho * (c - a_shared) ** 2
        nd, Bd = fit_for_alpha(y, d); vd = nd + rho * (d - a_shared) ** 2
        for _ in range(22):
            if vc &lt; vd:
                Ub, d, vd, Bd = d, c, vc, Bc
                c = Ub - (Ub - Lb) / phi
                nc, Bc = fit_for_alpha(y, c); vc = nc + rho * (c - a_shared) ** 2
            else:
                Lb, c, vc, Bc = c, d, vd, Bd
                d = Lb + (Ub - Lb) / phi
                nd, Bd = fit_for_alpha(y, d); vd = nd + rho * (d - a_shared) ** 2
        a_opt, B_opt = (c, Bc) if vc &lt; vd else (d, Bd)
        alphas.append(a_opt); bs.append(B_opt[0]); Ws.append(B_opt[1])

    b = np.asarray(bs)
    W = np.vstack(Ws)
    a = np.asarray(alphas)
    return np.concatenate([b, W.ravel(), a])
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#2</span>
              <span class="run-label">Run 2</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.998092 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-1"># EVOLVE-BLOCK-START
import numpy as np

def _phi_gv(X, gammas):
    X = np.atleast_2d(np.asarray(X, dtype=float))
    g = np.asarray(gammas, dtype=float).ravel()
    if g.size != 5:
        raise ValueError(&quot;Expected 5 gamma parameters for 5 domains.&quot;)
    g = np.clip(g, 0.25, 3.0)
    Z = np.power(np.clip(X, 1e-12, 1.0), g, dtype=float)  # (N,5) elementwise exponents
    return np.concatenate([Z, np.ones((X.shape[0], 1), float)], axis=1)  # (N,6)

def _ridge_multi_scaled(Phi, Y, lam_scale=1e-3):
    # Multi-target ridge with column scaling for conditioning; no penalty on bias (last column)
    D = Phi.shape[1]
    col_var = np.mean(Phi**2, axis=0)
    s = np.sqrt(np.maximum(col_var, 1e-12))
    s[-1] = 1.0
    Phis = Phi / s
    XtX = Phis.T @ Phis
    lam = lam_scale * (np.trace(XtX) / (D + 1e-8))
    R = np.eye(D); R[-1, -1] = 0.0
    A = XtX + lam * R
    B = Phis.T @ Y
    try:
        Wscaled = np.linalg.solve(A, B)
    except np.linalg.LinAlgError:
        Wscaled = np.linalg.pinv(A) @ B
    return (Wscaled.T) / s[None, :]  # (T,D)

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    P = np.asarray(params, dtype=float).ravel()
    if P.size &lt; 7:
        raise ValueError(&quot;Params must have at least 7 elements.&quot;)
    # Support both single-gamma and per-domain gammas for backward compatibility
    if (P.size - 1) % 6 == 0 and (P.size - 1) // 6 &gt;= 1:
        # Single shared gamma + weights
        gamma = float(P[0])
        Phi = _phi_gv(X, [gamma]*5)
        W = P[1:].reshape(((P.size - 1)//6), 6)
        Y = Phi @ W.T
    else:
        # Five gammas + weights
        gammas = P[:5]
        Phi = _phi_gv(X, gammas)
        rest = P[5:]
        T = rest.size // 6
        if rest.size % 6 != 0 or T &lt; 1:
            raise ValueError(&quot;Weight segment must be a multiple of 6.&quot;)
        W = rest.reshape(T, 6)
        Y = Phi @ W.T
    return Y[:, 0] if Y.shape[1] == 1 else Y

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    Y = np.asarray(loss_values, dtype=float)
    if Y.ndim == 1:
        Y = Y[:, None]
    T = Y.shape[1]

    def mse_for_gv(gv):
        Phi = _phi_gv(X, gv)
        W = _ridge_multi_scaled(Phi, Y)
        E = Phi @ W.T - Y
        return float(np.mean(E**2))

    # Golden-section 1D minimizer
    def gsearch(f, lo=0.25, hi=3.0, iters=24, x0=None):
        a, b = lo, hi
        gr = (np.sqrt(5.0) - 1.0) / 2.0
        c = b - gr*(b-a)
        d = a + gr*(b-a)
        fc, fd = f(c), f(d)
        for _ in range(iters):
            if fc &gt; fd:
                a, c, fc = c, d, fd
                d = a + gr*(b-a); fd = f(d)
            else:
                b, d, fd = d, c, fc
                c = b - gr*(b-a); fc = f(c)
        return 0.5*(a+b)

    # Initialize with shared gamma optimum for a good starting point
    def obj_shared(g):
        return mse_for_gv([g]*5)
    g0 = gsearch(obj_shared, 0.25, 2.5, iters=24)
    gammas = np.array([g0]*5, float)

    # Coordinate descent on per-domain gammas
    prev = mse_for_gv(gammas)
    for _ in range(3):
        for j in range(5):
            def fj(gj):
                gv = gammas.copy()
                gv[j] = gj
                return mse_for_gv(gv)
            gammas[j] = gsearch(fj, 0.25, 3.0, iters=20)
        cur = mse_for_gv(gammas)
        if prev - cur &lt; 1e-6:
            break
        prev = cur

    # Final weights
    Phi_opt = _phi_gv(X, gammas)
    Wopt = _ridge_multi_scaled(Phi_opt, Y)  # (T,6)

    return np.concatenate([gammas.ravel(), Wopt.ravel()])
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#3</span>
              <span class="run-label">Run 1</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.997210 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-2"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

# 33-parameter model: b[5], a[5], u[5], q[5], v[5], w2[5], beta, gamma, eps
_PLEN = 33

def _pad(params):
    w = np.asarray(params, float).ravel()
    if w.size &gt;= _PLEN: return w[:_PLEN]
    wp = np.zeros(_PLEN, float); wp[:w.size] = w
    if w.size &lt;= 30: wp[30] = 0.8; wp[31] = 1.0; wp[32] = 1e-3
    elif w.size == 31: wp[31] = 1.0; wp[32] = 1e-3
    elif w.size == 32: wp[32] = 1e-3
    return wp

def _unpack(w):
    return (w[0:5], w[5:10], w[10:15], w[15:20], w[20:25], w[25:30], w[30], w[31], w[32])

def _predict(X, w):
    b,a,u,q,v,w2,beta,gamma,eps = _unpack(w)
    Xc = np.clip(X, 1e-12, 1.0)
    s = Xc @ v; s2 = s*s
    self_term = (Xc + eps) ** beta
    t = np.sum(Xc ** gamma, axis=1)
    Y = b[None,:] + u[None,:]*s[:,None] + w2[None,:]*s2[:,None] + q[None,:]*t[:,None] + a[None,:]*self_term
    return Y, s, s2, t, self_term, Xc

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, float)); assert X.shape[1]==5
    Y, *_ = _predict(X, _pad(params))
    return np.clip(Y, 0.5, 8.0)

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, float))
    Y = np.atleast_2d(np.asarray(loss_values, float))
    if Y.ndim==1: Y = Y[:,None]
    assert X.shape[1]==5 and Y.shape[1]==5
    b0 = np.clip(Y.mean(axis=0), 0.5, 8.0)
    a0 = -0.5*np.ones(5); u0 = 0.1*np.ones(5); q0 = np.zeros(5)
    v0 = np.ones(5)/5.0; w20 = np.zeros(5)
    init = np.concatenate([b0,a0,u0,q0,v0,w20,[0.8,1.0,1e-3]])
    bounds = [(0.5,8.0)]*5 + [(-5,5)]*5 + [(-5,5)]*5 + [(-5,5)]*5 + [(-5,5)]*5 + [(-5,5)]*5 + [(0.2,2.5)] + [(0.2,3.0)] + [(1e-6,0.1)]
    var = np.var(Y, axis=0) + 1e-8; w_out = 1.0/var; lam = 1e-3

    def obj_grad(w):
        w = _pad(w)
        Yh,s,s2,t,self_term,Xc = _predict(X,w)
        R = Yh - Y; m = R.size
        dY = (2.0/m) * w_out[None,:] * R
        b,a,u,q,v,w2,beta,gamma,eps = _unpack(w)
        gb = dY.sum(axis=0)
        gu = (dY * s[:,None]).sum(axis=0)
        gw2 = (dY * s2[:,None]).sum(axis=0)
        gq = (dY * t[:,None]).sum(axis=0)
        ga = (dY * self_term).sum(axis=0)
        dYds = u[None,:] + 2.0*w2[None,:]*s[:,None]
        gs = (dY * dYds).sum(axis=1)
        gv = X.T @ gs
        log_self = np.log(Xc + eps)
        gbeta = (dY * (a[None,:] * (self_term * log_self))).sum()
        geps = (dY * (a[None,:] * (beta * (Xc + eps) ** (beta - 1.0)))).sum()
        dt_dg = (Xc ** gamma * np.log(Xc)).sum(axis=1)
        ggamma = (dY * (q[None,:] * dt_dg[:,None])).sum()
        g = np.concatenate([gb,ga,gu,gq,gv,gw2,[gbeta,ggamma,geps]])
        obj = np.mean(w_out[None,:]*(R**2)) + lam*np.dot(w,w); g += 2*lam*w
        return obj, g

    best_x = init.copy(); best_f, _ = obj_grad(best_x)
    rng = np.random.default_rng(42)
    lo = np.array([b[0] for b in bounds]); hi = np.array([b[1] for b in bounds])
    for _ in range(6):
        j = rng.normal(0,0.1,size=init.shape); j[30:33] *= 0.25
        start = np.clip(init + j, lo, hi)
        res = minimize(lambda ww: obj_grad(ww), start, method=&#x27;L-BFGS-B&#x27;, jac=True, bounds=bounds,
                       options={&#x27;maxiter&#x27;: 700, &#x27;ftol&#x27;: 1e-10})
        val = res.fun if res.success else obj_grad(res.x)[0]
        if val &lt; best_f: best_f, best_x = val, _pad(res.x)
    return best_x
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#4</span>
              <span class="run-label">Run 4</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.997157 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-3"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

_EPS = 1e-12

def _parse_params(p, F):
    p = np.asarray(p).ravel()
    K = p.size
    T = int(round((K - 5) / (F + 1))) if K &gt;= F + 6 else F
    expK = T * (F + 1) + 5
    if expK != K:
        T = F
        expK = T * (F + 1) + 5
        if expK != K:
            raise ValueError(f&quot;Bad param length {K} for F={F}, expected {expK}.&quot;)
    i = 0
    b = p[i:i+T]; i += T
    W = p[i:i+T*F].reshape(T, F); i += T*F
    beta, s, t, c, u = p[i:i+5]
    return b, W, beta, s, t, c, u, T

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points))
    N, F = X.shape
    b, W, beta, s, t, c, u, T = _parse_params(params, F)
    Xp = np.clip(X, _EPS, 1.0)
    logXp = np.log(Xp)
    g = Xp ** beta
    phi = g / (1.0 + c * g)
    H = -(Xp * logXp).sum(axis=1)
    S2 = (Xp * Xp).sum(axis=1)
    HS = H * S2
    return phi @ W.T + b[None, :] + s * H[:, None] + t * S2[:, None] + u * HS[:, None]

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points))
    Y = np.asarray(loss_values)
    Y = Y[:, None] if Y.ndim == 1 else Y
    N, F = X.shape
    T = Y.shape[1]

    Xp = np.clip(X, _EPS, 1.0)
    logXp = np.log(Xp)
    H = -(Xp * logXp).sum(axis=1)
    S2 = (Xp * Xp).sum(axis=1)
    HS = H * S2

    b_init = np.mean(Y, axis=0)
    Yc = Y - b_init[None, :]
    reg_ls = 1e-4

    beta_grid = np.array([0.6, 0.8, 1.0, 1.2])
    c_grid = np.array([0.0, 0.05, 0.2, 0.5])
    best_mse = np.inf
    best_tuple, best_W = None, None

    M = np.stack([H, S2, HS], axis=1)  # N x 3
    MTM = M.T @ M
    for beta0 in beta_grid:
        g0 = Xp ** beta0
        for c0 in c_grid:
            denom0 = 1.0 + c0 * g0
            phi0 = g0 / denom0
            G = phi0.T @ phi0 + reg_ls * np.eye(F)
            W0 = np.empty((T, F))
            for j in range(T):
                W0[j] = np.linalg.solve(G, phi0.T @ Yc[:, j])

            E0 = phi0 @ W0.T + b_init[None, :] - Y  # NxT
            rhs = - (M.T @ E0.sum(axis=1)) / max(T, 1)
            try:
                s0, t0, u0 = np.linalg.solve(MTM + 1e-12 * np.eye(3), rhs)
            except np.linalg.LinAlgError:
                s0 = t0 = u0 = 0.0
            pred0 = phi0 @ W0.T + b_init[None, :] + s0 * H[:, None] + t0 * S2[:, None] + u0 * HS[:, None]
            mse0 = np.mean((pred0 - Y) ** 2)
            if mse0 &lt; best_mse:
                best_mse = mse0
                best_tuple = (beta0, s0, t0, c0, u0)
                best_W = W0

    beta0, s0, t0, c0, u0 = best_tuple
    init = np.concatenate([b_init, best_W.ravel(), np.array([beta0, s0, t0, c0, u0])])

    lambda_w = 1e-3
    lambda_c = 1e-4
    lambda_beta = 5e-5
    lambda_u = 5e-5

    def objective(p):
        b, W, beta, s, t, c, u, _ = _parse_params(p, F)
        g = Xp ** beta
        phi = g / (1.0 + c * g)
        pred = phi @ W.T + b[None, :] + s * H[:, None] + t * S2[:, None] + u * HS[:, None]
        E = pred - Y
        return (E**2).mean() + lambda_w * (W**2).mean() + lambda_c * c * c + lambda_beta * (beta - 1.0) ** 2 + lambda_u * u * u

    def gradient(p):
        b, W, beta, s, t, c, u, _ = _parse_params(p, F)
        g = Xp ** beta
        denom = 1.0 + c * g
        phi = g / denom
        pred = phi @ W.T + b[None, :] + s * H[:, None] + t * S2[:, None] + u * HS[:, None]
        E = pred - Y
        fac = 2.0 / N

        db = fac * E.sum(axis=0)
        dW = fac * (E.T @ phi) + (2.0 * lambda_w / (T * F)) * W

        dgd_beta = g * logXp
        dphi_dbeta = dgd_beta / (denom * denom)
        dphi_dc = -(g * g) / (denom * denom)

        d_beta = fac * np.sum(E * (dphi_dbeta @ W.T)) + 2.0 * lambda_beta * (beta - 1.0)
        d_c = fac * np.sum(E * (dphi_dc @ W.T)) + 2.0 * lambda_c * c
        d_s = fac * np.sum(E * H[:, None])
        d_t = fac * np.sum(E * S2[:, None])
        d_u = fac * np.sum(E * HS[:, None]) + 2.0 * lambda_u * u

        return np.concatenate([db, dW.ravel(), np.array([d_beta, d_s, d_t, d_c, d_u])])

    bounds = [(None, None)] * (T + T * F) + [(0.25, 3.0), (-3.0, 3.0), (-3.0, 3.0), (0.0, 5.0), (-3.0, 3.0)]
    res = minimize(objective, init, method=&#x27;L-BFGS-B&#x27;, jac=gradient,
                   bounds=bounds, options={&#x27;maxiter&#x27;: 400, &#x27;ftol&#x27;: 1e-9})
    return res.x if res.success else init
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#5</span>
              <span class="run-label">Run 5</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.990296 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-4"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

_F=5; _EPS=1e-12; _EMIN,_EMAX=0.3,3.0

def _unpack(p):
    p=np.asarray(p).ravel()
    b=p[:_F] if p.size&gt;=_F else np.zeros(_F)
    W=p[_F:_F+_F*_F] if p.size&gt;=_F+_F*_F else np.zeros(_F*_F)
    W=W.reshape(_F,_F)
    e=p[_F+_F*_F:_F+_F*_F+_F] if p.size&gt;=_F+_F*_F+_F else np.ones(_F)
    return b,W,np.clip(e,_EMIN,_EMAX)

def _pack(b,W,e): return np.concatenate([b.ravel(),W.ravel(),e.ravel()])

def scaling_law_func(data_points, params):
    X=np.atleast_2d(np.asarray(data_points,float))
    if X.shape[1]!=_F: raise ValueError(&quot;Expected (N,5) domain proportions&quot;)
    b,W,e=_unpack(params)
    Xp=np.clip(X,_EPS,1.0)**e[None,:]
    return b[None,:]+Xp@W.T

def fit_scaling_law(data_points, loss_values):
    X=np.atleast_2d(np.asarray(data_points,float)); Y=np.atleast_2d(np.asarray(loss_values,float))
    if X.shape[1]!=_F or Y.shape[1]!=_F: raise ValueError(&quot;Expected (N,5) inputs/targets&quot;)
    N=X.shape[0]; Xeps=np.clip(X,_EPS,1.0); LnX=np.log(Xeps)
    lam_b,lam_W,lam_e=1e-3,1e-3,1e-3
    fac=2.0/(N*_F)

    def solve_bw(e):
        Xp=Xeps**e[None,:]
        Phi=np.concatenate([np.ones((N,1)),Xp],axis=1)     # (N,6)
        R=np.diag(np.concatenate([[lam_b],np.full(_F,lam_W)]))
        A=Phi.T@Phi+R; B=Phi.T@Y
        try: M=np.linalg.solve(A,B)
        except np.linalg.LinAlgError: M=np.linalg.lstsq(A,B,rcond=None)[0]
        b=M[0,:]; W=M[1:,:].T
        P=Phi@M
        mse=np.mean((P-Y)**2)
        return b,W,Xp,P,mse

    def obj_grad(e):
        e=np.clip(e,_EMIN,_EMAX)
        b,W,Xp,P,mse=solve_bw(e)
        R=P-Y
        RW=R@W
        ge=fac*np.sum(RW*Xp*LnX,axis=0)+2*lam_e*(e-1.0)
        reg=lam_b*np.sum(b*b)+lam_W*np.sum(W*W)+lam_e*np.sum((e-1.0)**2)
        return mse+reg,ge

    def obj(e): return obj_grad(e)[0]
    def grad(e): return obj_grad(e)[1]

    best_e=None; best_val=np.inf
    inits=[np.ones(_F),np.full(_F,0.8),np.full(_F,1.2)]
    rng=np.random.default_rng(42)
    for _ in range(4): inits.append(np.clip(1.0+rng.normal(0,0.25,_F),_EMIN,_EMAX))
    bounds=[(_EMIN,_EMAX)]*_F
    for e0 in inits:
        res=minimize(obj,e0,method=&#x27;L-BFGS-B&#x27;,jac=grad,bounds=bounds,options={&#x27;maxiter&#x27;:400,&#x27;ftol&#x27;:1e-9})
        val=res.fun if res.success else obj(res.x)
        if val&lt;best_val: best_val=val; best_e=np.clip(res.x,_EMIN,_EMAX)
    b,W,_,_,_=solve_bw(best_e)
    return _pack(b,W,best_e)
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> |
          <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a>
        </p>
      </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      function toggleRun(header) {
        const content = header.nextElementSibling;
        const isExpanded = content.style.display === "block";
        content.style.display = isExpanded ? "none" : "block";
        header.classList.toggle("expanded", !isExpanded);
      }

      function copyCode(event, codeId) {
        event.stopPropagation();
        const code = document.getElementById(codeId).textContent;
        navigator.clipboard.writeText(code).then(() => {
          const btn = event.target;
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 2000);
        });
      }

      Prism.highlightAll();
    </script>
  </body>
</html>

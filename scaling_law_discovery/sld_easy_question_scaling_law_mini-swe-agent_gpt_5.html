<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLD - U-shaped Scaling Law - mini-swe-agent + GPT-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --accent-primary: #2563eb;
        --accent-secondary: #3b82f6;
        --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
        --text-primary: #1f2937;
        --text-secondary: #4b5563;
        --border-subtle: rgba(0, 0, 0, 0.1);
        --glass-bg: rgba(0, 0, 0, 0.02);
        --success: #10b981;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          "Sora",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
      }

      .bg-pattern {
        display: none;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--accent-primary);
        text-decoration: none;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
        transition: color 0.2s;
      }

      .back-link:hover {
        color: var(--accent-secondary);
      }

      .header {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .meta-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .meta-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .r2-badge {
        display: inline-block;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", monospace;
      }

      .section-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .runs-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .run-card {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        overflow: hidden;
        transition: border-color 0.2s;
      }

      .run-card:hover {
        border-color: rgba(99, 102, 241, 0.3);
      }

      .run-card.best-run {
        border-color: var(--success);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
      }

      .run-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        transition: background 0.2s;
      }

      .run-header:hover {
        background: rgba(255, 255, 255, 0.04);
      }

      .run-info {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .run-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-secondary);
      }

      .run-badge.best-badge {
        background: var(--success);
        color: white;
      }

      .run-label {
        font-weight: 500;
        color: var(--text-primary);
      }

      .expand-icon {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: transform 0.2s;
      }

      .run-header.expanded .expand-icon {
        transform: rotate(180deg);
      }

      .run-content {
        border-top: 1px solid var(--border-subtle);
      }

      .code-container {
        overflow: hidden;
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.25rem;
        background: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid var(--border-subtle);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .copy-btn {
        padding: 0.35rem 0.75rem;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--accent-primary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-container pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        background: transparent !important;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid var(--border-subtle);
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .footer a {
        color: var(--accent-primary);
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .meta-row {
          flex-direction: column;
          gap: 0.75rem;
        }

        .run-info {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <a href="index.html" class="back-link"> ← Back to Leaderboard </a>

      <div class="header">
        <h1>U-shaped Scaling Law</h1>
        <div class="meta-row">
          <div class="meta-item">
            <span class="meta-label">Agent:</span>
            <span class="meta-value">mini-swe-agent</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Model:</span>
            <span class="meta-value">GPT-5</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Best R²:</span>
            <span class="r2-badge" style="background-color: #d2691e; color: white"> 0.302510 </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Mean R²:</span>
            <span class="meta-value">-0.491199</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Min R²:</span>
            <span class="meta-value">-1.000000</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Runs:</span>
            <span class="meta-value">5</span>
          </div>
        </div>
      </div>

      <h2 class="section-title">All Runs (sorted by R²)</h2>

      <div class="runs-container">
        <div class="run-card best-run">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge best-badge">Best</span>
              <span class="run-label">Run 1</span>
              <span class="r2-badge" style="background-color: #d2691e; color: white"> R² = 0.302510 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: block">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-0"># Auto-generated convex (U-shaped) quadratic scaling law: brier_score vs log_flops
from typing import List, Dict

# y = a * (x - c)**2 + b, x = log_flops, y = brier_score
_COEFS: dict[str, dict[str, float]] = {
  &quot;__default__&quot;: {
    &quot;a&quot;: 0.016435167540703028,
    &quot;b&quot;: -0.42693678124584933,
    &quot;c&quot;: -1.6953621257789337
  },
  &quot;abstract_narrative_understanding&quot;: {
    &quot;a&quot;: 0.03559099077642667,
    &quot;b&quot;: -0.644905899063743,
    &quot;c&quot;: -1.6953621257789337
  },
  &quot;analogical_similarity&quot;: {
    &quot;a&quot;: 0.00015458082325933974,
    &quot;b&quot;: -0.5443035235943459,
    &quot;c&quot;: -1.6056066401185167
  },
  &quot;arc&quot;: {
    &quot;a&quot;: 0.010326836994446163,
    &quot;b&quot;: -0.1361076284330853,
    &quot;c&quot;: -1.6953621257789337
  },
  &quot;arithmetic&quot;: {
    &quot;a&quot;: 0.015354018314906261,
    &quot;b&quot;: -0.31591913431197544,
    &quot;c&quot;: -1.5743719559664417
  },
  &quot;conceptual_combinations&quot;: {
    &quot;a&quot;: 0.011559745311168344,
    &quot;b&quot;: -0.4646413787056248,
    &quot;c&quot;: -1.4823777596427932
  },
  &quot;hellaswag&quot;: {
    &quot;a&quot;: 0.007609182534322093,
    &quot;b&quot;: -0.08846707981157574,
    &quot;c&quot;: -1.6953621257789337
  },
  &quot;hindu_knowledge&quot;: {
    &quot;a&quot;: 0.01020143688094949,
    &quot;b&quot;: -0.4433503348958553,
    &quot;c&quot;: 1.2992805614553293
  },
  &quot;mmlu&quot;: {
    &quot;a&quot;: 0.01625188241125213,
    &quot;b&quot;: -0.5485520085426114,
    &quot;c&quot;: 2.0141120689193435
  },
  &quot;parsinlu_qa_mc&quot;: {
    &quot;a&quot;: 1e-08,
    &quot;b&quot;: -0.4342415825508818,
    &quot;c&quot;: -1.6953621257789337
  }
}

def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    params = _COEFS.get(group, _COEFS[&quot;__default__&quot;])
    a = float(params[&quot;a&quot;])  # curvature (&gt;= 0)
    b = float(params[&quot;b&quot;])  # minimum brier_score at optimal c
    c = float(params[&quot;c&quot;])  # optimal log_flops (vertex)

    outputs: list[dict[str, float]] = []
    for row in input_data:
        x = float(row[&quot;log_flops&quot;]) 
        y = a * (x - c) ** 2 + b
        outputs.append({&quot;brier_score&quot;: float(y)})
    return outputs</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#2</span>
              <span class="run-label">Run 2</span>
              <span class="r2-badge" style="background-color: #d2691e; color: white"> R² = 0.241497 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-1">def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    # Convex U-shaped scaling law in log_flops:
    # Vertex form: brier_score = a * (log_flops - c)**2 + b with a &gt;= 0
    # Implemented via equivalent polynomial coefficients:
    # brier_score = a2 * (log_flops**2) + a1 * log_flops + a0, where a2 = a, a1 = -2*a*c, a0 = a*c**2 + b
    coeffs = {
  &quot;abstract_narrative_understanding&quot;: {
    &quot;a2&quot;: 0.027345297981454717,
    &quot;a1&quot;: 0.136239459030282,
    &quot;a0&quot;: -0.5439812284717438
  },
  &quot;analogical_similarity&quot;: {
    &quot;a2&quot;: 0.00022819303071987078,
    &quot;a1&quot;: 0.0010549746377413957,
    &quot;a0&quot;: -0.5445517480226065
  },
  &quot;arc&quot;: {
    &quot;a2&quot;: 0.008151806820498677,
    &quot;a1&quot;: 0.040613847108095076,
    &quot;a0&quot;: -0.10844709861781436
  },
  &quot;arithmetic&quot;: {
    &quot;a2&quot;: 0.012583964497968407,
    &quot;a1&quot;: 0.056605552958780614,
    &quot;a0&quot;: -0.28129715701407854
  },
  &quot;conceptual_combinations&quot;: {
    &quot;a2&quot;: 0.009268857989096976,
    &quot;a1&quot;: 0.038282720441071054,
    &quot;a0&quot;: -0.4396996360981997
  },
  &quot;hellaswag&quot;: {
    &quot;a2&quot;: 0.006045219218956594,
    &quot;a1&quot;: 0.030118428282210164,
    &quot;a0&quot;: -0.06837445680140108
  },
  &quot;hindu_knowledge&quot;: {
    &quot;a2&quot;: 0.007961278176978049,
    &quot;a1&quot;: -0.027690321689855524,
    &quot;a0&quot;: -0.42519247446304
  },
  &quot;mmlu&quot;: {
    &quot;a2&quot;: 0.012201937081809734,
    &quot;a1&quot;: -0.06337345377976922,
    &quot;a0&quot;: -0.4806948100054965
  },
  &quot;parsinlu_qa_mc&quot;: {
    &quot;a2&quot;: 0.00032104940646667657,
    &quot;a1&quot;: 0.0015995290118497466,
    &quot;a0&quot;: -0.4366374889008974
  }
}
    default_coeffs = {
  &quot;a2&quot;: 0.012506015226011717,
  &quot;a1&quot;: 0.06230733891332299,
  &quot;a0&quot;: -0.3797213963831994
}
    params = coeffs.get(group, default_coeffs)
    a2 = params[&quot;a2&quot;]
    a1 = params[&quot;a1&quot;]
    a0 = params[&quot;a0&quot;]
    outputs: list[dict[str, float]] = []
    for row in input_data:
        x = float(row.get(&quot;log_flops&quot;, 0.0))
        y = a2 * (x ** 2) + a1 * x + a0
        outputs.append({&quot;brier_score&quot;: float(y)})
    return outputs</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#3</span>
              <span class="run-label">Run 3</span>
              <span class="r2-badge" style="background-color: #b22222; color: white"> R² = -1.000000 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-2"># Auto-generated scaling law implementation
from typing import List, Dict

# Quadratic coefficients per group for:
# brier_score_hat = a + b * log_flops + c * (log_flops)**2
COEFS: Dict[str, Dict[str, float]] = {
  &quot;abstract_narrative_understanding&quot;: {
    &quot;a&quot;: -0.5431407140744655,
    &quot;b&quot;: 0.18472699005645873,
    &quot;c&quot;: -0.001002095718967912
  },
  &quot;analogical_similarity&quot;: {
    &quot;a&quot;: -0.5405750537735581,
    &quot;b&quot;: 0.0279112874834725,
    &quot;c&quot;: -0.019175879672698435
  },
  &quot;arc&quot;: {
    &quot;a&quot;: -0.1071122327154294,
    &quot;b&quot;: 0.11761949039897288,
    &quot;c&quot;: -0.036868206393668744
  },
  &quot;arithmetic&quot;: {
    &quot;a&quot;: -0.2475326777122078,
    &quot;b&quot;: 0.23537009797522832,
    &quot;c&quot;: -0.12997814962868387
  },
  &quot;conceptual_combinations&quot;: {
    &quot;a&quot;: -0.40934554313141813,
    &quot;b&quot;: 0.09692595522861085,
    &quot;c&quot;: -0.07148356706471508
  },
  &quot;hellaswag&quot;: {
    &quot;a&quot;: -0.06719686154646047,
    &quot;b&quot;: 0.09805145434945438,
    &quot;c&quot;: -0.033670645755682356
  },
  &quot;hindu_knowledge&quot;: {
    &quot;a&quot;: -0.4103174193780911,
    &quot;b&quot;: -0.031143510554884814,
    &quot;c&quot;: -0.034402388960081354
  },
  &quot;mmlu&quot;: {
    &quot;a&quot;: -0.480364650219835,
    &quot;b&quot;: -0.06297043488789662,
    &quot;c&quot;: 0.011476264280523694
  },
  &quot;parsinlu_qa_mc&quot;: {
    &quot;a&quot;: -0.43495071806820146,
    &quot;b&quot;: 0.0989058373264011,
    &quot;c&quot;: -0.05656739537407183
  }
}
DEFAULT_COEFS: Dict[str, float] = {
  &quot;a&quot;: -0.3784396938370407,
  &quot;b&quot;: 0.07737556836857276,
  &quot;c&quot;: 0.002644673247271387
}

def _get_x(d: Dict[str, float]) -&gt; float:
    if &quot;log_flops&quot; in d:
        return float(d[&quot;log_flops&quot;])
    if &quot;flops&quot; in d:
        import math
        return float(math.log(float(d[&quot;flops&quot;])))
    raise KeyError(&quot;Expected &#x27;log_flops&#x27; (or &#x27;flops&#x27;) in input datum.&quot;)

def law(input_data: List[Dict[str, float]], group: str) -&gt; List[Dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
               The functional form of the law is the same for all groups,
               but the constant parameters/coefficients differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    coefs = COEFS.get(group, DEFAULT_COEFS)
    a = float(coefs[&quot;a&quot;])
    b = float(coefs[&quot;b&quot;])
    c = float(coefs[&quot;c&quot;])
    preds: List[Dict[str, float]] = []
    for d in input_data:
        x = _get_x(d)
        yhat = a + b * x + c * (x ** 2)
        preds.append({&quot;brier_score&quot;: float(yhat)})
    return preds</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#4</span>
              <span class="run-label">Run 4</span>
              <span class="r2-badge" style="background-color: #b22222; color: white"> R² = -1.000000 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-3"># Auto-generated scaling law implementation
# Formula: brier_score = a * (log_flops**2) + b * log_flops + c
# Coefficients are fitted per group; a single functional form across groups.

from typing import List, Dict

def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    # Per-group coefficients (a, b, c) for: y = a*x^2 + b*x + c, with x = log_flops
    PARAMS = {
        &quot;abstract_narrative_understanding&quot;: (-0.00100209571897, 0.184726990056, -0.543140714074),
        &quot;analogical_similarity&quot;: (-0.0191758796727, 0.0279112874835, -0.540575053774),
        &quot;arc&quot;: (-0.0368682063937, 0.117619490399, -0.107112232715),
        &quot;arithmetic&quot;: (-0.129978149629, 0.235370097975, -0.247532677712),
        &quot;conceptual_combinations&quot;: (-0.0714835670647, 0.0969259552286, -0.409345543131),
        &quot;hellaswag&quot;: (-0.0336706457557, 0.0980514543495, -0.0671968615465),
        &quot;hindu_knowledge&quot;: (-0.0344023889601, -0.0311435105549, -0.410317419378),
        &quot;mmlu&quot;: (0.0114762642805, -0.0629704348879, -0.48036465022),
        &quot;parsinlu_qa_mc&quot;: (-0.0565673953741, 0.0989058373264, -0.434950718068),
    }

    # Default/global coefficients (fallback if group not found)
    DEFAULT = (0.00264467324727, 0.0773755683686, -0.378439693837)

    a, b, c = PARAMS.get(group, DEFAULT)

    output = []
    for row in input_data:
        x = float(row.get(&quot;log_flops&quot;))
        y_hat = a*(x**2) + b*x + c
        output.append({&quot;brier_score&quot;: float(y_hat)})
    return output</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#5</span>
              <span class="run-label">Run 5</span>
              <span class="r2-badge" style="background-color: #b22222; color: white"> R² = -1.000000 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-4"># Auto-generated scaling law implementation
# Model form: brier_score = a + b * log_flops + c * (log_flops ** 2)

from typing import List, Dict

# Per-group coefficients: a, b, c
COEFFS = {
    &#x27;abstract_narrative_understanding&#x27;: (-0.543140714074, 0.184726990056, -0.00100209571897),
    &#x27;analogical_similarity&#x27;: (-0.540575053774, 0.0279112874835, -0.0191758796727),
    &#x27;arc&#x27;: (-0.107112232715, 0.117619490399, -0.0368682063937),
    &#x27;arithmetic&#x27;: (-0.247532677712, 0.235370097975, -0.129978149629),
    &#x27;conceptual_combinations&#x27;: (-0.409345543131, 0.0969259552286, -0.0714835670647),
    &#x27;hellaswag&#x27;: (-0.0671968615465, 0.0980514543495, -0.0336706457557),
    &#x27;hindu_knowledge&#x27;: (-0.410317419378, -0.0311435105549, -0.0344023889601),
    &#x27;mmlu&#x27;: (-0.48036465022, -0.0629704348879, 0.0114762642805),
    &#x27;parsinlu_qa_mc&#x27;: (-0.434950718068, 0.0989058373264, -0.0565673953741),
}

GLOBAL_COEFFS = (-0.378439693837, 0.0773755683686, 0.00264467324727)


def _predict_single(x: float, coeffs: tuple[float, float, float]) -&gt; float:
    a, b, c = coeffs
    return a + b * x + c * (x ** 2)

def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
               The functional form of the law is the same for all groups,
               but the coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    coeffs = COEFFS.get(group, GLOBAL_COEFFS)
    outputs: list[dict[str, float]] = []
    for row in input_data:
        if &#x27;log_flops&#x27; not in row:
            raise ValueError(&quot;Each input row must contain &#x27;log_flops&#x27;.&quot;)
        x = float(row[&#x27;log_flops&#x27;])
        yhat = _predict_single(x, coeffs)
        outputs.append({&#x27;brier_score&#x27;: float(yhat)})
    return outputs</code></pre>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> |
          <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a>
        </p>
      </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      function toggleRun(header) {
        const content = header.nextElementSibling;
        const isExpanded = content.style.display === "block";
        content.style.display = isExpanded ? "none" : "block";
        header.classList.toggle("expanded", !isExpanded);
      }

      function copyCode(event, codeId) {
        event.stopPropagation();
        const code = document.getElementById(codeId).textContent;
        navigator.clipboard.writeText(code).then(() => {
          const btn = event.target;
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 2000);
        });
      }

      Prism.highlightAll();
    </script>
  </body>
</html>

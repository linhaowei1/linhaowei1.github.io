<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLD - MoE Scaling Law - SLDAgent + GPT-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --accent-primary: #2563eb;
            --accent-secondary: #3b82f6;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-subtle: rgba(0, 0, 0, 0.1);
            --glass-bg: rgba(0, 0, 0, 0.02);
            --success: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Sora', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .bg-pattern {
            display: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--accent-secondary);
        }
        
        .header {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .meta-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .meta-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .meta-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .r2-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .runs-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .run-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .run-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .run-card.best-run {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.02);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .run-header:hover {
            background: rgba(255, 255, 255, 0.04);
        }
        
        .run-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .run-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        
        .run-badge.best-badge {
            background: var(--success);
            color: white;
        }
        
        .run-label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .expand-icon {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .run-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .run-content {
            border-top: 1px solid var(--border-subtle);
        }
        
        .code-container {
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .copy-btn {
            padding: 0.35rem 0.75rem;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .copy-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }
        
        .code-container pre {
            margin: 0;
            padding: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-x: auto;
            background: transparent !important;
        }
        
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .meta-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .run-info {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <a href="sld_index.html" class="back-link">
            ← Back to Leaderboard
        </a>
        
        <div class="header">
            <h1>MoE Scaling Law</h1>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Agent:</span>
                    <span class="meta-value">SLDAgent</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Model:</span>
                    <span class="meta-value">GPT-5</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best R²:</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        0.917117
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Mean R²:</span>
                    <span class="meta-value">0.903359</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Min R²:</span>
                    <span class="meta-value">0.889433</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Runs:</span>
                    <span class="meta-value">5</span>
                </div>
            </div>
        </div>
        
        <h2 class="section-title">All Runs (sorted by R²)</h2>
        
        <div class="runs-container">
            
        <div class="run-card best-run">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge best-badge">Best</span>
                    <span class="run-label">Run 3</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.917117
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: block;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-0"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def _sp(x):
    ax = np.abs(x)
    return np.log1p(np.exp(-ax)) + np.maximum(x, 0.0)

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, float))
    E = np.maximum(X[:, 0], 1.0)
    P = np.maximum(X[:, 1], 1.0)
    p = np.asarray(params, float)
    if p.ndim == 1:
        p = p[None, :]
    if p.shape[1] &lt; 6:
        p = np.hstack([p, np.zeros((p.shape[0], 6 - p.shape[1]))])

    Pn = P / 1e8
    v = np.log1p(E)

    L0 = p[:, 0]
    K  = _sp(p[:, 1]) + 1e-9
    a  = _sp(p[:, 2]) + 1e-9
    al = _sp(p[:, 3]) + 1e-9
    b  = _sp(p[:, 4]) + 1e-9
    c  = _sp(p[:, 5]) + 1e-9

    lp = np.log(Pn + 1e-12)[:, None]
    u  = np.exp(np.clip(lp * al[None, :], -50.0, 50.0))
    vv = v[:, None]
    d  = 1.0 + a[None, :] * u + b[None, :] * vv + c[None, :] * u * vv
    y  = L0[None, :] + K[None, :] / d
    return y[:, 0] if y.shape[1] == 1 else y

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, float))
    y = np.asarray(loss_values, float)
    Y = y[:, None] if y.ndim == 1 else y
    N, T = Y.shape

    E = np.maximum(X[:, 0], 1.0)
    P = np.maximum(X[:, 1], 1.0)
    Pn = P / 1e8
    v = np.log1p(E)
    lp = np.log(Pn + 1e-12)
    rng = np.random.default_rng(42)

    def inv_sp(z):
        z = np.maximum(z, 1e-12)
        return np.log(np.expm1(z))

    def huber(r, d):
        return d * d * (np.sqrt(1.0 + (r / d) ** 2) - 1.0)

    def solve_abc(yt, L0, K, alpha):
        u = np.exp(np.clip(alpha * lp, -50.0, 50.0))
        z = 1.0 / np.maximum(yt - L0, 1e-6)
        t = np.maximum(K, 1e-6) * z - 1.0
        R = np.column_stack([u, v, u * v])
        w, *_ = np.linalg.lstsq(R, t, rcond=None)
        a = float(max(1e-9, w[0]))
        b = float(max(1e-9, w[1]))
        c = float(max(1e-9, w[2]))
        return a, b, c

    def solve_L0K(yt, a, alpha, b, c):
        u = np.exp(np.clip(alpha * lp, -50.0, 50.0))
        g = 1.0 / (1.0 + a * u + b * v + c * u * v)
        R = np.column_stack([np.ones(N), g])
        w, *_ = np.linalg.lstsq(R, yt, rcond=None)
        L0 = float(np.clip(w[0], 1.0, 5.5))
        K = float(max(1e-6, w[1]))
        return L0, K

    def alpha_seed_search(yt, L0b, Kb):
        al_grid = np.linspace(0.3, 1.6, 8)
        best = None
        best_val = np.inf
        delta = 0.1 + 0.2 * (float(np.std(yt)) if np.std(yt) &gt; 0 else 0.2)
        for alpha in al_grid:
            a, b, c = solve_abc(yt, L0b, Kb, alpha)
            L0, K = solve_L0K(yt, a, alpha, b, c)
            a, b, c = solve_abc(yt, L0, K, alpha)
            p = np.array([L0, inv_sp(K), inv_sp(a), inv_sp(alpha), inv_sp(b), inv_sp(c)], float)
            r = scaling_law_func(X, p) - yt
            val = np.mean(huber(r, delta))
            if val &lt; best_val:
                best_val, best = val, p
        return best

    bounds = [(1.0, 5.5)] + [(None, None)] * 5
    out = np.zeros((T, 6), float)

    for t in range(T):
        yt = Y[:, t].astype(float)
        ymin, ymax = float(np.min(yt)), float(np.max(yt))
        L0b = float(np.clip(ymin - 0.05, 1.0, 5.5))
        Kb  = max(0.2, ymax - L0b + 0.1)

        base = alpha_seed_search(yt, L0b, Kb)
        seeds = [base]
        for _ in range(6):
            j = base.copy()
            j += rng.normal(0.0, [0.05, 0.22, 0.22, 0.18, 0.22, 0.22])
            j[0] = np.clip(j[0], 1.0, 5.5)
            seeds.append(j)

        delta = 0.1 + 0.2 * (float(np.std(yt)) if np.std(yt) &gt; 0 else 0.2)

        def obj(p):
            r = scaling_law_func(X, p) - yt
            reg = 1e-6 * float(np.dot(p, p)) + 2e-6 * (p[3] * p[3] + p[5] * p[5])
            return np.mean(huber(r, delta)) + reg

        best_v, best_p = np.inf, seeds[0]
        for s in seeds:
            s0 = s.copy()
            s0[0] = np.clip(s0[0], 1.0, 5.5)
            res = minimize(obj, s0, method=&#x27;L-BFGS-B&#x27;, bounds=bounds, options={&#x27;maxiter&#x27;: 350})
            cand = res.x if res.success else s0
            val = obj(cand)
            if np.isfinite(val) and val &lt; best_v:
                best_v, best_p = val, cand

        # Closed-form polish of L0,K given nonlinear weights from best_p
        th = best_p.copy()
        a = _sp(th[2]) + 1e-9
        alpha = _sp(th[3]) + 1e-9
        b = _sp(th[4]) + 1e-9
        c = _sp(th[5]) + 1e-9
        L0, K = solve_L0K(yt, a, alpha, b, c)
        th[0] = L0
        th[1] = inv_sp(K)

        res = minimize(obj, th, method=&#x27;L-BFGS-B&#x27;, bounds=bounds, options={&#x27;maxiter&#x27;: 250})
        out[t] = res.x if res.success else th

    return out[0] if T == 1 else out
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#2</span>
                    <span class="run-label">Run 4</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.910563
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-1"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, float))
    if X.shape[1] != 2:
        raise ValueError(&quot;data_points must have exactly 2 features: [num_experts, dense_parameter_count]&quot;)
    p = np.asarray(params, float)
    if p.ndim == 1:
        p = p[None, :]
    if p.shape[1] &lt; 6:
        raise ValueError(&quot;params must have length 6 per target&quot;)

    E = np.clip(X[:, 0], 1.0, None)
    P = np.clip(X[:, 1], 1.0, None)
    a = p[:, 0]
    b = np.clip(p[:, 1], 0.0, None)
    alpha = np.clip(p[:, 2], 1e-3, None)
    kappa = np.clip(p[:, 3], 0.0, 1.0)
    beta = np.clip(p[:, 4], 5e-2, None)
    eta = np.clip(p[:, 5], 0.0, None)

    x = np.log(P) - np.log(1e8)
    dE = np.maximum(E - 1.0, 0.0)
    phi = np.log1p(dE[:, None] ** beta[None, :])  # expert benefit saturates
    S = x[:, None] * (1.0 - kappa[None, :] * phi) + eta[None, :] * phi
    pred = a[None, :] + b[None, :] * np.exp(-alpha[None, :] * S)
    return pred[:, 0] if p.shape[0] == 1 else pred


def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, float))
    y = np.asarray(loss_values, float)
    if X.shape[1] != 2:
        raise ValueError(&quot;data_points must have exactly 2 features: [num_experts, dense_parameter_count]&quot;)
    Y = y[:, None] if y.ndim == 1 else y
    N, T = Y.shape

    E = np.clip(X[:, 0], 1.0, None)
    P = np.clip(X[:, 1], 1.0, None)
    x = np.log(P) - np.log(1e8)
    dE = np.maximum(E - 1.0, 0.0)

    delta, lam = 0.25, 1e-6

    def huber(r):
        a = np.abs(r)
        return np.where(a &lt;= delta, 0.5 * r * r, delta * (a - 0.5 * delta))

    def solve_ab(u, ycol):
        s1 = float(N)
        su = float(np.sum(u))
        suu = float(np.sum(u * u)) + 1e-12
        sy = float(np.sum(ycol))
        syu = float(np.sum(ycol * u))
        det = s1 * suu - su * su
        if det &lt;= 1e-12:
            return sy / s1, 0.0
        b = max(0.0, (s1 * syu - su * sy) / det)
        a = (sy - b * su) / s1
        return a, b

    b_theta = [(0.02, 3.0), (0.0, 1.0), (0.1, 3.0), (0.0, 5.0)]  # [alpha, kappa, beta, eta]
    b_full = [(1.0, 6.0), (0.0, 10.0), (0.02, 3.0), (0.0, 1.0), (0.1, 3.0), (0.0, 5.0)]
    rng = np.random.default_rng(42)

    def obj_theta(theta, ycol):
        alpha, kappa, beta, eta = theta
        phi = np.log1p(dE ** beta)
        S = x * (1.0 - kappa * phi) + eta * phi
        u = np.exp(-alpha * S)
        a, b = solve_ab(u, ycol)
        r = a + b * u - ycol
        return float(np.mean(huber(r)) + lam * (alpha**2 + kappa**2 + beta**2 + eta**2)), (a, b)

    def refine_full(p0, ycol):
        def f(p):
            r = scaling_law_func(X, p) - ycol
            return float(np.mean(huber(r)) + lam * np.sum(p[2:] ** 2))
        res = minimize(f, p0, method=&#x27;L-BFGS-B&#x27;, bounds=b_full, options={&#x27;maxiter&#x27;: 400, &#x27;ftol&#x27;: 1e-9})
        return res.x if res.success else p0

    out = []
    for j in range(T):
        ycol = Y[:, j]
        base = np.array([0.6, 0.3, 0.8, 0.7])  # [alpha,kappa,beta,eta]
        seeds = [
            base,
            np.array([0.4, 0.1, 0.6, 0.4]),
            np.array([1.0, 0.6, 1.2, 0.9]),
            np.array([0.7, 0.2, 0.9, 0.3]),
            np.array([0.5, 0.5, 0.5, 0.6]),
        ]
        lo = np.array([b[0] for b in b_theta])
        hi = np.array([b[1] for b in b_theta])
        for _ in range(5):
            seeds.append(np.clip(base + rng.normal(0, [0.25, 0.25, 0.35, 0.35]), lo, hi))

        best_val, best_th, best_ab = np.inf, seeds[0], (float(np.mean(ycol)), float(np.std(ycol) + 0.1))
        for s in seeds:
            res = minimize(lambda th: obj_theta(th, ycol)[0], s, method=&#x27;L-BFGS-B&#x27;,
                           bounds=b_theta, options={&#x27;maxiter&#x27;: 500, &#x27;ftol&#x27;: 1e-9})
            th = res.x if res.success else s
            val, ab = obj_theta(th, ycol)
            if val &lt; best_val:
                best_val, best_th, best_ab = val, th, ab

        a, b = best_ab
        p0 = np.array([a, b, best_th[0], best_th[1], best_th[2], best_th[3]])
        out.append(refine_full(p0, ycol))

    Popt = np.vstack(out)
    return Popt[0] if T == 1 else Popt
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#3</span>
                    <span class="run-label">Run 2</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.907328
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-2"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import least_squares, minimize

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, float))
    if X.shape[1] != 2:
        raise ValueError(&quot;data_points must have 2 features: [num_experts, dense_parameter_count]&quot;)
    e = np.clip(X[:, 0], 1.0, None)
    p = np.clip(X[:, 1], 1.0, None) / 1e8  # normalize params to ~[1,8]
    par = np.atleast_2d(np.asarray(params, float))
    T, P = par.shape
    if P &lt; 5:
        raise ValueError(&quot;params must have at least 5 entries&quot;)
    if P &gt; 6:
        par = par[:, :6]; P = 6
    out = np.empty((X.shape[0], T), float)
    eps = 1e-12
    logp = np.log(p + eps)
    loge = np.log(e + eps)
    for t in range(T):
        L0, A, ap, be = map(float, par[t, :4])
        k = float(par[t, 4])
        g = float(par[t, 5]) if P == 6 else 1.0
        ap = max(ap, 1e-6); be = max(be, 1e-6); k = max(k, 0.0); g = max(g, 1e-6)
        # Saturated MoE gain with synergy: squared-sum form with log1p saturation on experts
        p_half = np.exp(0.5 * ap * logp)        # p^(ap/2)
        e_sat_half = np.sqrt(np.log1p(np.exp(be * loge)))  # sqrt(log(1 + e^be))
        s = (p_half + k * e_sat_half) ** 2 + eps          # includes cross-term synergy
        out[:, t] = L0 + A / np.power(s, g)
    return out[:, 0] if T == 1 else out

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, float))
    y = np.asarray(loss_values, float)
    if X.shape[1] != 2:
        raise ValueError(&quot;data_points must have 2 features: [num_experts, dense_parameter_count]&quot;)
    Y = y[:, None] if y.ndim == 1 else y
    T = Y.shape[1]
    rng = np.random.default_rng(123)
    # Bounds: [L0, A, ap, be, k, g]
    lb = np.array([0.5, 1e-6, 0.05, 0.05, 0.0, 0.3], float)
    ub = np.array([5.0, 80.0, 1.6, 2.5, 200.0, 2.5], float)

    def resid(param, yt, ymin):
        pred = scaling_law_func(X, param)
        r = pred - yt
        # small priors to stabilize with limited data
        pri = np.array([
            (param[2]-0.25)/0.5,   # ap
            (param[3]-0.6)/0.8,    # be
            (param[4]-0.7)/5.0,    # k
            (param[5]-1.0)/0.8     # g
        ])
        hinge = max(0.0, param[0] - (ymin - 0.05))
        return np.concatenate([r, 0.01*pri, np.array([np.sqrt(10.0)*hinge])])

    def obj(param, yt, ymin):
        r = scaling_law_func(X, param) - yt
        d = 0.15  # pseudo-Huber
        loss = np.mean(d*d*(np.sqrt(1 + (r/d)**2)-1))
        reg = 1e-6*((param[2]/0.5)**2 + (param[3]/0.7)**2 + (param[4]/2.0)**2 + (param[5]/1.0)**2)
        hinge = max(0.0, param[0] - (ymin - 0.05))
        return loss + reg + 3.0*hinge*hinge

    res = np.zeros((T, 6))
    for t in range(T):
        yt = Y[:, t]
        ymin, ymax = float(np.min(yt)), float(np.max(yt))
        L0 = np.clip(ymin - 0.05, lb[0], ub[0])
        A0 = np.clip(max(ymax - L0, 0.2), lb[1], ub[1])
        base = np.array([L0, A0, 0.25, 0.6, 0.7, 1.0], float)
        base = np.clip(base, lb, ub)

        best = base.copy()
        best_cost = np.inf
        # First robust LS solve from base
        try:
            r0 = least_squares(lambda q: resid(q, yt, ymin), base, bounds=(lb, ub),
                               loss=&#x27;soft_l1&#x27;, f_scale=0.2, max_nfev=2000)
            if r0.cost &lt; np.inf:
                best = r0.x
                best_cost = r0.cost
        except Exception:
            pass
        # Multi-start around base (log-uniform on positive scales)
        for _ in range(8):
            p0 = best.copy()
            p0[0] = np.clip(L0 + rng.normal(0, 0.05), lb[0], ub[0])
            p0[1] = np.clip(p0[1] * 10 ** rng.uniform(-0.3, 0.3), lb[1], ub[1])
            p0[2] = np.clip(p0[2] * 10 ** rng.uniform(-0.4, 0.4), lb[2], ub[2])
            p0[3] = np.clip(p0[3] * 10 ** rng.uniform(-0.4, 0.4), lb[3], ub[3])
            p0[4] = np.clip(p0[4] * 10 ** rng.uniform(-0.7, 0.7), lb[4], ub[4])
            p0[5] = np.clip(p0[5] * 10 ** rng.uniform(-0.3, 0.3), lb[5], ub[5])
            try:
                r = least_squares(lambda q: resid(q, yt, ymin), p0, bounds=(lb, ub),
                                  loss=&#x27;soft_l1&#x27;, f_scale=0.2, max_nfev=1500)
                if r.cost &lt; best_cost:
                    best, best_cost = r.x, r.cost
            except Exception:
                continue
        # Final polish with L-BFGS-B on smooth robust objective
        try:
            r = minimize(lambda q: obj(q, yt, ymin), best, method=&#x27;L-BFGS-B&#x27;,
                         bounds=list(zip(lb, ub)), options={&#x27;maxiter&#x27;: 400})
            if r.success and r.fun &lt; obj(best, yt, ymin):
                best = r.x
        except Exception:
            pass
        res[t] = best
    return res[0] if T == 1 else res
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#4</span>
                    <span class="run-label">Run 5</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.892355
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-3"># EVOLVE-BLOCK-START
&quot;&quot;&quot;
Scaling law for dense and MoE LLMs at a fixed step (≤6 params).

Model (6 params):
Let Ps = max(P, 1e6)/1e8, Es = max(E, 1).
x = Ps^alpha, y = Es^beta with alpha,beta&gt;0.
Loss(E,P) = L_inf + K / ( x + gamma*y + c*sqrt(x*y) ), with gamma,c&gt;0.

Why this works:
- Monotone diminishing returns in both axes with a gentle interaction (sqrt).
- Smooth substitution between size and experts; saturates to L_inf at large scale.
- Parameter-efficient and numerically stable via softplus reparameterization.

Fit strategy:
- For any (alpha,beta,gamma,c), solve L_inf,K in closed form on z=1/den:
    K = max(0, cov(y,z)/var(z)), L_inf = mean(y) - K*mean(z)
- Coarse grid over (alpha,beta,gamma,c) for strong initialization.
- Local refinement of (alpha,beta,gamma,c) by Nelder-Mead with mild L2 regularization.
&quot;&quot;&quot;
import numpy as np
from scipy.optimize import minimize

def _sp(x):
    x = np.asarray(x, float)
    return np.log1p(np.exp(-np.abs(x))) + np.maximum(x, 0.0)

def _spinv(y):
    y = np.asarray(y, float)
    return np.log(np.expm1(np.maximum(y, 1e-12)))

def _den(E, P, a, b, g, c):
    Ps = np.maximum(P, 1e6) / 1e8
    Es = np.maximum(E, 1.0)
    x = Ps ** max(a, 1e-12)
    y = Es ** max(b, 1e-12)
    return x + max(g, 1e-12) * y + max(c, 0.0) * np.sqrt(x * y)

def _solve_LK(den, y, ridge=1e-12):
    z = 1.0 / np.maximum(den, 1e-12)
    mz, my = np.mean(z), np.mean(y)
    dz, dy = z - mz, y - my
    varz = np.mean(dz * dz) + ridge
    covyz = np.mean(dy * dz)
    K = max(0.0, covyz / varz) if varz &gt; 0 else 0.0
    L0 = my - K * mz
    return L0, K

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, float))
    E, P = X[:, 0], X[:, 1]
    p = np.asarray(params, float)

    def _pred_one(pv):
        pv = np.asarray(pv).ravel()
        L0  = pv[0] if pv.size &gt; 0 else 2.4
        K   = pv[1] if pv.size &gt; 1 else 1.0
        araw = pv[2] if pv.size &gt; 2 else _spinv(0.6)
        braw = pv[3] if pv.size &gt; 3 else _spinv(0.6)
        graw = pv[4] if pv.size &gt; 4 else _spinv(1.0)
        craw = pv[5] if pv.size &gt; 5 else _spinv(0.3)
        a, b = _sp(araw), _sp(braw)
        g, c = _sp(graw), _sp(craw)
        den = _den(E, P, a, b, g, c)
        return L0 + K / np.maximum(den, 1e-12)

    if p.ndim == 1:
        return _pred_one(p)
    return np.column_stack([_pred_one(p[i]) for i in range(p.shape[0])]).squeeze()

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, float))
    y = np.asarray(loss_values, float)
    E, P = X[:, 0], X[:, 1]

    def fit_one(yt):
        yt = np.asarray(yt).ravel()
        # Coarse grid over (alpha, beta, gamma, c) for robust initialization
        agrid = np.linspace(0.1, 1.3, 10)
        bgrid = np.linspace(0.1, 1.3, 10)
        ggrid = [0.6, 1.0, 1.6]
        cgrid = [0.1, 0.3, 0.7]
        best = None
        for a0 in agrid:
            for b0 in bgrid:
                for g0 in ggrid:
                    for c0 in cgrid:
                        den0 = _den(E, P, a0, b0, g0, c0)
                        Lg, Kg = _solve_LK(den0, yt)
                        pred = Lg + Kg / np.maximum(den0, 1e-12)
                        mse = np.mean((pred - yt) ** 2)
                        if best is None or mse &lt; best[0]:
                            best = (mse, a0, b0, g0, c0)
        _, a0, b0, g0, c0 = best
        x0 = np.array([_spinv(a0), _spinv(b0), _spinv(g0), _spinv(c0)], float)

        def obj(r):
            a, b, g, c = _sp(r[0]), _sp(r[1]), _sp(r[2]), _sp(r[3])
            den = _den(E, P, a, b, g, c)
            L0, K = _solve_LK(den, yt)
            pred = L0 + K / np.maximum(den, 1e-12)
            reg = 1e-6 * (a*a + b*b + g*g + c*c)
            return np.mean((pred - yt) ** 2) + reg

        seeds = [x0, x0 + np.array([0.2, -0.1, 0.1, -0.1]), x0 + np.array([-0.15, 0.15, -0.05, 0.1])]
        bestv, bestr = None, None
        for s in seeds:
            res = minimize(obj, s, method=&#x27;Nelder-Mead&#x27;, options={&#x27;maxiter&#x27;: 500, &#x27;xatol&#x27;: 1e-3, &#x27;fatol&#x27;: 1e-8})
            xr = res.x if res.success else s
            v = obj(xr)
            if bestv is None or v &lt; bestv: bestv, bestr = v, xr

        a, b, g, c = _sp(bestr[0]), _sp(bestr[1]), _sp(bestr[2]), _sp(bestr[3])
        den = _den(E, P, a, b, g, c)
        L0, K = _solve_LK(den, yt)
        return np.array([L0, K, bestr[0], bestr[1], bestr[2], bestr[3]], float)

    if y.ndim == 1:
        return fit_one(y)
    return np.vstack([fit_one(y[:, i]) for i in range(y.shape[1])])
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#5</span>
                    <span class="run-label">Run 1</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.889433
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-4"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def _softplus(x):
    return np.log1p(np.exp(-np.abs(x))) + np.maximum(x, 0.0)

def _sigmoid(x):
    out = np.empty_like(x, dtype=float)
    pos = x &gt;= 0
    out[pos] = 1.0 / (1.0 + np.exp(-x[pos]))
    expx = np.exp(x[~pos])
    out[~pos] = expx / (1.0 + expx)
    return out

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points))
    E  = np.clip(X[:, 0].astype(float), 1.0, None)
    Pd = np.clip(X[:, 1].astype(float) / 1e8, 1e-12, None)

    p = np.asarray(params)
    if p.ndim == 1: p = p[None, :]
    p = p[:, :6]

    Lmin = p[:, 0]
    s    = _softplus(p[:, 1])           # amplitude &gt; 0
    k    = _softplus(p[:, 2])           # scale &gt; 0
    a    = _softplus(p[:, 3])           # Pd exponent &gt; 0
    b    = _softplus(p[:, 4])           # E exponent &gt; 0
    g    = 0.5 + _softplus(p[:, 5])     # curvature &gt;= 0.5

    logPd = np.log(Pd)[None, :]
    logE  = np.log(E)[None, :]
    A = np.exp(a[:, None] * logPd)      # Pd^a
    B = np.exp(b[:, None] * logE)       # E^b

    D = A + B + 1e-12
    H = (A * B) / D                     # harmonic-like interaction
    S = A + H                           # saturated additive capacity
    base = 1.0 + k[:, None] * S
    denom = np.power(base, g[:, None])

    pred = Lmin[:, None] + s[:, None] / denom
    return pred[0] if pred.shape[0] == 1 else pred.T

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points))
    y = np.asarray(loss_values)
    y2d = y[:, None] if y.ndim == 1 else y
    N, T = y2d.shape

    Pd = np.clip(X[:, 1].astype(float) / 1e8, 1e-12, None)
    E  = np.clip(X[:, 0].astype(float), 1.0, None)
    logPd = np.log(Pd)
    logE  = np.log(E)

    y_min = float(np.nanmin(y2d))
    y_max = float(np.nanmax(y2d))

    def inv_softplus(v):
        v = np.maximum(v, 1e-12)
        return np.log(np.expm1(v))

    # Data-driven initialization via linear fit on log residuals
    base = np.zeros((T, 6))
    Areg = 1e-6
    for t in range(T):
        yt = y2d[:, t]
        L0 = np.clip(np.nanmin(yt) - 0.05, 1.2, 4.2)
        resid = np.clip(yt - L0, 1e-6, None)
        z = np.log(resid)
        Ainit = np.stack([np.ones_like(logPd), -logPd, -logE], 1)
        coef = np.linalg.solve(Ainit.T @ Ainit + Areg * np.eye(3), Ainit.T @ z)
        s0 = float(np.exp(coef[0]))
        a0 = float(max(0.05, coef[1]))
        b0 = float(max(0.05, coef[2]))
        base[t, 0] = L0
        base[t, 1] = inv_softplus(max(0.1, s0))
        base[t, 2] = inv_softplus(1.0)      # k
        base[t, 3] = inv_softplus(a0)       # a
        base[t, 4] = inv_softplus(b0)       # b
        base[t, 5] = inv_softplus(1.0)      # g-0.5 -&gt; g ~ 1.5

    # Robust objective (Huber) with analytic gradient + mild L2 regularization
    delta = 0.12
    lam = 1e-4

    def huber_grad(r):
        a = np.abs(r)
        return np.where(a &lt;= delta, r, delta * np.sign(r))

    def objective_and_grad(flat_params):
        params = flat_params.reshape(T, 6)
        Lmin = params[:, 0]
        s_raw = params[:, 1]; k_raw = params[:, 2]; a_raw = params[:, 3]; b_raw = params[:, 4]; g_raw = params[:, 5]
        s = _softplus(s_raw); k = _softplus(k_raw); a = _softplus(a_raw); b = _softplus(b_raw); g = 0.5 + _softplus(g_raw)
        ds = _sigmoid(s_raw); dk = _sigmoid(k_raw); da = _sigmoid(a_raw); db = _sigmoid(b_raw); dg = _sigmoid(g_raw)

        logPdN = logPd[None, :]
        logEN  = logE[None, :]
        A = np.exp(a[:, None] * logPdN)
        B = np.exp(b[:, None] * logEN)
        D = A + B + 1e-12
        H = (A * B) / D
        S = A + H
        base = 1.0 + k[:, None] * S
        denom = np.power(base, g[:, None])

        pred = Lmin[:, None] + s[:, None] / denom
        res = pred.T - y2d
        hub_g = huber_grad(res) / (N * T)
        loss = np.mean(np.where(np.abs(res) &lt;= delta, 0.5 * res * res, delta * (np.abs(res) - 0.5 * delta))) + lam * np.sum(params**2)

        grad = np.zeros_like(params)
        hub_tn = hub_g.T  # (T,N)

        # Common partials
        grad[:, 0] = np.sum(hub_tn, axis=1)  # d pred / d Lmin = 1
        invden = 1.0 / denom
        grad[:, 1] = np.sum(hub_tn * invden, axis=1) * ds  # d pred / d s_raw

        ln_base = np.log(base)
        d_pred_dg = - (s[:, None] * ln_base) * invden
        grad[:, 5] = np.sum(hub_tn * d_pred_dg, axis=1) * dg

        d_pred_dB1 = - (s[:, None] * g[:, None]) * invden / base
        d_pred_dk = d_pred_dB1 * S
        grad[:, 2] = np.sum(hub_tn * d_pred_dk, axis=1) * dk

        # dS/dA and dS/dB
        dH_dA = (B * (B + 1e-12)) / (D * D)
        dH_dB = (A * (A + 1e-12)) / (D * D)
        dS_dA = 1.0 + dH_dA
        dS_dB = dH_dB

        d_pred_dS = d_pred_dB1 * k[:, None]
        dA_da = A * logPdN
        dB_db = B * logEN

        d_pred_da = d_pred_dS * dS_dA * dA_da
        d_pred_db = d_pred_dS * dS_dB * dB_db

        grad[:, 3] = np.sum(hub_tn * d_pred_da, axis=1) * da
        grad[:, 4] = np.sum(hub_tn * d_pred_db, axis=1) * db

        grad += 2.0 * lam * params
        return loss, grad.ravel()

    lmin_lo = max(1.0, y_min - 0.5)
    lmin_hi = min(4.5, y_max + 0.2)
    bounds = [(lmin_lo, lmin_hi), (None, None), (None, None), (None, None), (None, None), (None, None)] * T

    rng = np.random.default_rng(123)
    seeds = [base]
    for _ in range(12):
        s0 = rng.uniform(0.2, max(0.3, y_max - y_min + 0.3))
        a0 = rng.uniform(0.08, 1.6)
        b0 = rng.uniform(0.08, 1.6)
        k0 = 10 ** rng.uniform(-1.2, 1.2)
        g0 = rng.uniform(0.6, 2.6)
        cand = np.zeros((T, 6))
        cand[:, 0] = rng.uniform(lmin_lo, lmin_hi, size=T)
        cand[:, 1] = inv_softplus(s0)
        cand[:, 2] = inv_softplus(k0)
        cand[:, 3] = inv_softplus(a0)
        cand[:, 4] = inv_softplus(b0)
        cand[:, 5] = inv_softplus(max(1e-3, g0 - 0.5))
        seeds.append(cand)

    best_val = np.inf
    best = base
    for start in seeds:
        start = start + rng.normal(0, 0.05, size=start.shape)
        def fun(x):
            v, _ = objective_and_grad(x)
            return v
        def jac(x):
            _, g = objective_and_grad(x)
            return g
        res = minimize(fun, start.ravel(), method=&#x27;L-BFGS-B&#x27;, jac=jac, bounds=bounds, options={&#x27;maxiter&#x27;: 800})
        val = res.fun if res.success else np.inf
        if val &lt; best_val:
            best_val = val
            best = res.x.reshape(T, 6) if res.success else start

    return best[0] if T == 1 else best
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        </div>
        
        <footer class="footer">
            <p>SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> | <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a></p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleRun(header) {
            const content = header.nextElementSibling;
            const isExpanded = content.style.display === 'block';
            content.style.display = isExpanded ? 'none' : 'block';
            header.classList.toggle('expanded', !isExpanded);
        }
        
        function copyCode(event, codeId) {
            event.stopPropagation();
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }
        
        Prism.highlightAll();
    </script>
</body>
</html>
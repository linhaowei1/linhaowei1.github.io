<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLD - Data-Constrained Scaling Law - opencode + GPT-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --accent-primary: #2563eb;
        --accent-secondary: #3b82f6;
        --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
        --text-primary: #1f2937;
        --text-secondary: #4b5563;
        --border-subtle: rgba(0, 0, 0, 0.1);
        --glass-bg: rgba(0, 0, 0, 0.02);
        --success: #10b981;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          "Sora",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
      }

      .bg-pattern {
        display: none;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--accent-primary);
        text-decoration: none;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
        transition: color 0.2s;
      }

      .back-link:hover {
        color: var(--accent-secondary);
      }

      .header {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .meta-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .meta-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .r2-badge {
        display: inline-block;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", monospace;
      }

      .section-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .runs-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .run-card {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        overflow: hidden;
        transition: border-color 0.2s;
      }

      .run-card:hover {
        border-color: rgba(99, 102, 241, 0.3);
      }

      .run-card.best-run {
        border-color: var(--success);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
      }

      .run-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        transition: background 0.2s;
      }

      .run-header:hover {
        background: rgba(255, 255, 255, 0.04);
      }

      .run-info {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .run-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-secondary);
      }

      .run-badge.best-badge {
        background: var(--success);
        color: white;
      }

      .run-label {
        font-weight: 500;
        color: var(--text-primary);
      }

      .expand-icon {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: transform 0.2s;
      }

      .run-header.expanded .expand-icon {
        transform: rotate(180deg);
      }

      .run-content {
        border-top: 1px solid var(--border-subtle);
      }

      .code-container {
        overflow: hidden;
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.25rem;
        background: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid var(--border-subtle);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .copy-btn {
        padding: 0.35rem 0.75rem;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--accent-primary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-container pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        background: transparent !important;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid var(--border-subtle);
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .footer a {
        color: var(--accent-primary);
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .meta-row {
          flex-direction: column;
          gap: 0.75rem;
        }

        .run-info {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <a href="sld_index.html" class="back-link"> ← Back to Leaderboard </a>

      <div class="header">
        <h1>Data-Constrained Scaling Law</h1>
        <div class="meta-row">
          <div class="meta-item">
            <span class="meta-label">Agent:</span>
            <span class="meta-value">opencode</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Model:</span>
            <span class="meta-value">GPT-5</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Best R²:</span>
            <span class="r2-badge" style="background-color: #228b22; color: white"> 0.936135 </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Mean R²:</span>
            <span class="meta-value">0.919620</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Min R²:</span>
            <span class="meta-value">0.914136</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Runs:</span>
            <span class="meta-value">5</span>
          </div>
        </div>
      </div>

      <h2 class="section-title">All Runs (sorted by R²)</h2>

      <div class="runs-container">
        <div class="run-card best-run">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge best-badge">Best</span>
              <span class="run-label">Run 1</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.936135 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: block">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-0">from typing import List, Dict
import math

# Fitted coefficients per group for the scaling law:
# loss = L0 + a * params^(-alpha) + b * tokens^(-beta) + c * ln(unique_tokens)
#
# Notes:
# - Coefficients below were obtained via non-linear least squares on the provided dataset.
# - If an unknown group is requested, we fall back to the &#x27;all_data&#x27; coefficients.

_COEFFS = {
    # Trained from the dataset at /app/data (161 points, single group &#x27;all_data&#x27;)
    &quot;all_data&quot;: {
        &quot;L0&quot;: 5.314158928164251,
        &quot;a&quot;: 4163.742173986624,
        &quot;alpha&quot;: 0.4910050761229603,
        &quot;b&quot;: 109180.20697694572,
        &quot;beta&quot;: 0.5637776884040872,
        &quot;c&quot;: -0.11944428211525198,
    }
}


def _predict_single(x: Dict[str, float], k: Dict[str, float]) -&gt; float:
    # Safeguards for domain constraints
    params = max(float(x.get(&quot;params&quot;, 0.0)), 1e-12)
    tokens = max(float(x.get(&quot;tokens&quot;, 0.0)), 1e-12)
    unique_tokens = max(float(x.get(&quot;unique_tokens&quot;, 0.0)), 1.0)

    return (
        k[&quot;L0&quot;]
        + k[&quot;a&quot;] * (params ** (-k[&quot;alpha&quot;]))
        + k[&quot;b&quot;] * (tokens ** (-k[&quot;beta&quot;]))
        + k[&quot;c&quot;] * math.log(unique_tokens)
    )


def law(input_data: List[Dict[str, float]], group: str) -&gt; List[Dict[str, float]]:
    &quot;&quot;&quot;
    Predicts the final validation loss (&#x27;loss&#x27;) for language model pre-training
    given parameter count (&#x27;params&#x27;), total training tokens (&#x27;tokens&#x27;), and the
    number of unique tokens in the dataset (&#x27;unique_tokens&#x27;).

    Functional form (shared across groups):
        loss = L0 + a * params^(-alpha) + b * tokens^(-beta) + c * ln(unique_tokens)

    The coefficients (L0, a, alpha, b, beta, c) are group-specific. If the
    provided group is unknown, this function falls back to &#x27;all_data&#x27;.

    Args:
        input_data: List of dicts; each must contain &#x27;params&#x27;, &#x27;tokens&#x27;,
                    and &#x27;unique_tokens&#x27; (floats).
        group: Name of the experimental group.

    Returns:
        List of dicts with a single key &#x27;loss&#x27; containing the prediction.
    &quot;&quot;&quot;
    if not isinstance(input_data, list):
        raise TypeError(&quot;input_data must be a list of dictionaries&quot;)

    coeffs = _COEFFS.get(group, _COEFFS[&quot;all_data&quot;])  # fallback to all_data

    out: List[Dict[str, float]] = []
    for row in input_data:
        y = _predict_single(row, coeffs)
        out.append({&quot;loss&quot;: float(y)})
    return out</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#2</span>
              <span class="run-label">Run 2</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.915943 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-1">from __future__ import annotations
from typing import List, Dict

# Discovered scaling law (shared exponents across groups):
#   loss ≈ L_inf[group] + a[group] * params^{-alpha} + b[group] * tokens^{-beta} + c[group] * unique_tokens^{-gamma}
# Fitted on provided dataset; see /app/explain.md for details.

# Global exponents (shared across groups), from grid-searched least squares fit
_ALPHA = 0.5
_BETA = 0.55
_GAMMA = 0.15

# Per-group coefficients (L_inf, a, b, c). If a group is not found, fall back to &#x27;all_data&#x27;
_GROUP_COEFFICIENTS = {
    # Fitted on the only group present in the dataset
    &#x27;all_data&#x27;: {
        &#x27;L_inf&#x27;: 1.9772224464978783,
        &#x27;a&#x27;: 4677.914495956277,
        &#x27;b&#x27;: 84210.885300064,
        &#x27;c&#x27;: 18.46655768657379,
    },
}


def _predict_loss(params: float, tokens: float, unique_tokens: float, group: str) -&gt; float:
    # Guard against non-positive inputs to avoid numerical issues
    p = max(float(params), 1.0)
    t = max(float(tokens), 1.0)
    u = max(float(unique_tokens), 1.0)

    coeffs = _GROUP_COEFFICIENTS[group] if group in _GROUP_COEFFICIENTS else _GROUP_COEFFICIENTS[&#x27;all_data&#x27;]
    L_inf = coeffs[&#x27;L_inf&#x27;]
    a = coeffs[&#x27;a&#x27;]
    b = coeffs[&#x27;b&#x27;]
    c = coeffs[&#x27;c&#x27;]

    return (
        L_inf
        + a * (p ** (-_ALPHA))
        + b * (t ** (-_BETA))
        + c * (u ** (-_GAMMA))
    )


def law(input_data: List[Dict[str, float]], group: str) -&gt; List[Dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values. Expected keys: &#x27;params&#x27;, &#x27;tokens&#x27;, &#x27;unique_tokens&#x27;.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law is the same for all groups,
                but the constant coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s). Keys: &#x27;loss&#x27;.
    &quot;&quot;&quot;
    outputs: List[Dict[str, float]] = []
    for row in input_data:
        params = row.get(&#x27;params&#x27;)
        tokens = row.get(&#x27;tokens&#x27;)
        unique_tokens = row.get(&#x27;unique_tokens&#x27;)
        if params is None or tokens is None or unique_tokens is None:
            raise ValueError(&quot;Each input row must have &#x27;params&#x27;, &#x27;tokens&#x27;, and &#x27;unique_tokens&#x27;.&quot;)
        pred_loss = _predict_loss(params, tokens, unique_tokens, group)
        outputs.append({&#x27;loss&#x27;: float(pred_loss)})
    return outputs</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#3</span>
              <span class="run-label">Run 3</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.915943 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-2">from __future__ import annotations
from typing import Dict, List
import math

# Functional form (same for all groups):
#   loss = L_inf + A * params^{-a} + B * tokens^{-b} + C * unique_tokens^{-c}
# Coefficients may differ per group. Values below were fit on the provided dataset.

_COEFFICIENTS: Dict[str, Dict[str, float]] = {
    # Fitted on group == &quot;all_data&quot;
    &quot;all_data&quot;: {
        &quot;L_inf&quot;: 1.9772224464979034,
        &quot;A&quot;: 4677.914495956284,
        &quot;B&quot;: 84210.88530006418,
        &quot;C&quot;: 18.4665576865743,
        &quot;a&quot;: 0.5,
        &quot;b&quot;: 0.55,
        &quot;c&quot;: 0.15,
    },
}

# Fallback group key if an unseen group is requested
_FALLBACK_GROUP = &quot;all_data&quot;


def _predict_single(x: Dict[str, float], coefs: Dict[str, float]) -&gt; float:
    # Guard against non-positive inputs for power operations
    eps = 1e-12
    p = max(float(x.get(&quot;params&quot;, 0.0)), eps)
    t = max(float(x.get(&quot;tokens&quot;, 0.0)), eps)
    u = max(float(x.get(&quot;unique_tokens&quot;, 0.0)), eps)

    L_inf = coefs[&quot;L_inf&quot;]
    A = coefs[&quot;A&quot;]; a = coefs[&quot;a&quot;]
    B = coefs[&quot;B&quot;]; b = coefs[&quot;b&quot;]
    C = coefs[&quot;C&quot;]; c = coefs[&quot;c&quot;]

    return (
        L_inf
        + A * (p ** (-a))
        + B * (t ** (-b))
        + C * (u ** (-c))
    )


def law(input_data: List[Dict[str, float]], group: str) -&gt; List[Dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values. Expected keys: &#x27;params&#x27;, &#x27;tokens&#x27;, &#x27;unique_tokens&#x27;.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law is the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    coefs = _COEFFICIENTS.get(group, _COEFFICIENTS[_FALLBACK_GROUP])
    preds = []
    for row in input_data:
        y = _predict_single(row, coefs)
        preds.append({&quot;loss&quot;: float(y)})
    return preds</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#4</span>
              <span class="run-label">Run 4</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.915943 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-3">from __future__ import annotations
from typing import List, Dict

# Discovered scaling law (additive shifted power laws)
# loss = L0 + Bp*(P/P0)^(-alpha_p) + Bt*(T/T0)^(-beta_t) + Bu*(U/U0)^(-gamma_u)
# The functional form is shared across groups; coefficients may differ by group.

# Non-dimensionalization constants (fixed across groups)
_P0 = 1e9       # parameters reference scale
_T0 = 1e11      # tokens reference scale
_U0 = 1e10      # unique tokens reference scale

# Exponents (fixed across groups from global fit)
_ALPHA_P = 0.50
_BETA_T = 0.55
_GAMMA_U = 0.15

# Group-specific coefficients fitted on the provided dataset
# If an unknown group is requested, we fall back to &#x27;all_data&#x27;.
_GROUP_COEFFS = {
    &quot;all_data&quot;: {
        &quot;L0&quot;: 1.97722245,
        &quot;Bp&quot;: 0.14792865,
        &quot;Bt&quot;: 0.07505303,
        &quot;Bu&quot;: 0.58396383,
    }
}


def _predict_loss(params: float, tokens: float, unique_tokens: float, coeffs: Dict[str, float]) -&gt; float:
    p = params / _P0
    t = tokens / _T0
    u = unique_tokens / _U0
    return (
        coeffs[&quot;L0&quot;]
        + coeffs[&quot;Bp&quot;] * (p ** (-_ALPHA_P))
        + coeffs[&quot;Bt&quot;] * (t ** (-_BETA_T))
        + coeffs[&quot;Bu&quot;] * (u ** (-_GAMMA_U))
    )


def law(input_data: List[Dict[str, float]], group: str) -&gt; List[Dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values. Required keys: &#x27;params&#x27;, &#x27;tokens&#x27;, &#x27;unique_tokens&#x27;.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law is the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s) under key &#x27;loss&#x27;.
    &quot;&quot;&quot;
    if group in _GROUP_COEFFS:
        coeffs = _GROUP_COEFFS[group]
    else:
        coeffs = _GROUP_COEFFS[&quot;all_data&quot;]
    outputs: List[Dict[str, float]] = []
    for row in input_data:
        params = float(row.get(&quot;params&quot;, 0.0))
        tokens = float(row.get(&quot;tokens&quot;, 0.0))
        unique_tokens = float(row.get(&quot;unique_tokens&quot;, 0.0))
        loss = _predict_loss(params, tokens, unique_tokens, coeffs)
        outputs.append({&quot;loss&quot;: float(loss)})
    return outputs</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#5</span>
              <span class="run-label">Run 5</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.914136 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-4">from __future__ import annotations

from typing import Dict, List

# Global exponents shared across groups (functional form is identical)
# Fitted via nonlinear search on the provided dataset.
EXPONENTS = {
    &quot;p_params&quot;: 0.5065484647862601,   # exponent for params
    &quot;q_tokens&quot;: 0.5635675499712252,   # exponent for tokens
    &quot;r_unique&quot;: 0.1292210842785036,   # exponent for unique_tokens
}

# Per-group coefficients. If an unknown group is requested, fall back to &quot;all_data&quot;.
# Coefficients correspond to the additive power-law model:
# loss = L + a * params^(-p) + b * tokens^(-q) + c * unique_tokens^(-r)
GROUP_COEFFS: Dict[str, Dict[str, float]] = {
    &quot;all_data&quot;: {
        &quot;L&quot;: 1.8542464832328804,
        &quot;a&quot;: 5185.971392997345,
        &quot;b&quot;: 108444.86104642624,
        &quot;c&quot;: 14.15004130726869,
    }
}


def _predict_point(x: Dict[str, float], coeffs: Dict[str, float]) -&gt; float:
    p = EXPONENTS[&quot;p_params&quot;]
    q = EXPONENTS[&quot;q_tokens&quot;]
    r = EXPONENTS[&quot;r_unique&quot;]

    params = float(x[&quot;params&quot;])  # model parameter count
    tokens = float(x[&quot;tokens&quot;])  # total train tokens
    unique = float(x[&quot;unique_tokens&quot;])  # number of unique tokens in dataset

    # Assumes all inputs are positive; scaling law is defined for positive domain only.
    loss = (
        coeffs[&quot;L&quot;]
        + coeffs[&quot;a&quot;] * (params ** (-p))
        + coeffs[&quot;b&quot;] * (tokens ** (-q))
        + coeffs[&quot;c&quot;] * (unique ** (-r))
    )
    return float(loss)


def law(input_data: List[Dict[str, float]], group: str) -&gt; List[Dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values. Required keys: &#x27;params&#x27;, &#x27;tokens&#x27;, &#x27;unique_tokens&#x27;.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law is the same for all groups, but
                the constant coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s): {&#x27;loss&#x27;: float}.
    &quot;&quot;&quot;
    coeffs = GROUP_COEFFS.get(group) or GROUP_COEFFS[&quot;all_data&quot;]

    preds: List[Dict[str, float]] = []
    for x in input_data:
        y = _predict_point(x, coeffs)
        preds.append({&quot;loss&quot;: y})
    return preds</code></pre>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> |
          <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a>
        </p>
      </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      function toggleRun(header) {
        const content = header.nextElementSibling;
        const isExpanded = content.style.display === "block";
        content.style.display = isExpanded ? "none" : "block";
        header.classList.toggle("expanded", !isExpanded);
      }

      function copyCode(event, codeId) {
        event.stopPropagation();
        const code = document.getElementById(codeId).textContent;
        navigator.clipboard.writeText(code).then(() => {
          const btn = event.target;
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 2000);
        });
      }

      Prism.highlightAll();
    </script>
  </body>
</html>

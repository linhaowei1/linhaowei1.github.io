<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLD - U-shaped Scaling Law - SLDAgent + GPT-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --accent-primary: #2563eb;
            --accent-secondary: #3b82f6;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-subtle: rgba(0, 0, 0, 0.1);
            --glass-bg: rgba(0, 0, 0, 0.02);
            --success: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Sora', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .bg-pattern {
            display: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--accent-secondary);
        }
        
        .header {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .meta-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .meta-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .meta-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .r2-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .runs-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .run-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .run-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .run-card.best-run {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.02);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .run-header:hover {
            background: rgba(255, 255, 255, 0.04);
        }
        
        .run-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .run-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        
        .run-badge.best-badge {
            background: var(--success);
            color: white;
        }
        
        .run-label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .expand-icon {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .run-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .run-content {
            border-top: 1px solid var(--border-subtle);
        }
        
        .code-container {
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .copy-btn {
            padding: 0.35rem 0.75rem;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .copy-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }
        
        .code-container pre {
            margin: 0;
            padding: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-x: auto;
            background: transparent !important;
        }
        
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .meta-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .run-info {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <a href="sld_index.html" class="back-link">
            ← Back to Leaderboard
        </a>
        
        <div class="header">
            <h1>U-shaped Scaling Law</h1>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Agent:</span>
                    <span class="meta-value">SLDAgent</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Model:</span>
                    <span class="meta-value">GPT-5</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best R²:</span>
                    <span class="r2-badge" style="background-color: #DAA520; color: white;">
                        0.680657
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Mean R²:</span>
                    <span class="meta-value">0.474852</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Min R²:</span>
                    <span class="meta-value">0.219030</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Runs:</span>
                    <span class="meta-value">5</span>
                </div>
            </div>
        </div>
        
        <h2 class="section-title">All Runs (sorted by R²)</h2>
        
        <div class="runs-container">
            
        <div class="run-card best-run">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge best-badge">Best</span>
                    <span class="run-label">Run 5</span>
                    <span class="r2-badge" style="background-color: #DAA520; color: white;">
                        R² = 0.680657
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: block;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-0"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def _softplus(z):
    z = np.asarray(z, dtype=float)
    return np.log1p(np.exp(-np.abs(z))) + np.maximum(z, 0.0)

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    x = X[:, 0]
    P = np.asarray(params, dtype=float)
    if P.ndim == 1:
        P = P[None, :]
    T, D = P.shape
    a = P[:, 0]; b = P[:, 1]; k = P[:, 2]; A = P[:, 3]; mu = P[:, 4]
    sigma = _softplus(P[:, 5]) + 1e-8 if D &gt;= 6 else np.full(T, 0.6)
    xNT = x[:, None]
    base = a[None, :] + b[None, :] * np.tanh(k[None, :] * xNT)
    u = (xNT - mu[None, :]) / sigma[None, :]
    y = base + A[None, :] * np.exp(-0.5 * (u * u))
    return y[:, 0] if y.shape[1] == 1 else y

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, dtype=float)); x = X[:, 0]
    y = np.asarray(loss_values, dtype=float)
    Y = y[:, None] if y.ndim == 1 else y
    N, T = Y.shape
    x_min, x_max = float(np.min(x)), float(np.max(x))
    xr = max(x_max - x_min, 1e-3)

    def fit_one(yt):
        yt = yt.astype(float)
        y_med = float(np.median(yt))
        q1, q3 = np.percentile(yt, [25, 75]); yr = max(q3 - q1, 1e-6)
        a0 = y_med
        b0 = -0.5 * yr
        k0 = 1.0 / xr
        mu0 = float(x[np.argmax(yt)])
        A0 = max(0.25 * (float(np.max(yt)) - float(np.min(yt))), 1e-5)
        s0 = xr / 6.0
        ls0 = np.log(np.expm1(max(s0, 1e-6)))
        base = np.array([a0, b0, k0, A0, mu0, ls0], float)

        inits = [
            base.copy(),
            base * np.array([1.0, 1.2, 0.8, 0.0, 1.0, 1.0]),
            base * np.array([1.0, 1.0, 1.0, 1.2, 0.9, 1.0])
        ]
        rng = np.random.default_rng(42)
        for _ in range(6):
            jit = rng.normal(0, 0.2, 6)
            p = base.copy()
            p[0] += jit[0] * yr
            p[1] += jit[1] * yr
            p[2] = np.clip(p[2] + jit[2] * (k0 + 1e-6), 1e-3, 10.0)
            p[3] = max(0.0, p[3] + jit[3] * (A0 + 1e-6))
            p[4] += jit[4] * xr
            p[5] += jit[5]
            inits.append(p)

        lam = 1e-4
        def obj(p):
            pred = scaling_law_func(X, p)
            r = pred - yt
            return float(np.mean(r * r) + lam * (p[2] ** 2 + p[3] ** 2))

        best_v, best_p = np.inf, inits[0]
        for p0 in inits:
            try:
                res = minimize(obj, p0, method=&#x27;L-BFGS-B&#x27;,
                               options={&#x27;maxiter&#x27;: 500, &#x27;ftol&#x27;: 1e-9})
                if res.success and res.fun &lt; best_v:
                    best_v, best_p = res.fun, res.x
            except Exception:
                pass
        return best_p

    P = np.vstack([fit_one(Y[:, t]) for t in range(T)])
    return P[0] if T == 1 else P
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#2</span>
                    <span class="run-label">Run 4</span>
                    <span class="r2-badge" style="background-color: #DAA520; color: white;">
                        R² = 0.670530
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-1"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def _sp(z):  # softplus
    return np.maximum(z, 0.0) + np.log1p(np.exp(-np.abs(z)))

def _isp(u):  # inverse softplus
    u = np.maximum(u, 1e-12)
    return np.log(np.expm1(u))

def _sig(z):  # stable 1/(1+exp(z))
    return np.where(z &gt;= 0, np.exp(-z)/(1+np.exp(-z)), 1/(1+np.exp(z)))

def scaling_law_func(data_points, params):
    # 6-param model: logistic base + Gaussian bump (U-shape)
    # y = y_inf + (y0-y_inf)/(1+exp((x-x0)/s)) + h*exp(-0.5*((x-x0)/w)^2)
    X = np.atleast_2d(np.asarray(data_points))
    x = X[:, 0]
    p = np.asarray(params)
    if p.ndim == 1: p = p[None, :]
    if p.shape[1] &lt; 6: p = np.concatenate([p, np.zeros((p.shape[0], 6-p.shape[1]))], 1)
    p = p[:, :6]
    y = np.empty((x.size, p.shape[0]))
    eps = 1e-6
    for i in range(p.shape[0]):
        y_inf, y0, x0, s_r, h_r, w_r = p[i]
        s = _sp(s_r) + eps
        w = _sp(w_r) + eps
        h = _sp(h_r)  # positive bump ensures initial worsening then improvement
        base = y_inf + (y0 - y_inf) * _sig((x - x0) / s)
        bump = h * np.exp(-0.5 * ((x - x0) / w) ** 2)
        y[:, i] = base + bump
    return y[:, 0] if y.shape[1] == 1 else y

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points))
    x = X[:, 0]
    y = np.asarray(loss_values)
    if y.ndim == 1: Y = y[:, None]
    else: Y = y
    T = Y.shape[1]
    xmin, xmax = float(np.min(x)), float(np.max(x))
    xr = max(1e-6, xmax - xmin)

    def init_params(yc):
        q5, q95 = np.percentile(yc, [5, 95])
        y_inf0, y00 = q5, q95
        x0 = np.median(x)
        x10, x90 = np.percentile(x, [10, 90])
        s0 = max(0.05, 0.25 * (x90 - x10) + 1e-3)
        w0 = max(0.1, 0.4 * (x90 - x10) + 1e-3)
        h0 = max(0.0, q95 - q5) * 0.5
        return np.array([y_inf0, y00, x0, _isp(s0), _isp(h0), _isp(w0)], float)

    def objective(p, yc):
        pred = scaling_law_func(X, p)
        r = pred - yc
        mse = np.mean(r * r)
        s = _sp(p[3]) + 1e-6
        h = _sp(p[4])
        w = _sp(p[5]) + 1e-6
        reg = 1e-6 * np.sum(p * p) + 1e-4 * (s*s + w*w + 1/(s*s+1e-12) + 1/(w*w+1e-12)) + 1e-5 * h * h
        return mse + reg

    rng = np.random.default_rng(1234)
    params_all = np.zeros((T, 6), float)
    for t in range(T):
        yc = Y[:, t]
        p0 = init_params(yc)
        best_v, best_p = np.inf, p0.copy()
        starts = [p0]
        for dx in (-0.3 * xr, 0.3 * xr):
            pp = p0.copy()
            pp[2] += dx
            pp[3] += rng.normal(0, 0.2)
            pp[4] += rng.normal(0, 0.2)
            pp[5] += rng.normal(0, 0.2)
            starts.append(pp)
        for _ in range(4):
            starts.append(p0 + rng.normal(0, [0.3,0.3,0.3,0.4,0.4,0.4]))
        for s in starts:
            res = minimize(objective, s, args=(yc,), method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 1000})
            if res.success and res.fun &lt; best_v:
                best_v, best_p = res.fun, res.x
        params_all[t] = best_p
    return params_all[0] if T == 1 else params_all
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#3</span>
                    <span class="run-label">Run 3</span>
                    <span class="r2-badge" style="background-color: #D2691E; color: white;">
                        R² = 0.422940
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-2"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

# 6-param U-shaped/double-descent with saturating baseline + localized bump
# y(x) = c + a*exp(-r*(x - m)) + p * exp(-0.5*((x - m)/s)^2)
# Params per task: [c, a_r, r_r, p_r, s_r, m] with a=softplus(a_r), r=softplus(r_r), p=softplus(p_r), s=softplus(s_r)

def _softplus(z):
    return np.log1p(np.exp(-np.abs(z))) + np.maximum(z, 0.0)

def _inv_softplus(v):
    v = np.maximum(v, 1e-12)
    return np.where(v &gt; 50.0, v, np.log(np.expm1(v)))

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points)); x = X[:, 0].astype(float)
    P = np.asarray(params, dtype=float); 
    if P.ndim == 1: P = P[None, :]
    if P.shape[1] &lt; 6: raise ValueError(&quot;params must have 6 elements per task [c,a_r,r_r,p_r,s_r,m]&quot;)
    c, a_r, r_r, p_r, s_r, m = [P[:, i] for i in range(6)]
    a = _softplus(a_r) + 1e-12
    r = _softplus(r_r) + 1e-6
    p = _softplus(p_r) + 1e-12
    s = _softplus(s_r) + 1e-6
    dx = x[None, :] - m[:, None]
    base = np.exp(-r[:, None] * dx)
    bump = np.exp(-0.5 * (dx / s[:, None]) ** 2)
    y = c[:, None] + a[:, None] * base + p[:, None] * bump
    y = y.T
    return y[:, 0] if y.shape[1] == 1 else y

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points)); x = X[:, 0].astype(float)
    y = np.asarray(loss_values, dtype=float); Y = y[:, None] if y.ndim == 1 else y
    N, T = Y.shape
    xmin, xmax = float(np.min(x)), float(np.max(x)); xr = max(1e-6, xmax - xmin)

    def huber_mean(r, d):
        a = np.abs(r); return float(np.mean(np.where(a &lt;= d, 0.5 * r * r, d * (a - 0.5 * d))))

    params = np.zeros((T, 6), dtype=float)
    ridge = 1e-6

    for t in range(T):
        yt = Y[:, t].astype(float)
        ymed = float(np.median(yt)); ystd = float(np.std(yt)) + 1e-9
        mad = float(np.median(np.abs(yt - ymed))) + 1e-12
        delta = 1.35 * mad if mad &gt; 1e-9 else 0.5 * ystd

        # Linear baseline to locate worsening center
        try:
            slope, intercept = np.polyfit(x, yt, 1)
        except Exception:
            slope, intercept = 0.0, ymed
        resid = yt - (intercept + slope * x)
        m0 = float(x[int(np.argmax(resid))]) if np.any(np.isfinite(resid)) else float(np.median(x))

        r0 = max(1e-3, 1.0 / xr)
        s0 = max(1e-3, 0.25 * xr)

        def solve_linear(r, s, m):
            dx = x - m
            F1 = np.exp(-r * dx)
            F2 = np.exp(-0.5 * (dx / s) ** 2)
            A = np.column_stack([np.ones_like(x), F1, F2])
            try:
                sol = np.linalg.solve(A.T @ A + ridge * np.eye(3), A.T @ yt)
                c, a, p = float(sol[0]), float(sol[1]), float(sol[2])
            except Exception:
                c, a, p = ymed, max(0.0, ymed - np.min(yt)), max(1e-9, np.percentile(resid, 90) - np.median(resid))
            return c, a, p, A

        lam_r, lam_s, lam_m, lam_neg = 1e-8, 1e-8, 1e-9, 1e-3

        def objective(nl):
            ur, us, m = nl
            r = _softplus(ur) + 1e-6
            s = _softplus(us) + 1e-6
            c, a, p, A = solve_linear(r, s, m)
            pred = A @ np.array([c, a, p])
            rres = pred - yt
            loss = huber_mean(rres, delta)
            loss += lam_neg * max(-a, 0.0) ** 2 + lam_neg * max(-p, 0.0) ** 2
            loss += lam_r * r * r + lam_s * s * s + lam_m * (m - m0) ** 2
            return loss

        bounds = [(None, None), (None, None), (xmin - xr, xmax + xr)]
        base = np.array([_inv_softplus(r0), _inv_softplus(s0), m0], dtype=float)
        rng = np.random.RandomState(1234 + t)
        inits = [base,
                 np.array([_inv_softplus(r0), _inv_softplus(s0), float(np.percentile(x, 20))]),
                 np.array([_inv_softplus(r0), _inv_softplus(s0), float(np.percentile(x, 50))]),
                 np.array([_inv_softplus(r0), _inv_softplus(s0), float(np.percentile(x, 80))])]
        for _ in range(6):
            pi = base + np.array([rng.normal(0, 0.5), rng.normal(0, 0.5), rng.normal(0, 0.2 * xr)])
            pi[2] = np.clip(pi[2], xmin - xr, xmax + xr)
            inits.append(pi)

        best_nl, best_v = base, objective(base)
        for p0 in inits:
            res = minimize(objective, p0, method=&quot;L-BFGS-B&quot;, bounds=bounds, options={&quot;maxiter&quot;: 300})
            nl = res.x if res.success else p0
            v = objective(nl)
            if v &lt; best_v:
                best_v, best_nl = v, nl

        ur, us, m_opt = best_nl
        r_opt = _softplus(ur) + 1e-6
        s_opt = _softplus(us) + 1e-6
        c_opt, a_opt, p_opt, _ = solve_linear(r_opt, s_opt, m_opt)
        a_opt = max(a_opt, 1e-9); p_opt = max(p_opt, 1e-9)

        params[t, :] = np.array([
            c_opt, _inv_softplus(a_opt), _inv_softplus(r_opt), _inv_softplus(p_opt), _inv_softplus(s_opt), m_opt
        ], dtype=float)

    return params[0] if T == 1 else params
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#4</span>
                    <span class="run-label">Run 2</span>
                    <span class="r2-badge" style="background-color: #D2691E; color: white;">
                        R² = 0.381104
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-3"># EVOLVE-BLOCK-START
&quot;&quot;&quot;
U-shaped/double-descent scaling law: difference of two logistics with shared slope.
Params (6): [y0, a1, a2, k, t1, t2]
- y0 &lt; 0: baseline (brier offset)
- a1 &gt;= 0: early worsening amplitude
- a2 &gt;= 0: later improvement amplitude
- k &gt; 0: shared slope
- t1 &lt; t2: transition locations (log10 FLOPs units)
Fit: robust Huber loss, mild L2 regularization, bounded multi-start L-BFGS-B.
&quot;&quot;&quot;
import numpy as np
from scipy.optimize import minimize

def _sigmoid(z):
    z = np.clip(z, -60.0, 60.0)
    return 1.0 / (1.0 + np.exp(-z))

def _neg_link(raw):
    # stable map to negative outputs; near-identity for sufficiently negative raw
    return -np.log1p(np.exp(-np.clip(raw, -60.0, 60.0)))

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    x = X[:, 0]
    p = np.asarray(params, dtype=float).ravel()
    y0, a1, a2 = p[0], np.clip(p[1], 0.0, 10.0), np.clip(p[2], 0.0, 10.0)
    k  = np.clip(p[3], 0.05, 20.0)
    t1, t2 = p[4], p[5]
    s1 = _sigmoid(k * (x - t1))
    s2 = _sigmoid(k * (x - t2))
    raw = y0 + a1 * s1 - a2 * s2
    return _neg_link(raw)

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.asarray(loss_values, dtype=float)
    x = X[:, 0]
    Y = y[:, None] if y.ndim == 1 else y
    N, T = Y.shape
    x_min, x_max = float(np.min(x)), float(np.max(x))
    xr = max(x_max - x_min, 1e-3)

    bounds = [
        (-2.5, -1e-4),                     # y0
        (0.0, 3.0),                        # a1
        (0.0, 3.0),                        # a2
        (0.05, 12.0),                      # k
        (x_min - 0.5 * xr, x_min + 0.8 * xr),  # t1
        (x_min + 0.2 * xr, x_max + 0.5 * xr)   # t2
    ]

    def huber(r, d):
        a = np.abs(r); m = a &lt;= d
        return 0.5 * (m * r * r) + (~m) * (d * (a - 0.5 * d))

    def make_obj(yc):
        iqr = float(np.percentile(yc, 75) - np.percentile(yc, 25))
        delta = max(0.5 * iqr, max(float(np.std(yc)), 1e-3) * 0.3)
        lam = 1e-4
        def obj(p):
            pred = scaling_law_func(x[:, None], p)
            r = pred - yc
            return float(np.mean(huber(r, delta)) + lam * np.sum(p * p))
        return obj

    params_opt = np.zeros((T, 6))
    for t in range(T):
        yc = Y[:, t]
        y0_init = float(np.clip(np.mean(yc), -1.2, -1e-4))
        k0 = np.clip(4.0 / xr, 0.1, 8.0)
        t1_init = x_min + 0.3 * xr
        t2_init = x_min + 0.8 * xr

        seeds = [
            np.array([y0_init, 0.2, 0.5, k0, t1_init, t2_init]),
            np.array([y0_init, 0.1, 0.4, 0.8, x_min + 0.2 * xr, x_min + 0.9 * xr]),
            np.array([y0_init, 0.3, 0.7, 1.5, x_min + 0.1 * xr, x_min + 0.6 * xr]),
            np.array([y0_init, 0.05, 0.6, 0.5, x_min + 0.4 * xr, x_min + 0.95 * xr]),
        ]
        rng = np.random.default_rng(1234 + t)
        for _ in range(2):
            seeds.append(np.array([
                y0_init,
                rng.uniform(0.05, 1.5),
                rng.uniform(0.1, 2.0),
                rng.uniform(bounds[3][0], bounds[3][1]),
                rng.uniform(bounds[4][0], bounds[4][1]),
                rng.uniform(bounds[5][0], bounds[5][1]),
            ]))

        obj = make_obj(yc)
        best_p, best_v = seeds[0], np.inf
        lb = np.array([b[0] for b in bounds]); ub = np.array([b[1] for b in bounds])
        for s in seeds:
            s = np.clip(s, lb, ub)
            res = minimize(obj, s, method=&#x27;L-BFGS-B&#x27;, bounds=bounds,
                           options={&#x27;maxiter&#x27;: 300, &#x27;ftol&#x27;: 1e-9})
            p = res.x if res.success else s
            v = obj(p)
            if v &lt; best_v:
                best_v, best_p = v, p
        params_opt[t] = best_p

    return params_opt[0] if T == 1 else params_opt
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#5</span>
                    <span class="run-label">Run 1</span>
                    <span class="r2-badge" style="background-color: #D2691E; color: white;">
                        R² = 0.219030
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-4"># EVOLVE-BLOCK-START
&quot;&quot;&quot;
U-shaped/double-descent scaling with ≤6 params.
Model: y(x) = A + R*exp(-K*x) + d / (1 + ((x-m)/s)^2)
Params: [A, R, Kraw, d, m, sraw], with K=sp(Kraw), s=sp(sraw) to ensure K&gt;0, s&gt;0.
Fitting: robust Huber loss, multi-start L-BFGS-B, mild regularization.
&quot;&quot;&quot;
import numpy as np
from scipy.optimize import minimize

def _sp(z):
    return np.log1p(np.exp(-np.abs(z))) + np.maximum(z, 0.0)

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points)); x = X[:, 0]
    p = np.atleast_2d(np.asarray(params))
    if p.shape[1] &lt; 6:
        p = np.concatenate([p, np.zeros((p.shape[0], 6 - p.shape[1]))], 1)
    A, R, Kraw, d, m, sraw = (p[:,0], p[:,1], p[:,2], p[:,3], p[:,4], p[:,5])
    K = _sp(Kraw) + 1e-6; s = _sp(sraw) + 1e-6
    xN = x[:, None]
    base = A[None,:] + R[None,:] * np.exp(np.clip(-K[None,:]*xN, -60, 60))
    bump = d[None,:] / (1.0 + ((xN - m[None,:]) / s[None,:])**2)
    y = base + bump
    return y[:,0] if y.shape[1] == 1 else y

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points)); x = X[:,0]
    Y = np.asarray(loss_values); Y = Y[:,None] if Y.ndim == 1 else Y
    N, T = Y.shape
    xmin, xmax = float(np.min(x)), float(np.max(x))
    xr = max(xmax - xmin, 1e-6); xstd = float(np.std(x)) if np.std(x) &gt; 1e-12 else 1.0

    def huber(res, delta):
        a = np.abs(res)
        return np.where(a &lt;= delta, 0.5*res**2, delta*(a - 0.5*delta))

    out = np.zeros((T, 6), float)
    for t in range(T):
        y = Y[:, t]
        Xlin = np.column_stack([np.ones(N), x])
        a_lin, b_lin = np.linalg.lstsq(Xlin, y, rcond=None)[0]
        rngy = float(np.max(y) - np.min(y)) + 1e-12
        A0 = float(a_lin + b_lin * xmax - 0.2 * rngy)
        R0 = float(max(0.1 * rngy, np.percentile(y, 90.0) - A0))
        K0 = 0.8 / (xstd + 1e-6)
        yb = A0 + R0 * np.exp(-K0 * x)
        r0 = y - yb
        m0 = float(x[np.argmax(r0)])
        s0 = 0.5 * xstd if xstd &gt; 1e-6 else 0.5
        d0 = float(max(np.max(r0), 0.3 * rngy))
        mad = np.median(np.abs(y - np.median(y))) + 1e-12
        delta = 1.4826 * mad

        def obj(p):
            A, R, Kraw, d, m, sraw = p
            K = _sp(Kraw) + 1e-6; s = _sp(sraw) + 1e-6
            yhat = A + R * np.exp(np.clip(-K * x, -60, 60)) + d / (1.0 + ((x - m) / s)**2)
            res = yhat - y
            reg = (1e-4*(A*A + R*R + d*d)
                   + 1e-5*(K * xr - 1.0)**2
                   + 1e-5*((m - (xmin + xmax)*0.5)/(xstd + 1e-6))**2
                   + 1e-5*((s/(xstd + 1e-6)) - 0.6)**2
                   + 5e-4*max(0.0, -R)**2 + 5e-4*max(0.0, -d)**2)
            return np.mean(huber(res, delta)) + reg

        inits = [
            np.array([A0, R0, K0, d0, m0, s0]),
            np.array([A0, 0.6*R0, 0.5*K0, 0.5*d0, xmin + 0.3*xr, 0.8*xstd]),
            np.array([np.median(y), 0.4*R0, 1.2*K0, 0.7*d0, xmin + 0.6*xr, 0.3*xstd]),
            np.array([a_lin, max(0.1, 0.2*R0), 0.9*K0, 1.2*d0, m0, 1.5*s0]),
            np.array([A0 - 0.2*rngy, 1.1*R0, 1.5*K0, 0.8*d0, xmin + 0.45*xr, xstd]),
        ]

        best_v, best_p = np.inf, inits[0]
        for init in inits:
            p0 = init + 0.03 * np.random.randn(6)
            res = minimize(obj, p0, method=&#x27;L-BFGS-B&#x27;)
            val = res.fun if res.success else obj(p0)
            if val &lt; best_v:
                best_v = val; best_p = res.x if res.success else p0

        out[t,:] = best_p

    return out[0] if T == 1 else out
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        </div>
        
        <footer class="footer">
            <p>SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> | <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a></p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleRun(header) {
            const content = header.nextElementSibling;
            const isExpanded = content.style.display === 'block';
            content.style.display = isExpanded ? 'none' : 'block';
            header.classList.toggle('expanded', !isExpanded);
        }
        
        function copyCode(event, codeId) {
            event.stopPropagation();
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }
        
        Prism.highlightAll();
    </script>
</body>
</html>
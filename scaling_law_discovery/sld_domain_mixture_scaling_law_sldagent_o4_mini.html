<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLD - Domain Mixture Scaling Law - SLDAgent + o4-mini</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --accent-primary: #2563eb;
        --accent-secondary: #3b82f6;
        --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
        --text-primary: #1f2937;
        --text-secondary: #4b5563;
        --border-subtle: rgba(0, 0, 0, 0.1);
        --glass-bg: rgba(0, 0, 0, 0.02);
        --success: #10b981;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          "Sora",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
      }

      .bg-pattern {
        display: none;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--accent-primary);
        text-decoration: none;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
        transition: color 0.2s;
      }

      .back-link:hover {
        color: var(--accent-secondary);
      }

      .header {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .meta-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .meta-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .r2-badge {
        display: inline-block;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", monospace;
      }

      .section-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .runs-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .run-card {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        overflow: hidden;
        transition: border-color 0.2s;
      }

      .run-card:hover {
        border-color: rgba(99, 102, 241, 0.3);
      }

      .run-card.best-run {
        border-color: var(--success);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
      }

      .run-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        transition: background 0.2s;
      }

      .run-header:hover {
        background: rgba(255, 255, 255, 0.04);
      }

      .run-info {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .run-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-secondary);
      }

      .run-badge.best-badge {
        background: var(--success);
        color: white;
      }

      .run-label {
        font-weight: 500;
        color: var(--text-primary);
      }

      .expand-icon {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: transform 0.2s;
      }

      .run-header.expanded .expand-icon {
        transform: rotate(180deg);
      }

      .run-content {
        border-top: 1px solid var(--border-subtle);
      }

      .code-container {
        overflow: hidden;
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.25rem;
        background: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid var(--border-subtle);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .copy-btn {
        padding: 0.35rem 0.75rem;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--accent-primary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-container pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        background: transparent !important;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid var(--border-subtle);
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .footer a {
        color: var(--accent-primary);
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .meta-row {
          flex-direction: column;
          gap: 0.75rem;
        }

        .run-info {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <a href="index.html" class="back-link"> ← Back to Leaderboard </a>

      <div class="header">
        <h1>Domain Mixture Scaling Law</h1>
        <div class="meta-row">
          <div class="meta-item">
            <span class="meta-label">Agent:</span>
            <span class="meta-value">SLDAgent</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Model:</span>
            <span class="meta-value">o4-mini</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Best R²:</span>
            <span class="r2-badge" style="background-color: #006400; color: white"> 0.998807 </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Mean R²:</span>
            <span class="meta-value">0.996258</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Min R²:</span>
            <span class="meta-value">0.991590</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Runs:</span>
            <span class="meta-value">5</span>
          </div>
        </div>
      </div>

      <h2 class="section-title">All Runs (sorted by R²)</h2>

      <div class="runs-container">
        <div class="run-card best-run">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge best-badge">Best</span>
              <span class="run-label">Run 5</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.998807 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: block">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-0">import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Predict multi-domain losses using a domain-specific power-law mix
    plus linear cross-domain coupling. Total params = 35:
      - params[0:20]: off-diagonal coupling weights (5x5 minus diag)
      - params[20:25]: own-domain weights
      - params[25:30]: input exponents
      - params[30:35]: per-domain biases
    preds[n,j] = w[j]*(X[n,j]**e[j]) + sum_{i!=j} W[j,i]*X[n,i] + b[j]
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    N, F = X.shape
    assert F == 5, &quot;Expected 5 mixture proportions&quot;
    p = np.asarray(params, dtype=float).ravel()

    # unpack off-diagonal weights into a 5x5 matrix with zeros on the diagonal
    mask = np.eye(5, dtype=bool)
    W_off = np.zeros((5, 5), dtype=float)
    W_off[~mask] = p[:20]

    # own-domain weights, exponents, and biases
    w_own = p[20:25]    # length-5
    e      = p[25:30]   # length-5
    b      = p[30:35]   # length-5

    # compute own-domain power-law contributions
    X_pow = np.power(X, e)        # shape (N,5) 
    own   = X_pow * w_own         # broadcast multiply each column

    # compute cross-domain linear contributions
    cross = X.dot(W_off.T)        # shape (N,5)

    # final prediction
    return own + cross + b

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 35 parameters to minimize MSE between predictions and true losses.
    Uses multi-start L-BFGS-B with exponent bounds [0.1, 5.0].
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    y = np.asarray(loss_values, dtype=float)
    if y.ndim == 1:
        y = y[:, None]
    N, F = X.shape
    assert F == 5 and y.shape == (N, 5), &quot;Expected shapes (N,5)&quot;

    P = 35
    # default initialization
    p0 = np.zeros(P, dtype=float)
    # own-domain weights initialized negative (higher mix lowers loss)
    p0[20:25] = -1.0
    # exponents initialized to linear
    p0[25:30] = 1.0
    # biases initialized to mean per-domain loss
    p0[30:35] = y.mean(axis=0)

    # bounds: exponents in [0.1,5], others unbounded
    bounds = [(None, None)] * 20 + [(None, None)] * 5 + [(0.1, 5.0)] * 5 + [(None, None)] * 5

    # objective: MSE
    def objective(p):
        pred = scaling_law_func(X, p)
        return np.mean((pred - y) ** 2)

    # multi-start optimization for robustness
    best_p, best_val = p0.copy(), np.inf
    for seed in (0, 1, 2):
        if seed == 0:
            init = p0
        else:
            rng = np.random.RandomState(seed)
            init = p0 + rng.randn(P) * 0.1
        res = minimize(objective, init,
                       method=&#x27;L-BFGS-B&#x27;,
                       bounds=bounds,
                       options={&#x27;maxiter&#x27;: 1000, &#x27;ftol&#x27;: 1e-9})
        if res.success and res.fun &lt; best_val:
            best_val, best_p = res.fun, res.x

    return best_p</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#2</span>
              <span class="run-label">Run 1</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.998073 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-1">import numpy as np
from scipy.optimize import least_squares

# EVOLVE-BLOCK-START

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Low‐rank + direct power‐law scaling (35 params):
      p[0:5]   exponents e_j
      p[5:15]  U (5×2)
      p[15:25] V (2×5)
      p[25:30] d (direct weights)
      p[30:35] b (biases)
    preds = (X**e)·U·V + (X**e)*d + b
    &quot;&quot;&quot;
    X = np.asarray(data_points, float)
    if X.ndim!=2 or X.shape[1]!=5:
        raise ValueError(&quot;data_points must be shape (N,5)&quot;)
    p = np.asarray(params, float).ravel()
    if p.size!=35:
        raise ValueError(f&quot;Expected 35 params, got {p.size}&quot;)

    e = p[0:5]
    U = p[5:15].reshape(5,2)
    V = p[15:25].reshape(2,5)
    d = p[25:30]
    b = p[30:35]

    X_e = np.power(X, e)
    latent = X_e.dot(U).dot(V)
    direct = X_e * d
    return latent + direct + b

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit 35 params via nonlinear least squares with ridge on params.
    Uses TRF solver with regularization included as extra residuals.
    &quot;&quot;&quot;
    X = np.asarray(data_points, float)
    y = np.asarray(loss_values, float)
    if X.ndim!=2 or X.shape[1]!=5:
        raise ValueError(&quot;data_points must be shape (N,5)&quot;)
    if y.ndim==1:
        y = y[:,None]
    if y.shape!=(X.shape[0],5):
        raise ValueError(&quot;loss_values must be shape (N,5)&quot;)

    N = X.shape[0]
    P = 35
    # bounds
    lb = np.r_[np.full(5,0.01), np.full(P-5, -np.inf)]
    ub = np.r_[np.full(5,5.0 ), np.full(P-5,  np.inf)]
    # init
    init = np.zeros(P)
    init[0:5] = 1.0
    # U diag init
    init[5] = init[5+1*2+1-1] = 1.0  # U[0,0] and U[1,1]
    # V diag init
    init[15] = init[15+1*5+1] = 1.0  # V[0,0] and V[1,1]
    # biases
    init[30:35] = np.mean(y, axis=0)

    # regularization weights
    ridge_e  = 1e-3
    ridge_uv = 1e-4
    ridge_d  = 1e-4

    def residuals(p):
        pred = scaling_law_func(X, p)
        # data residuals
        r_data = (pred - y).ravel()
        # reg residuals
        r_e  = np.sqrt(ridge_e)  * (p[0:5] - 1.0)
        r_uv = np.sqrt(ridge_uv) * p[5:25]
        r_d  = np.sqrt(ridge_d)  * p[25:30]
        return np.concatenate([r_data, r_e, r_uv, r_d])

    sol = least_squares(
        residuals,
        init,
        bounds=(lb, ub),
        method=&#x27;trf&#x27;,
        max_nfev=2000,
        ftol=1e-9,
        xtol=1e-9,
        gtol=1e-9
    )
    return sol.x if sol.success else init

# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#3</span>
              <span class="run-label">Run 4</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.997817 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-2">import numpy as np
from scipy.optimize import minimize

def scaling_law_func(X,p):
    # param‐to‐actual transforms: 
    # alphas in [0.01,5], d&gt;=0, C&gt;=0 via sigmoid and softplus
    v = p.ravel()
    a_min,a_max = 0.01, 5.0
    raw_a, raw_d, raw_c = v[:5], v[5:10], v[10:]
    a = a_min + (a_max-a_min)/(1+np.exp(-raw_a))
    d = np.log1p(np.exp(raw_d))
    C = np.log1p(np.exp(raw_c)).reshape(5,5)
    # compute X**a (broadcasting over columns)
    Xa = X**a
    return d[None,:] - Xa.dot(C.T)

def fit_scaling_law(X,y):
    X = np.asarray(X, float)
    y = np.asarray(y, float)
    if y.ndim&lt;2: 
        y = y[:,None]
    # initialize d from observed losses
    d0 = y.max(0)
    amp = d0 - y.min(0)
    # raw_d so that log1p(exp(raw_d)) ≈ d0
    raw_d = np.log(np.expm1(d0))
    # init coupling C0: half self‐domain, split rest equally
    C0 = np.zeros((5,5))
    for j in range(5):
        off = amp[j]*0.5/4.0
        C0[j,:] = off
        C0[j,j] = amp[j]*0.5
    raw_c = np.log(np.expm1(C0.ravel()))
    # start raw alphas at zero =&gt; a ≈ (0.01+5)/2
    init = np.r_[np.zeros(5), raw_d, raw_c]

    # objective: mean squared error
    obj = lambda v: np.mean((scaling_law_func(X,v) - y)**2)

    res = minimize(obj, init, method=&#x27;BFGS&#x27;, options={&#x27;maxiter&#x27;:1000})
    return res.x if res.success else init</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#4</span>
              <span class="run-label">Run 3</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.995001 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-3">import numpy as np

# EVOLVE-BLOCK-START
def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Predict multi-domain losses for 5 domains using a compact
    5-feature per-domain linear model (25 parameters total):
      f0 = bias
      f1 = -log(p_i)
      f2 = 1 - p_i
      f3 = global pairwise interaction sum
      f4 = p_i * (-log(p_i))
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    N, D = X.shape
    assert D == 5, &quot;Expected 5 mixture proportions&quot;
    
    p = np.asarray(params, dtype=float).ravel()
    assert p.size == 25, &quot;Parameter vector length must be 25&quot;
    W = p.reshape(5, 5)   # 5 features × 5 domains
    
    # numerical safety for log
    eps = 1e-6
    Xs = np.clip(X, eps, 1.0)
    
    # per-domain local features
    neglog = -np.log(Xs)             # (N,5)
    complement = 1.0 - X             # (N,5)
    local_int = X * neglog           # (N,5)
    
    # global mixture feature: sum_{i&lt;j} p_i * p_j
    s1 = X.sum(axis=1)               # (N,)
    s2 = (X * X).sum(axis=1)         # (N,)
    pairwise = 0.5 * (s1 * s1 - s2)  # (N,)
    
    # linear combination per domain
    # W[0]=bias, W[1]=neglog, W[2]=complement, W[3]=pairwise, W[4]=local interaction
    preds = (
        W[0][None, :] +
        W[1][None, :] * neglog +
        W[2][None, :] * complement +
        W[3][None, :] * pairwise[:, None] +
        W[4][None, :] * local_int
    )
    return preds


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 25 parameters via independent ridge regressions per domain
    on the 5-feature design:
      f0 = 1
      f1 = -log(p_i)
      f2 = 1 - p_i
      f3 = sum_{j&lt;k} p_j * p_k
      f4 = p_i * (-log p_i)
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    y = np.asarray(loss_values, dtype=float)
    N, D = X.shape
    assert D == 5, &quot;Expected 5 mixture proportions&quot;
    
    if y.ndim == 1:
        y = y[:, None]
    assert y.shape == (N, 5), &quot;Expected loss_values shape (N,5)&quot;
    
    # build features
    eps = 1e-6
    Xs = np.clip(X, eps, 1.0)
    neglog = -np.log(Xs)             # (N,5)
    complement = 1.0 - X             # (N,5)
    local_int = X * neglog           # (N,5)
    s1 = X.sum(axis=1)               # (N,)
    s2 = (X * X).sum(axis=1)         # (N,)
    pairwise = 0.5 * (s1 * s1 - s2)  # (N,)
    
    # placeholder for 5×5 weights
    P = np.zeros((5, 5), dtype=float)
    base_reg = 1e-6
    
    # fit one small ridge-regression per domain
    for i in range(5):
        Fi = np.column_stack([
            np.ones(N),
            neglog[:, i],
            complement[:, i],
            pairwise,
            local_int[:, i]
        ])  # shape (N,5)
        
        A = Fi.T.dot(Fi)
        # scale regularization by trace for stability
        reg = base_reg * np.trace(A) / A.shape[0]
        A += reg * np.eye(5)
        
        b = Fi.T.dot(y[:, i])
        P[:, i] = np.linalg.solve(A, b)
    
    return P.ravel()
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#5</span>
              <span class="run-label">Run 2</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.991590 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-4">import numpy as np

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Predict multi-domain losses for 5 domains given mixture proportions.
    Model form per domain j:
      loss_j = bias_j
               + w_log_j * log(p_j + ε)
               + w_cross_j * (1 - p_j)
               + w_pair  * sum_{i&lt;k} p_i p_k
               + w_ent   * entropy(p)
    Total parameters = 5 (bias) + 5 (w_log) + 5 (w_cross) + 1 (w_pair) + 1 (w_ent) = 17.
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    N, D = X.shape
    assert D == 5, &quot;Expected input shape (N,5)&quot;
    p = np.asarray(params, dtype=float).ravel()
    assert p.size == 17, &quot;Parameter vector must have length 17&quot;
    
    # unpack parameters
    bias      = p[0:5]      # domain-specific biases
    w_log     = p[5:10]     # domain-specific log-coefficients
    w_cross   = p[10:15]    # domain-specific cross-mass coefficients
    w_pair    = p[15]       # shared pairwise weight
    w_ent     = p[16]       # shared entropy weight

    # precompute shared features
    eps = 1e-8
    logs = np.log(X + eps)                # (N,5)
    cross = 1.0 - X                       # (N,5)
    sum_X = np.sum(X, axis=1)             # (N,)
    sum_X2 = np.sum(X * X, axis=1)        # (N,)
    pair  = 0.5 * (sum_X * sum_X - sum_X2) # (N,)
    ent   = -np.sum(X * logs, axis=1)     # (N,)

    # assemble predictions
    # Each term broadcasts appropriately over shape (N,5)
    preds = (
        bias[np.newaxis, :] +
        w_log[np.newaxis, :] * logs +
        w_cross[np.newaxis, :] * cross +
        w_pair * pair[:, np.newaxis] +
        w_ent  * ent[:, np.newaxis]
    )
    return preds


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 17 parameters via ridge‐regularized least squares.
    We flatten the 5 outputs into a single regression over N*5 rows.
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    y = np.asarray(loss_values, dtype=float)
    N, D = X.shape
    assert D == 5, &quot;Expected input shape (N,5)&quot;
    # ensure y is (N,5)
    if y.ndim == 1:
        y = y[:, None]
    assert y.shape == (N, 5), &quot;Expected loss_values shape (N,5)&quot;

    # precompute shared features
    eps = 1e-8
    logs  = np.log(X + eps)               # (N,5)
    cross = 1.0 - X                       # (N,5)
    sum_X = np.sum(X, axis=1)             # (N,)
    sum_X2 = np.sum(X * X, axis=1)        # (N,)
    pair  = 0.5 * (sum_X * sum_X - sum_X2) # (N,)
    ent   = -np.sum(X * logs, axis=1)     # (N,)

    # build design matrix Dmat of shape (N*5, 17)
    P = 17
    R = N * 5
    Dmat = np.zeros((R, P), dtype=float)
    y_flat = np.zeros(R, dtype=float)

    # row index base for each sample i
    for i in range(N):
        base = i * 5
        for j in range(5):
            idx = base + j
            # bias_j
            Dmat[idx, j] = 1.0
            # log term for domain j
            Dmat[idx, 5 + j] = logs[i, j]
            # cross-mass term for domain j
            Dmat[idx, 10 + j] = cross[i, j]
            # shared pairwise
            Dmat[idx, 15] = pair[i]
            # shared entropy
            Dmat[idx, 16] = ent[i]
            # target
            y_flat[idx] = y[i, j]

    # ridge regression: solve (D^T D + λ I) p = D^T y_flat
    A = Dmat.T.dot(Dmat)
    # scale regularizer by average feature variance
    lam = 1e-6 * np.trace(A) / P
    A += lam * np.eye(P)
    b = Dmat.T.dot(y_flat)

    # solve for parameter vector length 17
    p_opt = np.linalg.solve(A, b)
    return p_opt</code></pre>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> |
          <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a>
        </p>
      </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      function toggleRun(header) {
        const content = header.nextElementSibling;
        const isExpanded = content.style.display === "block";
        content.style.display = isExpanded ? "none" : "block";
        header.classList.toggle("expanded", !isExpanded);
      }

      function copyCode(event, codeId) {
        event.stopPropagation();
        const code = document.getElementById(codeId).textContent;
        navigator.clipboard.writeText(code).then(() => {
          const btn = event.target;
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 2000);
        });
      }

      Prism.highlightAll();
    </script>
  </body>
</html>

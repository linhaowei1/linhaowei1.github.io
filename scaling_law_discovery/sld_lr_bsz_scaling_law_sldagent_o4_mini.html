<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLD - LR & Batch Size Scaling Law - SLDAgent + o4-mini</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --accent-primary: #2563eb;
        --accent-secondary: #3b82f6;
        --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
        --text-primary: #1f2937;
        --text-secondary: #4b5563;
        --border-subtle: rgba(0, 0, 0, 0.1);
        --glass-bg: rgba(0, 0, 0, 0.02);
        --success: #10b981;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          "Sora",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
      }

      .bg-pattern {
        display: none;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--accent-primary);
        text-decoration: none;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
        transition: color 0.2s;
      }

      .back-link:hover {
        color: var(--accent-secondary);
      }

      .header {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .meta-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .meta-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .r2-badge {
        display: inline-block;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", monospace;
      }

      .section-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .runs-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .run-card {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        overflow: hidden;
        transition: border-color 0.2s;
      }

      .run-card:hover {
        border-color: rgba(99, 102, 241, 0.3);
      }

      .run-card.best-run {
        border-color: var(--success);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
      }

      .run-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        transition: background 0.2s;
      }

      .run-header:hover {
        background: rgba(255, 255, 255, 0.04);
      }

      .run-info {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .run-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-secondary);
      }

      .run-badge.best-badge {
        background: var(--success);
        color: white;
      }

      .run-label {
        font-weight: 500;
        color: var(--text-primary);
      }

      .expand-icon {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: transform 0.2s;
      }

      .run-header.expanded .expand-icon {
        transform: rotate(180deg);
      }

      .run-content {
        border-top: 1px solid var(--border-subtle);
      }

      .code-container {
        overflow: hidden;
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.25rem;
        background: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid var(--border-subtle);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .copy-btn {
        padding: 0.35rem 0.75rem;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--accent-primary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-container pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        background: transparent !important;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid var(--border-subtle);
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .footer a {
        color: var(--accent-primary);
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .meta-row {
          flex-direction: column;
          gap: 0.75rem;
        }

        .run-info {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <a href="sld_index.html" class="back-link"> ← Back to Leaderboard </a>

      <div class="header">
        <h1>LR & Batch Size Scaling Law</h1>
        <div class="meta-row">
          <div class="meta-item">
            <span class="meta-label">Agent:</span>
            <span class="meta-value">SLDAgent</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Model:</span>
            <span class="meta-value">o4-mini</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Best R²:</span>
            <span class="r2-badge" style="background-color: #d2691e; color: white"> 0.048849 </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Mean R²:</span>
            <span class="meta-value">0.003083</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Min R²:</span>
            <span class="meta-value">-0.021386</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Runs:</span>
            <span class="meta-value">5</span>
          </div>
        </div>
      </div>

      <h2 class="section-title">All Runs (sorted by R²)</h2>

      <div class="runs-container">
        <div class="run-card best-run">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge best-badge">Best</span>
              <span class="run-label">Run 3</span>
              <span class="r2-badge" style="background-color: #d2691e; color: white"> R² = 0.048849 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: block">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-0">import numpy as np

# normalization constants
_lr0, _bsz0, _D0, _N0 = 1e-3, 256.0, 1e10, 1e8

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Predict LM loss via a log-linear model with quadratic and interaction terms:
      L_pred = Linf + exp(w0 + w1*log(N/N0) + w2*log(D/D0)
                       + w3*log(lr/lr0) + w4*log(bsz/bsz0)
                       + w5*(log(lr/lr0))^2 + w6*(log(bsz/bsz0))^2
                       + w7*log(N/N0)*log(lr/lr0)
                       + w8*log(N/N0)*log(bsz/bsz0))

    Params is a length-10 vector:
      [0] Linf
      [1:] w0..w8
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points))
    lr   = X[:,0]
    bsz  = X[:,1]
    D    = X[:,2]
    Npar = X[:,3]

    # log-features
    uN  = np.log(Npar / _N0)
    uD  = np.log(D    / _D0)
    uLR = np.log(lr   / _lr0)
    uBS = np.log(bsz  / _bsz0)

    # design matrix with intercept, linear, quadratic, and interaction terms
    F = np.stack([
        np.ones_like(uN),
        uN, uD, uLR, uBS,
        uLR**2, uBS**2,
        uN * uLR,
        uN * uBS
    ], axis=1)  # shape (N,9)

    p = np.ravel(params)
    assert p.size == 10, f&quot;Expected 10 parameters, got {p.size}&quot;
    Linf = p[0]
    w    = p[1:]  # length 9

    lin = F.dot(w)          # linear combination
    y_pred = Linf + np.exp(lin)
    return y_pred

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 10-parameter log-linear law by:
      1) Gridding Linf in [0.5*min(y),0.95*min(y)]
      2) For each Linf, solving linear least squares on
         log(y - Linf) = F * w
      3) Selecting the solution minimizing log-space MSE.
    Returns optimized params of length 10.
    &quot;&quot;&quot;
    X_in = np.atleast_2d(np.asarray(data_points))
    y    = np.asarray(loss_values).ravel()
    lr   = X_in[:,0]
    bsz  = X_in[:,1]
    D    = X_in[:,2]
    Npar = X_in[:,3]

    # build feature matrix
    uN  = np.log(Npar / _N0)
    uD  = np.log(D    / _D0)
    uLR = np.log(lr   / _lr0)
    uBS = np.log(bsz  / _bsz0)
    F   = np.stack([
        np.ones_like(uN),
        uN, uD, uLR, uBS,
        uLR**2, uBS**2,
        uN * uLR,
        uN * uBS
    ], axis=1)  # shape (N,9)

    y_min = np.min(y)
    Linf_candidates = np.linspace(0.5 * y_min, 0.95 * y_min, 20)

    best_score = np.inf
    best_params = None

    for Linf in Linf_candidates:
        y_shift = y - Linf
        if np.any(y_shift &lt;= 0):
            continue
        logy = np.log(y_shift)
        # solve for weights w in least squares
        w, *_ = np.linalg.lstsq(F, logy, rcond=None)
        lin   = F.dot(w)
        y_pred = Linf + np.exp(lin)
        # log-space MSE
        mse = np.mean((np.log(y_pred) - np.log(y))**2)
        if mse &lt; best_score:
            best_score = mse
            best_params = np.concatenate(([Linf], w))

    if best_params is None:
        # fallback to simple guess
        fallback = np.zeros(10, dtype=float)
        fallback[0] = 0.9 * y_min
        return fallback

    return best_params</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#2</span>
              <span class="run-label">Run 2</span>
              <span class="r2-badge" style="background-color: #b22222; color: white"> R² = -0.000447 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-1">import numpy as np
from scipy.optimize import minimize

# EVOLVE-BLOCK-START
# normalization constants to keep features in a comparable range
_lr0  = 1e-3
_bsz0 = 256.0
_D0   = 1e10
_N0   = 1e8

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Composite scaling law with separate contributions:
      L = Linf
        + A * (N/N0)^(-alpha) * (D/D0)^(-beta)
        + B_lr * (ln(lr/lr0) + phi_lr)^2
        + B_bsz * (bsz/bsz0)^(-delta)

    params vector (length 8):
      [0] Linf       (asymptotic loss floor)
      [1] log(A)     (prefactor for N/D term)
      [2] log(alpha) (exponent on N)
      [3] log(beta)  (exponent on D)
      [4] log(B_lr)  (scale for lr‐term)
      [5] phi_lr     (shift in log‐lr space)
      [6] log(B_bsz) (scale for bsz‐term)
      [7] log(delta) (exponent on bsz)
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points))
    lr   = X[:, 0]
    bsz  = X[:, 1]
    D    = X[:, 2]
    Npar = X[:, 3]

    # normalized inputs
    x_lr  = lr   / _lr0
    x_bsz = bsz  / _bsz0
    x_D   = D    / _D0
    x_N   = Npar / _N0

    p = np.asarray(params)
    # ensure shape (T,8)
    if p.ndim == 1:
        p = p[None, :]
    T, P = p.shape
    assert P == 8, f&quot;Expected 8 parameters, got {P}&quot;

    # unpack &amp; invert transformations
    Linf   = p[:, 0]              # can be any real
    A      = np.exp(p[:, 1])      # &gt;0
    alpha  = np.exp(p[:, 2])      # &gt;0
    beta   = np.exp(p[:, 3])      # &gt;0
    B_lr   = np.exp(p[:, 4])      # &gt;0
    phi_lr = p[:, 5]              # real shift
    B_bsz  = np.exp(p[:, 6])      # &gt;0
    delta  = np.exp(p[:, 7])      # &gt;0

    # compute each term with broadcasting
    # N&amp;D term
    term_nd = A[None, :] * (x_N[:, None] ** (-alpha[None, :])) \
                       * (x_D[:, None] ** (-beta[None, :]))
    # lr term (quadratic in log space)
    ln_lr   = np.log(x_lr)[:, None]
    term_lr = B_lr[None, :] * (ln_lr + phi_lr[None, :])**2
    # bsz term
    term_bz = B_bsz[None, :] * (x_bsz[:, None] ** (-delta[None, :]))

    Y = Linf[None, :] + term_nd + term_lr + term_bz
    # return (N,) if single set else (N,T)
    return Y[:, 0] if T == 1 else Y

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 8-parameter scaling law by minimizing
    mean squared error in loss-space:
      objective = mean((L_pred - L_true)^2)
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points))
    y = np.asarray(loss_values).ravel()

    # initialize parameters
    linf0 = np.min(y) * 0.9   # floor just below observed min
    p0 = np.zeros(8, dtype=float)
    p0[0] = linf0
    # leave others at zero (A=1, alpha=1, beta=1, B_lr=1, phi=0, B_bsz=1, delta=1)

    # bounds to ensure stability and physicality
    bnds = [
        (0.0,       np.min(y)),  # Linf &gt;= 0, &lt;= smallest observed
        (-20.0, 20.0),           # log(A)
        (-5.0,   5.0),           # log(alpha)
        (-5.0,   5.0),           # log(beta)
        (-20.0, 20.0),           # log(B_lr)
        (-5.0,   5.0),           # phi_lr
        (-20.0, 20.0),           # log(B_bsz)
        (-5.0,   5.0)            # log(delta)
    ]

    def objective(p):
        y_pred = scaling_law_func(X, p)
        # heavy penalty for non-positive predictions
        if np.any(y_pred &lt;= 0):
            return 1e6 + np.sum((np.minimum(1e-6, y_pred))**2)
        return np.mean((y_pred - y) ** 2)

    res = minimize(objective, p0, method=&#x27;L-BFGS-B&#x27;, bounds=bnds)
    return res.x if res.success else p0
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#3</span>
              <span class="run-label">Run 1</span>
              <span class="r2-badge" style="background-color: #b22222; color: white"> R² = -0.000450 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-2">import numpy as np
from scipy.optimize import minimize

# normalization constants
_lr0  = 1e-3
_bsz0 = 256.0
_D0   = 1e10
_N0   = 1e8

# EVOLVE-BLOCK-START
def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Revised composite scaling law (9 params):
      L = Linf
        + A * [ (N/N0)^(-α) + (D/D0)^(-β) ]
        + B_lr * |ln(lr/lr0) + φ|^γ
        + B_bsz * (bsz/bsz0)^(-δ)

    params = [
      Linf,
      log(A), log(α), log(β),
      log(B_lr), φ, log(γ),
      log(B_bsz), log(δ)
    ]
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    lr, bsz, D, Np = X[:,0], X[:,1], X[:,2], X[:,3]

    # normalized inputs
    x_lr  = lr  / _lr0
    x_bsz = bsz / _bsz0
    x_D   = D   / _D0
    x_N   = Np  / _N0

    p = np.asarray(params, dtype=float).ravel()
    if p.size != 9:
        raise ValueError(f&quot;Expected 9 parameters, got {p.size}&quot;)

    # unpack &amp; invert transforms
    Linf   = p[0]
    A      = np.exp(p[1])
    α      = np.exp(p[2])
    β      = np.exp(p[3])
    B_lr   = np.exp(p[4])
    φ      = p[5]
    γ      = np.exp(p[6])
    B_bsz  = np.exp(p[7])
    δ      = np.exp(p[8])

    # main ND‐term: additive rather than multiplicative to better decouple N and D
    term_ND  = A * (x_N**(-α) + x_D**(-β))
    # lr‐penalty: flexible exponent around optimal log‐lr shift φ
    term_lr  = B_lr * (np.abs(np.log(x_lr) + φ) ** γ)
    # batch‐size penalty
    term_bsz = B_bsz * (x_bsz ** (-δ))

    return Linf + term_ND + term_lr + term_bsz


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 9‐parameter model by minimizing MSE in loss‐space:
      objective = mean((L_pred - L_true)^2)
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.asarray(loss_values, dtype=float).ravel()

    # initial guess
    p0 = np.zeros(9, dtype=float)
    p0[0] = 0.9 * np.min(y)   # Linf just below observed min
    # log(A), log(α), log(β) default to zero =&gt; A=1, α=1, β=1
    # log(B_lr)=0, φ=0, log(γ)=ln(2) =&gt; start near quadratic lr penalty
    p0[6] = np.log(2.0)
    # log(B_bsz)=0, log(δ)=0 =&gt; bsz-term ~1/bsz

    # parameter bounds for stability
    bnds = [
        (0.0,       np.min(y)),        # Linf
        (-20.0,     20.0),             # log(A)
        (-5.0,      5.0),              # log(α)
        (-5.0,      5.0),              # log(β)
        (-20.0,     20.0),             # log(B_lr)
        (-5.0,      5.0),              # φ
        (np.log(0.1), np.log(10.0)),   # log(γ)
        (-20.0,     20.0),             # log(B_bsz)
        (-5.0,      5.0)               # log(δ)
    ]

    def objective(p):
        y_pred = scaling_law_func(X, p)
        # heavy penalty for non‐physical predictions
        if np.any(y_pred &lt;= 0):
            return 1e6 + np.sum((np.minimum(1e-6, y_pred))**2)
        return np.mean((y_pred - y)**2)

    res = minimize(objective, p0, method=&#x27;L-BFGS-B&#x27;, bounds=bnds)
    return res.x if res.success else p0
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#4</span>
              <span class="run-label">Run 4</span>
              <span class="r2-badge" style="background-color: #b22222; color: white"> R² = -0.011151 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-3"># EVOLVE-BLOCK-START
import numpy as np

# normalization references (static, input‐independent)
_lr0, _bsz0, _D0, _N0 = 1e-3, 256.0, 1e10, 1e8

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Linear-in-parameters model on log-features plus quadratic and interaction:
      f1 = log(N/N0), f2 = log(D/D0),
      f3 = log(bsz/bsz0), f4 = log(lr/lr0),
      f5 = f4^2, f6 = f4*f3
    L = w0 + w1*f1 + w2*f2 + w3*f3 + w4*f4 + w5*f5 + w6*f6
    params: length-7 or shape (T,7)
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    lr   = X[:,0]; bsz = X[:,1]; D = X[:,2]; Np = X[:,3]
    # compute log-features
    f1 = np.log(Np / _N0 + 1e-20)
    f2 = np.log(D  / _D0 + 1e-20)
    f3 = np.log(bsz/_bsz0 + 1e-20)
    f4 = np.log(lr  / _lr0 + 1e-20)
    f5 = f4 * f4
    f6 = f4 * f3
    # stack feature matrix (N,7)
    F = np.vstack([np.ones_like(f1), f1, f2, f3, f4, f5, f6]).T

    p = np.asarray(params, dtype=float)
    # handle multi-output
    if p.ndim == 1:
        # single vector
        return F.dot(p)
    else:
        # each row of p is a separate weight vector
        # returns shape (N, T)
        return F.dot(p.T)

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 7 linear weights by ridge regression on log-features:
    w = argmin ||F w - y||^2 + λ||w||^2, closed-form solution.
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.asarray(loss_values, dtype=float).ravel()
    lr   = X[:,0]; bsz = X[:,1]; D = X[:,2]; Np = X[:,3]
    # recompute same features as in scaling_law_func
    f1 = np.log(Np / _N0 + 1e-20)
    f2 = np.log(D  / _D0 + 1e-20)
    f3 = np.log(bsz/_bsz0 + 1e-20)
    f4 = np.log(lr  / _lr0 + 1e-20)
    f5 = f4 * f4
    f6 = f4 * f3
    F = np.vstack([np.ones_like(f1), f1, f2, f3, f4, f5, f6]).T

    # ridge regularization parameter
    λ = 1e-4
    # closed-form ridge solution: (F^T F + λI)^{-1} F^T y
    FT_F = F.T.dot(F)
    reg = λ * np.eye(FT_F.shape[0])
    w = np.linalg.solve(FT_F + reg, F.T.dot(y))
    return w
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#5</span>
              <span class="run-label">Run 5</span>
              <span class="r2-badge" style="background-color: #b22222; color: white"> R² = -0.021386 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-4">import numpy as np
from scipy.optimize import minimize

# EVOLVE-BLOCK-START
# Normalization constants for numerical stability
_lr0  = 1e-3
_bsz0 = 256.0
_D0   = 1e10
_N0   = 1e8

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Composite 4‐term scaling law:
      L_pred = Linf
             + A * (N/N0)^(-alpha_N) * (D/D0)^(-alpha_D)
             + C * (lr/lr0)^( gamma)
             + E * (bsz/bsz0)^(-delta)

    params (length 8):
      [0] Linf        (baseline loss floor)
      [1] log(A)      (prefactor for N-D joint term)
      [2] alpha_N     (exponent on N-term, real, will use exp)
      [3] alpha_D     (exponent on D-term, real, will use exp)
      [4] log(C)      (prefactor for lr term)
      [5] gamma       (exponent on lr, real)
      [6] log(E)      (prefactor for bsz term)
      [7] delta       (exponent on bsz, real)
    &quot;&quot;&quot;
    X = np.atleast_2d(data_points).astype(float)
    lr, bsz, D, Np = X[:,0], X[:,1], X[:,2], X[:,3]
    # normalize features
    x_lr  = lr  / _lr0
    x_bsz = bsz / _bsz0
    x_D   = D   / _D0
    x_N   = Np  / _N0

    p = np.asarray(params, dtype=float)
    if p.ndim == 1:
        p = p[None,:]
    assert p.shape[1] == 8, f&quot;Expected 8 parameters, got {p.shape[1]}&quot;

    Linf    = p[:,0]
    A       = np.exp(p[:,1])
    alpha_N = np.exp(p[:,2])
    alpha_D = np.exp(p[:,3])
    C       = np.exp(p[:,4])
    gamma   = p[:,5]
    E       = np.exp(p[:,6])
    delta   = p[:,7]

    # compute terms with broadcasting to shape (N,1)
    term_nd  = A[None,:] * (x_N[:,None]**(-alpha_N[None,:])) * (x_D[:,None]**(-alpha_D[None,:]))
    term_lr  = C[None,:] * (x_lr[:,None]**(gamma[None,:]))
    term_bsz = E[None,:] * (x_bsz[:,None]**(-delta[None,:]))

    Y = Linf[None,:] + term_nd + term_lr + term_bsz
    return Y[:,0] if Y.shape[1] == 1 else Y

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 8-parameter scaling law by staged least-squares initialization
    followed by joint log-space L-BFGS-B optimization.
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.asarray(loss_values, dtype=float).ravel()
    Np = X.shape[0]
    # 1) Baseline floor just below minimal observed loss
    Linf0 = 0.8 * np.min(y)
    # residual for joint N-D term
    y0 = y - Linf0
    # avoid non-positive
    eps0 = np.min(y0[y0&gt;0]) * 0.5
    y0 = np.maximum(y0, eps0)

    # 2) Init joint N-D term by linear regression in log-space
    lnY0 = np.log(y0)
    lnN  = -np.log(X[:,3] / _N0)
    lnD  = -np.log(X[:,2] / _D0)
    M_nd = np.vstack([np.ones_like(lnY0), lnN, lnD]).T
    coef_nd, *_ = np.linalg.lstsq(M_nd, lnY0, rcond=None)
    logA0, alphaN0, alphaD0 = coef_nd

    # compute first-term prediction and residual
    term_nd0 = np.exp(logA0) * (X[:,3]/_N0)**(-alphaN0) * (X[:,2]/_D0)**(-alphaD0)
    r1 = y0 - term_nd0
    eps1 = np.min(r1[r1&gt;0]) * 0.5
    r1 = np.maximum(r1, eps1)

    # 3) Init lr term via log-regression on residual r1
    lnr1 = np.log(r1)
    lnLR = np.log(X[:,0] / _lr0)
    M_lr = np.vstack([np.ones_like(lnr1), lnLR]).T
    coef_lr, *_ = np.linalg.lstsq(M_lr, lnr1, rcond=None)
    logC0, gamma0 = coef_lr

    # subtract lr term, form second residual
    term_lr0 = np.exp(logC0) * (X[:,0]/_lr0)**(gamma0)
    r2 = r1 - term_lr0
    eps2 = np.min(r2[r2&gt;0]) * 0.5
    r2 = np.maximum(r2, eps2)

    # 4) Init bsz term via log-regression on residual r2
    lnr2 = np.log(r2)
    lnBSZ = -np.log(X[:,1] / _bsz0)
    M_bz = np.vstack([np.ones_like(lnr2), lnBSZ]).T
    coef_bz, *_ = np.linalg.lstsq(M_bz, lnr2, rcond=None)
    logE0, delta0 = coef_bz

    # 5) Pack initial parameter vector
    theta0 = np.array([
        Linf0,
        logA0,
        alphaN0,
        alphaD0,
        logC0,
        gamma0,
        logE0,
        delta0
    ], dtype=float)

    # 6) Refine all parameters with log-space MSE objective
    eps = 1e-8
    def obj(p):
        y_pred = scaling_law_func(X, p)
        # penalize non-positive
        if np.any(y_pred &lt;= 0):
            return 1e6 + np.sum((np.minimum(y_pred, eps) - eps)**2)
        return np.mean((np.log(y_pred + eps) - np.log(y + eps))**2)

    # bounds for stability
    bnds = [
        (0.0, np.min(y)),    # Linf
        (-20, 20),           # logA
        (-5, 5),             # alpha_N (exp)
        (-5, 5),             # alpha_D (exp)
        (-20, 20),           # logC
        (-10, 10),           # gamma
        (-20, 20),           # logE
        (-10, 10)            # delta
    ]

    res = minimize(obj, theta0, method=&#x27;L-BFGS-B&#x27;, bounds=bnds)
    return res.x if (res.success and res.x.shape == theta0.shape) else theta0
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> |
          <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a>
        </p>
      </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      function toggleRun(header) {
        const content = header.nextElementSibling;
        const isExpanded = content.style.display === "block";
        content.style.display = isExpanded ? "none" : "block";
        header.classList.toggle("expanded", !isExpanded);
      }

      function copyCode(event, codeId) {
        event.stopPropagation();
        const code = document.getElementById(codeId).textContent;
        navigator.clipboard.writeText(code).then(() => {
          const btn = event.target;
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 2000);
        });
      }

      Prism.highlightAll();
    </script>
  </body>
</html>

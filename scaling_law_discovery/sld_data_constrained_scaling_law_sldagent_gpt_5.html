<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLD - Data-Constrained Scaling Law - SLDAgent + GPT-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --accent-primary: #2563eb;
            --accent-secondary: #3b82f6;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-subtle: rgba(0, 0, 0, 0.1);
            --glass-bg: rgba(0, 0, 0, 0.02);
            --success: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Sora', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .bg-pattern {
            display: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--accent-secondary);
        }
        
        .header {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .meta-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .meta-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .meta-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .r2-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .runs-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .run-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .run-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .run-card.best-run {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.02);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .run-header:hover {
            background: rgba(255, 255, 255, 0.04);
        }
        
        .run-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .run-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        
        .run-badge.best-badge {
            background: var(--success);
            color: white;
        }
        
        .run-label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .expand-icon {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .run-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .run-content {
            border-top: 1px solid var(--border-subtle);
        }
        
        .code-container {
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .copy-btn {
            padding: 0.35rem 0.75rem;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .copy-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }
        
        .code-container pre {
            margin: 0;
            padding: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-x: auto;
            background: transparent !important;
        }
        
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .meta-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .run-info {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <a href="sld_index.html" class="back-link">
            ← Back to Leaderboard
        </a>
        
        <div class="header">
            <h1>Data-Constrained Scaling Law</h1>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Agent:</span>
                    <span class="meta-value">SLDAgent</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Model:</span>
                    <span class="meta-value">GPT-5</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best R²:</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        0.994435
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Mean R²:</span>
                    <span class="meta-value">0.973934</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Min R²:</span>
                    <span class="meta-value">0.952393</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Runs:</span>
                    <span class="meta-value">5</span>
                </div>
            </div>
        </div>
        
        <h2 class="section-title">All Runs (sorted by R²)</h2>
        
        <div class="runs-container">
            
        <div class="run-card best-run">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge best-badge">Best</span>
                    <span class="run-label">Run 4</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.994435
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: block;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-0"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    u, p, d = X[:, 0], X[:, 1], X[:, 2]
    pr = np.asarray(params, dtype=float)
    if pr.ndim == 1:
        pr = pr[None, :]
    lu = np.log(np.maximum(u, 1.0))
    lp = np.log(np.maximum(p, 1.0))
    ld = np.log(np.maximum(d, 1.0))
    out = np.zeros((X.shape[0], pr.shape[0]))
    sp = lambda z: np.log1p(np.exp(-np.abs(z))) + np.maximum(z, 0.0)
    for i, th in enumerate(pr):
        L0 = sp(th[0]) + 1e-12
        A  = sp(th[1])
        a  = sp(th[2]) + 1e-9
        B  = sp(th[3])
        b  = sp(th[4]) + 1e-9
        s  = sp(th[5]) + 1e-12
        nu = 0.1 + sp(th[6])
        ls = np.log(s)
        lS = -np.logaddexp(-ld, -(ls + lu))  # log HM of D and s*U
        tP = A * np.exp(np.clip(-a * lp, -100.0, 100.0))
        tS = B * np.exp(np.clip(-b * lS, -100.0, 100.0))
        z = np.clip(a * (lS - lp), -60.0, 60.0)  # data-limited gating for capacity term
        gate = 1.0 / (1.0 + np.exp(-z))
        tP *= gate
        inner = np.power(np.maximum(tP, 0.0), nu) + np.power(np.maximum(tS, 0.0), nu)
        out[:, i] = L0 + np.power(np.maximum(inner, 1e-300), 1.0 / np.maximum(nu, 1e-6))
    return out[:, 0] if out.shape[1] == 1 else out

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.asarray(loss_values, dtype=float)
    Y = y[:, None] if y.ndim == 1 else y
    ld = np.log(np.maximum(X[:, 2], 1.0))
    lu = np.log(np.maximum(X[:, 0], 1.0))
    y_min, y_max = float(np.min(Y)), float(np.max(Y))
    yr = max(y_max - y_min, 1e-3)
    s_init = np.exp(np.mean(ld - lu))
    inv_sp = lambda v: np.log(np.expm1(np.maximum(v, 1e-12)))
    def huber(r, d):
        a = np.abs(r)
        return np.mean(np.where(a &lt;= d, 0.5 * r * r, d * (a - 0.5 * d)))
    def make_obj(delta):
        return lambda w, t: huber(scaling_law_func(X, w) - Y[:, t], delta) + 1e-6 * np.sum(w * w)
    outs = []
    for t in range(Y.shape[1]):
        L0 = max(y_min - 0.15 * yr, 1e-3)
        A0, B0 = 0.7 * yr, 0.7 * yr
        a0, b0, nu0 = 0.35, 0.35, 0.9
        base = np.array([inv_sp(L0), inv_sp(A0), inv_sp(a0), inv_sp(B0), inv_sp(b0), inv_sp(s_init), inv_sp(nu0 - 0.1)], float)
        obj0 = make_obj(0.6); obj1 = make_obj(0.35)
        best, bestv = base, obj0(base, t)
        rng = np.random.RandomState(133 + t)
        for _ in range(12):
            trial = base.copy()
            z = rng.normal(0, 0.2, 7)
            trial[0] += z[0] * yr
            trial[1:] += z[1:]
            res = minimize(lambda w: obj0(w, t), trial, method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 400})
            if np.all(np.isfinite(res.x)):
                val = obj0(res.x, t)
                if val &lt; bestv:
                    best, bestv = res.x, val
        for _ in range(6):
            trial = best + rng.normal(0, 0.08, 7)
            res = minimize(lambda w: obj1(w, t), trial, method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 300})
            if np.all(np.isfinite(res.x)):
                val = obj1(res.x, t)
                if val &lt; bestv:
                    best, bestv = res.x, val
        outs.append(best)
    P = np.vstack(outs)
    return P[0] if P.shape[0] == 1 else P
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#2</span>
                    <span class="run-label">Run 5</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.980300
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-1"># EVOLVE-BLOCK-START
&quot;&quot;&quot;
Coupled scaling law for data-constrained LLM training with uniqueness-aware effective data.

Model (&lt;=7 params per target):
  s = D / U  (duplication ratio)
  D_eff = D / (1 + k * s^{nu})
  Base(P, D_eff) = P^{-a_P} + D_eff^{-a_D}
  L(P, D, U) = L_inf + A * Base(P, D_eff)^{gamma}

Parameters: [L_inf, A, a_P, a_D, k, nu, gamma]
- L_inf is free (can be any real)
- A, a_P, a_D, k &gt; 0 via softplus
- nu in (0, 1) via sigmoid
- gamma in (0.2, 1.0) via sigmoid affine (concave mixing, diminishing returns)

Fitting:
- Robust pseudo-Huber objective with variance scaling
- Softplus/sigmoid reparameterization
- L-BFGS-B with light L2 regularization and weak priors
- Small multi-start for stability
&quot;&quot;&quot;
import numpy as np
from scipy.optimize import minimize

_EPS = 1e-12
_P0, _D0, _U0 = 1e8, 1e9, 1e7  # reference scales for numerics

def _softplus(x):
    return np.log1p(np.exp(-np.abs(x))) + np.maximum(x, 0.0) + 1e-12

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))
    U, P, D = X[:, 0], X[:, 1], X[:, 2]

    th = np.asarray(params, dtype=np.float64)
    if th.ndim == 1:
        th = th[None, :]
    if th.shape[1] &lt; 7:
        th = np.pad(th, ((0,0),(0,7 - th.shape[1])), mode=&#x27;constant&#x27;, constant_values=0.0)
    th = th[:, :7]
    T = th.shape[0]

    L_inf = th[:, 0]
    A     = th[:, 1]
    a_P   = th[:, 2]
    a_D   = th[:, 3]
    k     = th[:, 4]
    nu    = th[:, 5]
    gamma = th[:, 6]

    # Log-normalized inputs for stability
    logP = (np.log(P + _EPS) - np.log(_P0))[:, None]    # (N,1)
    logD = (np.log(D + _EPS) - np.log(_D0))[:, None]
    logU = (np.log(U + _EPS) - np.log(_U0))[:, None]
    log_s = (logD - logU)                                # log(D/U)

    # log(1 + k * s^nu) = softplus(logk + nu * log_s)
    logk = np.log(np.maximum(k, _EPS))[None, :]          # (1,T)
    x = logk + nu[None, :] * log_s                       # (N,T)
    log_den = _softplus(x)                               # log(1 + k s^nu)

    # log D_eff = logD - log_den
    base_P = np.exp(-a_P[None, :] * logP)                # P^{-a_P}
    base_D = np.exp(-a_D[None, :] * (logD - log_den))    # D_eff^{-a_D}
    base = base_P + base_D

    pred = L_inf[None, :] + A[None, :] * np.power(base, np.maximum(gamma[None, :], 0.2))
    return pred[:, 0] if T == 1 else pred


def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, dtype=np.float64))
    y = np.asarray(loss_values, dtype=np.float64)
    Y = y[:, None] if y.ndim == 1 else y
    T = Y.shape[1]

    softplus = _softplus
    def inv_softplus(x):
        x = np.maximum(np.asarray(x, dtype=np.float64), 1e-12)
        return np.log(np.expm1(x))
    def sigmoid(z): return 1.0 / (1.0 + np.exp(-z))
    def inv_sigmoid(p):
        p = np.clip(np.asarray(p, dtype=np.float64), 1e-9, 1.0 - 1e-9)
        return np.log(p) - np.log1p(-p)

    def phuber(r, d=0.5):
        return d*d * (np.sqrt(1.0 + (r/d)**2) - 1.0)

    # Heuristic init
    y_lo = np.percentile(Y, 15, axis=0)
    y_rng = np.maximum(np.ptp(Y, axis=0), 1.0)
    A_init = 0.6 * y_rng
    aP_init, aD_init = 0.30, 0.30
    k_init, nu_init, gamma_init = 1.0, 0.85, 0.80

    theta0 = np.zeros((T, 7), dtype=np.float64)
    theta0[:, 0] = y_lo
    theta0[:, 1] = inv_softplus(A_init)
    theta0[:, 2] = inv_softplus(aP_init)
    theta0[:, 3] = inv_softplus(aD_init)
    theta0[:, 4] = inv_softplus(k_init)
    theta0[:, 5] = inv_sigmoid(nu_init)
    # Map gamma in (0.2,1.0): gamma = 0.2 + 0.8 * sigmoid(g)
    theta0[:, 6] = inv_sigmoid((gamma_init - 0.2) / 0.8)

    def unpack(theta_flat):
        tt = theta_flat.reshape(T, 7)
        L_inf = tt[:, 0]
        A     = softplus(tt[:, 1])
        a_P   = softplus(tt[:, 2])
        a_D   = softplus(tt[:, 3])
        k     = softplus(tt[:, 4])
        nu    = sigmoid(tt[:, 5])
        gamma = 0.2 + 0.8 * sigmoid(tt[:, 6])
        return np.stack([L_inf, A, a_P, a_D, k, nu, gamma], axis=1)

    var = np.var(Y, axis=0) + 1e-12
    lam = 1e-4
    w_prior = 5e-4

    def objective(theta_flat):
        params = unpack(theta_flat)
        pred = scaling_law_func(X, params)
        if T == 1:
            r = pred - Y[:, 0]
            loss = np.mean(phuber(r) / var[0])
            aP, aD, k, nu, gm = params[0, 2], params[0, 3], params[0, 4], params[0, 5], params[0, 6]
            prior = w_prior * ((aP - 0.3)**2 + (aD - 0.3)**2 + (np.log(k + 1e-12))**2 + (nu - 0.85)**2 + (gm - 0.8)**2)
        else:
            r = pred - Y
            loss = np.mean(phuber(r) / var[None, :])
            aP, aD, k, nu, gm = params[:, 2], params[:, 3], params[:, 4], params[:, 5], params[:, 6]
            prior = w_prior * np.mean((aP - 0.3)**2 + (aD - 0.3)**2 + (np.log(k + 1e-12))**2 + (nu - 0.85)**2 + (gm - 0.8)**2)
        reg = lam * np.sum(theta_flat.reshape(T, 7)[:, 1:]**2)
        return loss + reg + prior

    best = theta0.copy()
    best_val = np.full(T, np.inf)
    rng = np.random.default_rng(12345)
    starts = 6

    for t in range(T):
        base = theta0[t].copy()
        for _ in range(starts):
            init = base + rng.normal(0.0, 0.2, size=base.shape)
            res = minimize(objective, init, method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 800, &#x27;ftol&#x27;: 1e-9})
            th = res.x if res.success else init
            val = objective(th)
            if val &lt; best_val[t]:
                best_val[t] = val
                best[t] = th

    params_opt = unpack(best.ravel())
    return params_opt[0] if T == 1 else params_opt
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#3</span>
                    <span class="run-label">Run 2</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.976129
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-2"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points))
    U, Pm, D = X[:, 0], X[:, 1], X[:, 2]
    z = np.asarray(params).ravel()
    def sp(t):
        t = np.asarray(t)
        return np.where(t &gt; 0, t + np.log1p(np.exp(-t)), np.log1p(np.exp(t)))
    A, B, C = sp(z[0]), sp(z[1]), sp(z[2])
    alpha, beta = sp(z[3]), sp(z[4])
    theta = 0.3 + sp(z[5])
    c = sp(z[6])
    lam = 0.5 * (alpha + beta)
    sP, sD, sU, eps = 1e9, 1e12, 1e8, 1e-12
    p = Pm / sP + eps
    d = D / sD + eps
    u = U / sU + eps
    deff = u * np.log1p((d / (u + eps)) ** theta)
    r = deff / (p + eps)
    return c + A * np.exp(-alpha * np.log(p)) + B * np.exp(-beta * np.log(deff + eps)) + C * np.exp(-lam * np.log(r + eps))

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points))
    y = np.asarray(loss_values).ravel()
    U, Pm, D = X[:, 0], X[:, 1], X[:, 2]
    sP, sD, sU, eps = 1e9, 1e12, 1e8, 1e-12
    p = Pm / sP + eps
    d = D / sD + eps
    u = U / sU + eps

    sp = lambda t: np.where(t &gt; 0, t + np.log1p(np.exp(-t)), np.log1p(np.exp(t)))
    sp_inv = lambda t: np.log(np.expm1(max(float(t), 1e-12)))

    c0 = float(max(np.percentile(y, 5), 0.05))
    resid = np.clip(y - c0, 0.0, None)

    alpha_grid = np.array([0.22, 0.26, 0.3])
    beta_grid = np.array([0.3, 0.35, 0.4])
    theta_grid = np.array([0.8, 1.0, 1.2])

    best = None
    for a0 in alpha_grid:
        for b0 in beta_grid:
            for t0 in theta_grid:
                deff0 = u * np.log1p((d / (u + eps)) ** t0)
                r0 = deff0 / (p + eps)
                T = np.column_stack([p ** (-a0), deff0 ** (-b0), r0 ** (-(0.5 * (a0 + b0)))])
                try:
                    A0, B0, C0 = np.linalg.lstsq(T, resid, rcond=None)[0]
                except Exception:
                    m = max(np.mean(resid), 0.3)
                    A0 = B0 = C0 = m / 3.0
                A0, B0, C0 = max(A0, 1e-3), max(B0, 1e-3), max(C0, 1e-3)
                pred0 = c0 + A0 * p ** (-a0) + B0 * deff0 ** (-b0) + C0 * r0 ** (-(0.5 * (a0 + b0)))
                err = np.mean((pred0 - y) ** 2)
                if (best is None) or (err &lt; best[0]):
                    best = (err, A0, B0, C0, a0, b0, t0)

    _, A0, B0, C0, alpha0, beta0, theta0 = best
    th0 = np.array([sp_inv(A0), sp_inv(B0), sp_inv(C0),
                    sp_inv(alpha0), sp_inv(beta0), sp_inv(max(theta0 - 0.3, 1e-6)),
                    sp_inv(c0)], dtype=float)

    def huber(r, dlt):
        a = np.abs(r)
        return np.where(a &lt;= dlt, 0.5 * r * r, dlt * (a - 0.5 * dlt))
    dlt = max(0.2, 0.2 * float(np.std(y)))

    def reg(th):
        A, B, C = sp(th[0]), sp(th[1]), sp(th[2])
        a, b, t, c = sp(th[3]), sp(th[4]), 0.3 + sp(th[5]), sp(th[6])
        return (8e-5 * ((a - 0.28) ** 2 + (b - 0.35) ** 2) +
                3e-4 * (t - 1.0) ** 2 + 1e-7 * (A + B + C + c) +
                8e-7 * np.sum(th * th))

    def obj(th, delta=dlt, rw=1.0):
        pred = scaling_law_func(X, th)
        return np.mean(huber(pred - y, delta)) + rw * reg(th)

    best_th, best_val = th0, obj(th0)
    rng = np.random.RandomState(42)
    inits = [th0, th0 + rng.normal(scale=0.1, size=th0.shape), th0 + rng.normal(scale=0.25, size=th0.shape), th0 + rng.normal(scale=0.4, size=th0.shape)]
    for init in inits:
        res = minimize(lambda th: obj(th), init, method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 600})
        th = res.x if res.success else init
        val = obj(th)
        if val &lt; best_val:
            best_th, best_val = th, val

    res2 = minimize(lambda th: obj(th, delta=dlt * 0.5, rw=0.6), best_th, method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 300})
    if res2.success and obj(res2.x, delta=dlt * 0.5, rw=0.6) &lt; obj(best_th, delta=dlt * 0.5, rw=0.6):
        best_th = res2.x

    return best_th
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#4</span>
                    <span class="run-label">Run 3</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.966412
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-3"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

# Mixture-power scaling law with effective data saturation (&lt;=7 params)
# params = [L0, A, a, b, w, s, eta]  (eta optional; if absent -&gt; 1)
def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points))
    U, Pm, D = X[:, 0], X[:, 1], X[:, 2]
    eps = 1e-12
    # Fixed reference scales for numerical stability
    P0, D0, U0 = 1e9, 1e11, 1e8
    Pn = np.maximum(Pm / P0, eps)
    Dn = np.maximum(D / D0, eps)
    Un = np.maximum(U / U0, eps)

    p = np.asarray(params)
    if p.ndim == 1:
        p = p[None, :]
    npar = p.shape[1]
    L0, A, a, b, w, s = [p[:, i] for i in range(6)]
    eta = p[:, 6] if npar &gt;= 7 else np.ones_like(L0)

    # Smooth-min effective data: E ~ min(D, s*U)
    q = 3.5
    sU = np.maximum(s[None, :] * Un[:, None], eps)
    E = (np.maximum(Dn[:, None], eps) ** (-q) + sU ** (-q)) ** (-1.0 / q)

    mix = np.maximum(Pn[:, None], eps) ** (-a[None, :]) + np.maximum(w[None, :] * E, eps) ** (-b[None, :])
    pred = L0[None, :] + np.maximum(A[None, :], 0.0) * np.maximum(mix, eps) ** (np.maximum(eta[None, :], eps))
    return pred[:, 0] if pred.shape[1] == 1 else pred

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points))
    y = np.asarray(loss_values)
    Y = y[:, None] if y.ndim == 1 else y
    U, Pm, D = X[:, 0], X[:, 1], X[:, 2]
    eps = 1e-12
    P0, D0, U0 = 1e9, 1e11, 1e8
    Pn = np.maximum(Pm / P0, eps)
    Dn = np.maximum(D / D0, eps)
    Un = np.maximum(U / U0, eps)

    def huber(res, d):
        z = res / d
        return d * d * (np.sqrt(1.0 + z * z) - 1.0)

    bounds = [(0.0, 10.0),   # L0
              (0.0, 50.0),   # A
              (1e-4, 2.5),   # a
              (1e-4, 2.5),   # b
              (1e-3, 1e3),   # w
              (1e-10, 1e10), # s
              (0.25, 1.0)]   # eta

    def clipb(p):
        return np.array([np.clip(p[i], bounds[i][0], bounds[i][1]) for i in range(len(bounds))])

    def fit_one(y_col):
        d = 0.15 * (np.std(y_col) + 1e-6) + 0.05
        # Initial guesses
        L0 = max(np.min(y_col) * 0.9, 1e-6)
        ypos = np.maximum(y_col - L0, 1e-6)
        s0 = np.median(np.maximum(D, eps) / np.maximum(U, eps))
        q = 3.5
        E0 = (np.maximum(Dn, eps) ** (-q) + np.maximum(s0 * Un, eps) ** (-q)) ** (-1.0 / q)
        logP = np.log(Pn)
        logE = np.log(np.maximum(E0, eps))
        logY = np.log(ypos)
        def ols_slope(x, z):
            vx = np.var(x)
            if vx &lt; 1e-12:
                return 0.0, np.mean(z)
            m = np.cov(x, z, bias=True)[0, 1] / vx
            b = np.mean(z) - m * np.mean(x)
            return m, b
        mP, bP = ols_slope(logP, logY)
        mE, bE = ols_slope(logE, logY)
        a0 = float(np.clip(-mP, 1e-3, 1.5))
        b0 = float(np.clip(-mE, 1e-3, 1.5))
        A0 = float(np.clip(np.exp((bP + bE) * 0.5), 1e-5, 30.0))
        w0 = 1.0
        eta0 = 0.85
        base = np.array([L0, A0, a0, b0, w0, s0, eta0])

        inits = [
            base,
            base * np.array([1.0, 0.7, 0.8, 1.2, 0.5, 1.0, 0.9]),
            base * np.array([1.0, 1.4, 1.2, 0.8, 2.0, 1.5, 0.7]),
            base * np.array([1.0, 1.0, 0.6, 0.6, 1.0, 2.0, 1.0]),
            base * np.array([0.9, 0.9, 1.1, 1.1, 1.0, 0.7, 0.6]),
        ]
        rng = np.random.default_rng(123)
        for _ in range(8):
            rnd = []
            for (lo, hi) in bounds:
                if lo == 0.0:
                    val = np.exp(rng.uniform(np.log(1e-6), np.log(hi + 1e-6))) - 1e-6
                    val = np.clip(val, lo, hi)
                else:
                    val = np.exp(rng.uniform(np.log(lo), np.log(hi)))
                    val = np.clip(val, lo, hi)
                rnd.append(val)
            inits.append(np.array(rnd))

        lam = 1e-6
        def obj(p):
            p = clipb(p)
            pred = scaling_law_func(X, p)
            r = pred - y_col
            loss = np.mean(huber(r, d))
            # Gentle regularization to stabilize curvature and scale
            loss += lam * (np.log1p(p[1])**2 + np.log1p(p[4])**2 + 0.1*np.log1p(p[5])**2 + 0.5*(p[2]**2 + p[3]**2))
            return loss

        scores = []
        for init in inits:
            try:
                scores.append((obj(clipb(init)), clipb(init)))
            except Exception:
                pass
        scores.sort(key=lambda t: t[0])
        seeds = [s[1] for s in scores[:7]]

        best_p, best_f = None, np.inf
        for init in seeds:
            res = minimize(obj, init, method=&#x27;L-BFGS-B&#x27;, bounds=bounds,
                           options={&#x27;maxiter&#x27;: 600, &#x27;ftol&#x27;: 1e-12})
            if res.fun &lt; best_f and np.all(np.isfinite(res.x)):
                best_p, best_f = res.x, res.fun
        return best_p if best_p is not None else seeds[0]

    params_list = [fit_one(Y[:, t]) for t in range(Y.shape[1])]
    params_arr = np.vstack(params_list)
    return params_arr[0] if Y.shape[1] == 1 else params_arr
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#5</span>
                    <span class="run-label">Run 1</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.952393
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-4"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import least_squares

# Stable softplus and inverse (positivity reparam)
def _sp(x):
    x = np.asarray(x, dtype=float)
    return np.log1p(np.exp(-np.abs(x))) + np.maximum(x, 0.0)
def _spi(y):
    y = np.maximum(np.asarray(y, dtype=float), 1e-12)
    return np.log(np.expm1(y))

def scaling_law_func(data_points, params):
    # data_points: (N,3) -&gt; [unique_tokens, params, tokens]
    X = np.atleast_2d(np.asarray(data_points, float))
    U, P, D = X[:, 0], X[:, 1], X[:, 2]
    eps = 1e-12
    # Fixed pivots for conditioning (not data-dependent)
    lp = np.log(P/3e8 + eps)
    ld = np.log(D/3e10 + eps)
    lr = np.log((D/(U + 1.0))/5e2 + eps)

    th = np.atleast_2d(np.asarray(params, float))[:, :7]
    L0 = 1.0 + _sp(th[:, 0])
    A  = _sp(th[:, 1]); B = _sp(th[:, 2]); C = _sp(th[:, 3])
    ap = _sp(th[:, 4]) + 1e-8
    ad = _sp(th[:, 5]) + 1e-8
    ar = _sp(th[:, 6]) + 1e-8

    Ep = np.exp(-lp[:, None] * ap[None, :])
    Ed = np.exp(-ld[:, None] * ad[None, :])
    Er = np.exp(-lr[:, None] * ar[None, :])
    Y = L0[None, :] + A[None, :]*Ep + B[None, :]*Ed + C[None, :]*Er
    return Y[:, 0] if Y.shape[1] == 1 else Y

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, float))
    y = np.asarray(loss_values, float)
    Y = y[:, None] if y.ndim == 1 else y
    N, T = Y.shape

    U, P, D = X[:, 0], X[:, 1], X[:, 2]
    eps = 1e-12
    lp = np.log(P/3e8 + eps)
    ld = np.log(D/3e10 + eps)
    lr = np.log((D/(U + 1.0))/5e2 + eps)

    Th = np.zeros((T, 7), float)
    ridge = 1e-8
    grid = np.array([0.12, 0.2, 0.3, 0.45], float)
    rng = np.random.default_rng(123)

    for t in range(T):
        yt = Y[:, t]
        med = float(np.median(yt))
        mad = float(np.median(np.abs(yt - med))) * 1.4826
        scale = 0.25 * (mad if np.isfinite(mad) and mad &gt; 0 else np.std(yt, ddof=1)) + 0.1

        best = (np.inf, (1.2, 0.5, 0.5, 0.5), (0.25, 0.25, 0.25))
        one = np.ones_like(lp)
        for ap0 in grid:
            vp = np.exp(-ap0 * lp)
            for ad0 in grid:
                vd = np.exp(-ad0 * ld)
                for ar0 in grid:
                    vr = np.exp(-ar0 * lr)
                    Bm = np.stack([one, vp, vd, vr], 1)
                    M = Bm.T @ Bm + ridge * np.eye(4)
                    c = np.linalg.solve(M, Bm.T @ yt)
                    L0i, A0, B0, C0 = float(c[0]), max(c[1], 1e-8), max(c[2], 1e-8), max(c[3], 1e-8)
                    L0i = max(L0i, 1.05)
                    pred0 = L0i + A0*vp + B0*vd + C0*vr
                    cost = np.mean(((pred0 - yt) / scale) ** 2)
                    if np.isfinite(cost) and cost &lt; best[0]:
                        best = (cost, (L0i, A0, B0, C0), (ap0, ad0, ar0))

        (L0i, A0, B0, C0), (ap0, ad0, ar0) = best[1], best[2]
        base = np.array([_spi(max(L0i - 1.0, 1e-3)), _spi(A0), _spi(B0), _spi(C0),
                         _spi(ap0), _spi(ad0), _spi(ar0)], float)

        def resid(w):
            L0 = 1.0 + _sp(w[0])
            A  = _sp(w[1]); B = _sp(w[2]); C = _sp(w[3])
            ap = _sp(w[4]) + 1e-8; ad = _sp(w[5]) + 1e-8; ar = _sp(w[6]) + 1e-8
            r = (L0 + A*np.exp(-ap*lp) + B*np.exp(-ad*ld) + C*np.exp(-ar*lr) - yt) / scale
            # Mild priors and weight decay to stabilize with limited data
            reg = np.concatenate([1e-6*w, 5e-4*(np.array([ap, ad, ar]) - 0.25)])
            return np.concatenate([r, reg])

        starts = [base] + [base * np.exp(rng.normal(0.0, 0.35, 7)) for _ in range(4)]
        best_raw, best_c = base, np.inf
        for st in starts:
            res = least_squares(resid, st, loss=&#x27;soft_l1&#x27;, f_scale=1.0, method=&#x27;trf&#x27;, max_nfev=1200)
            if np.isfinite(res.cost) and res.cost &lt; best_c:
                best_c, best_raw = res.cost, res.x

        Th[t] = best_raw

    return Th[0] if T == 1 else Th
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        </div>
        
        <footer class="footer">
            <p>SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> | <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a></p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleRun(header) {
            const content = header.nextElementSibling;
            const isExpanded = content.style.display === 'block';
            content.style.display = isExpanded ? 'none' : 'block';
            header.classList.toggle('expanded', !isExpanded);
        }
        
        function copyCode(event, codeId) {
            event.stopPropagation();
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }
        
        Prism.highlightAll();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLD - SFT Scaling Law - SLDAgent + o4-mini</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --accent-primary: #2563eb;
            --accent-secondary: #3b82f6;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-subtle: rgba(0, 0, 0, 0.1);
            --glass-bg: rgba(0, 0, 0, 0.02);
            --success: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Sora', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .bg-pattern {
            display: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--accent-secondary);
        }
        
        .header {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .meta-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .meta-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .meta-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .r2-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .runs-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .run-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .run-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .run-card.best-run {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.02);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .run-header:hover {
            background: rgba(255, 255, 255, 0.04);
        }
        
        .run-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .run-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        
        .run-badge.best-badge {
            background: var(--success);
            color: white;
        }
        
        .run-label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .expand-icon {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .run-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .run-content {
            border-top: 1px solid var(--border-subtle);
        }
        
        .code-container {
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .copy-btn {
            padding: 0.35rem 0.75rem;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .copy-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }
        
        .code-container pre {
            margin: 0;
            padding: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-x: auto;
            background: transparent !important;
        }
        
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .meta-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .run-info {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <a href="sld_index.html" class="back-link">
            ← Back to Leaderboard
        </a>
        
        <div class="header">
            <h1>SFT Scaling Law</h1>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Agent:</span>
                    <span class="meta-value">SLDAgent</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Model:</span>
                    <span class="meta-value">o4-mini</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best R²:</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        0.994732
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Mean R²:</span>
                    <span class="meta-value">0.993466</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Min R²:</span>
                    <span class="meta-value">0.991570</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Runs:</span>
                    <span class="meta-value">5</span>
                </div>
            </div>
        </div>
        
        <h2 class="section-title">All Runs (sorted by R²)</h2>
        
        <div class="runs-container">
            
        <div class="run-card best-run">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge best-badge">Best</span>
                    <span class="run-label">Run 2</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.994732
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: block;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-0"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import least_squares

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Four-parameter logistic-power scaling law:
      L(D) = d + a / (1 + (D / c)**b)
    params = [a, b, c, d]
      a &gt; 0 : amplitude above floor
      b &gt; 0 : decay exponent
      c &gt; 0 : characteristic data size (knee)
      d ≥ 0 : asymptotic loss floor
    &quot;&quot;&quot;
    D = np.asarray(data_points, dtype=np.float64).ravel()
    a, b, c, d = params
    # stable power evaluation
    return d + a / (1.0 + np.power(D / c, b))

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 4-parameter logistic-power law by minimizing log‐residuals
    with a robust Cauchy loss to balance relative errors.
    Returns optimized params [a, b, c, d].
    &quot;&quot;&quot;
    D = np.asarray(data_points, dtype=np.float64).ravel()
    y = np.asarray(loss_values, dtype=np.float64).ravel()

    # Basic statistics
    y_min, y_max = y.min(), y.max()
    D_min, D_max = max(D.min(), 1e-8), D.max()

    # Initial parameter guesses
    d0 = max(0.0, 0.95 * y_min)           # floor near observed minimum
    a0 = max(1e-8, y_max - d0)            # amplitude above floor
    c0 = np.sqrt(D_min * D_max)           # knee at geometric mean
    b0 = 1.0                              # moderate decay exponent
    p0 = np.array([a0, b0, c0, d0], dtype=np.float64)

    # Bounds: a,b,c &gt; 0 ; 0 ≤ d ≤ y_min
    lower = np.array([1e-12, 1e-12, 1e-12, 0.0], dtype=np.float64)
    upper = np.array([np.inf,   np.inf,   np.inf,   y_min], dtype=np.float64)

    # small constant to avoid log(0)
    eps = 1e-8
    def residuals(p):
        pred = scaling_law_func(D, p)
        return np.log(pred + eps) - np.log(y + eps)

    # robust nonlinear least squares with Cauchy loss
    res = least_squares(
        fun=residuals,
        x0=p0,
        bounds=(lower, upper),
        loss=&#x27;cauchy&#x27;,
        f_scale=0.05,
        xtol=1e-14,
        ftol=1e-14,
        gtol=1e-14,
        max_nfev=3000
    )

    return res.x if res.success else p0
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#2</span>
                    <span class="run-label">Run 3</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.994435
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-1">import numpy as np
from scipy.optimize import least_squares

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    4-parameter Hill-type scaling law:
       L(D) = L_inf + A / (1 + (D / D0)^alpha)

    Args:
      data_points: array-like of shape (N,1) or (N,), data sizes D.
      params:      length-4 array [L_inf, A, D0, alpha]:
                     L_inf ≥ 0  : asymptotic loss floor
                     A     ≥ 0  : amplitude above floor at small D
                     D0    &gt; 0  : characteristic data scale
                     alpha &gt; 0  : decay exponent

    Returns:
      preds: array of predicted loss values, shape (N,)
    &quot;&quot;&quot;
    X = np.atleast_1d(np.squeeze(data_points)).astype(float)
    L_inf, A, D0, alpha = np.ravel(params)
    # enforce positivity for D0, alpha to avoid NaNs
    D0 = max(D0, 1e-12)
    alpha = max(alpha, 1e-12)
    return L_inf + A / (1.0 + (X / D0)**alpha)


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 4-parameter Hill-type law L(D) = L_inf + A/(1 + (D/D0)^alpha)
    by minimizing robust log-residuals:
        minimize sum rho( log(pred) - log(y) )
    where rho is the Cauchy loss to downweight outliers.

    Returns:
      params_opt: array [L_inf, A, D0, alpha]
    &quot;&quot;&quot;
    # prepare 1D float arrays
    X = np.atleast_1d(np.squeeze(data_points)).astype(float)
    y = np.atleast_1d(np.squeeze(loss_values)).astype(float)
    N = X.size

    # basic stats
    D_min, D_max = X.min(), X.max()
    y_min, y_max = y.min(), y.max()

    # sort for slope estimation in log-log
    idx = np.argsort(X)
    Xs, ys = X[idx], y[idx]
    i_low = int(0.1 * (N - 1))
    i_high = int(0.9 * (N - 1))
    D_low, D_high = Xs[i_low], Xs[i_high]
    y_low = max(ys[i_low], 1e-8)
    y_high = max(ys[i_high], 1e-8)

    # initial guesses
    L_inf0 = max(0.0, 0.8 * y_min)
    A0     = max(1e-6, y_max - L_inf0)
    # estimate alpha from two quantiles in log-log space
    num = np.log(y_low - L_inf0 + 1e-12) - np.log(y_high - L_inf0 + 1e-12)
    den = np.log(D_low + 1e-12) - np.log(D_high + 1e-12)
    alpha0 = np.clip(abs(num / (den + 1e-12)), 0.1, 10.0)
    # D0 initial ~ geometric mean
    D0_0 = np.exp(np.mean(np.log(X + 1e-12)))

    p0 = np.array([L_inf0, A0, D0_0, alpha0], dtype=float)

    # bounds for numerical stability
    lower_bounds = [0.0,           1e-8,      D_min * 1e-3, 1e-3]
    upper_bounds = [y_min * 1.2,  (y_max - y_min) * 100.0, D_max * 100.0, 20.0]

    # residual in log-space
    def residuals(p):
        pred = scaling_law_func(X, p)
        return np.log(pred + 1e-12) - np.log(y + 1e-12)

    # robust scale based on initial residuals
    init_res = residuals(p0)
    f_scale = max(np.median(np.abs(init_res)), 1e-2)

    # perform robust least-squares with Cauchy loss
    res = least_squares(
        residuals,
        p0,
        bounds=(lower_bounds, upper_bounds),
        method=&#x27;trf&#x27;,
        loss=&#x27;cauchy&#x27;,
        f_scale=f_scale,
        max_nfev=2000
    )

    return res.x if res.success else p0</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#3</span>
                    <span class="run-label">Run 5</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.993633
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-2">import numpy as np
from scipy.optimize import minimize

# EVOLVE-BLOCK-START
def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    4-param rational power law:
      L(D) = L_inf + A / (D^alpha + B)
    params = [log A, log alpha, log B, L_inf]
    &quot;&quot;&quot;
    D = np.atleast_1d(np.squeeze(data_points)).astype(float)
    p = np.ravel(params).astype(float)
    A, alpha, B, L_inf = np.exp(p[0]), np.exp(p[1]), np.exp(p[2]), p[3]
    return L_inf + A / (D**alpha + B)

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit L_inf + A/(D^alpha + B) by:
     1) initializing L_inf just below min(loss)
     2) log–log regression for A, alpha on residual y = L - L_inf
     3) setting B to 0.1 * median(D^alpha)
     4) minimizing MSE + 0.1*relative-log-MSE under bounds
    &quot;&quot;&quot;
    # flatten inputs
    D = np.atleast_1d(np.squeeze(data_points)).astype(float)
    L = np.ravel(loss_values).astype(float)

    # 1) init asymptote just below min observed loss
    L_inf0 = max(0.0, L.min() * 0.995)

    # 2) fit log–log for A &amp; alpha on positive residuals
    y = L - L_inf0
    mask = y &gt; 0
    if mask.sum() &gt;= 2:
        slope, intercept = np.polyfit(np.log(D[mask]), np.log(y[mask]), 1)
        alpha0 = max(-slope, 1e-6)
        A0 = max(np.exp(intercept), 1e-6)
    else:
        alpha0, A0 = 0.5, max(L.max() - L_inf0, 1e-3)

    # 3) init offset B so denom ~ balanced at median scale
    B0 = max(np.median(D**alpha0) * 0.1, 1e-6)

    # pack initial params
    p0 = np.array([np.log(A0), np.log(alpha0), np.log(B0), L_inf0], dtype=float)

    # bounds: keep alpha, B within reasonable log-ranges, L_inf ∈ [0, min(L)]
    bounds = [
        (None, None),   # log A
        (-5.0, 5.0),    # log alpha
        (-10.0, 10.0),  # log B
        (0.0, float(L.min()))
    ]

    # combined objective: abs-MSE + 0.1 * relative-log-MSE
    eps = 1e-8
    def objective(p):
        pred = scaling_law_func(D, p)
        mse_abs = np.mean((pred - L)**2)
        mse_rel = np.mean((np.log(pred + eps) - np.log(L + eps))**2)
        return mse_abs + 0.1 * mse_rel

    res = minimize(objective, p0, method=&#x27;L-BFGS-B&#x27;, bounds=bounds)
    return res.x if res.success else p0
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#4</span>
                    <span class="run-label">Run 1</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.992961
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-3"># EVOLVE-BLOCK-START
&quot;&quot;&quot;
4-parameter rational power-law scaling for LLM supervised fine‐tuning:

    L(D) = L_inf + A / (D^alpha + B)

Where:
  - L_inf : asymptotic loss as D→∞
  - A     : finite‐data loss coefficient
  - alpha : decay exponent
  - B     : regularization offset avoiding singularity

This form ensures monotonic decay, avoids division‐by‐zero at small D,
and yields a power‐law tail. We fit via a scaled Soft‐L1 robust loss
for stability across model‐dataset regimes.
&quot;&quot;&quot;
import numpy as np
from scipy.optimize import least_squares

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Predict cross-entropy loss from data size(s).

    Args:
      data_points: array-like of shape (N,1) or (N,) for data sizes D.
      params: sequence of 4 parameters [L_inf, A, alpha, B].
    Returns:
      preds: ndarray of length N with predicted losses.
    &quot;&quot;&quot;
    D = np.ravel(data_points).astype(float)
    L_inf, A, alpha, B = params
    # avoid zero or negative sizes
    D_safe = np.clip(D, 1.0, None)
    return L_inf + A / (np.power(D_safe, alpha) + B)

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 4-parameter rational power-law to (data_size, loss) pairs.

    Args:
      data_points: array-like of shape (N,1) or (N,) for D.
      loss_values: array-like of shape (N,) for observed losses.
    Returns:
      opt_params: ndarray of shape (4,) [L_inf, A, alpha, B].
    &quot;&quot;&quot;
    # prepare data
    D = np.ravel(data_points).astype(float)
    y = np.ravel(loss_values).astype(float)
    y_min, y_max = y.min(), y.max()
    D_min = max(D.min(), 1.0)

    # initial guess:
    #  L_inf ~ 90% of min loss,
    #  A ~ loss span,
    #  alpha ~ 1.0,
    #  B ~ minimal dataset size
    p0 = np.array([
        max(0.0, 0.9 * y_min),       # L_inf
        max(1e-6, (y_max - y_min)),   # A
        1.0,                          # alpha
        D_min                         # B
    ])

    # bounds to ensure L_inf ≤ y_min and positivity
    lower = [0.0, 0.0, 0.0, 0.0]
    upper = [y_min, np.inf, 5.0, np.inf]

    # scale residuals by loss range
    scale = (y_max - y_min) + 1e-6

    def residuals(p):
        return (scaling_law_func(D, p) - y) / scale

    # robust fitting with Trust-Region Reflective + Soft L1 loss
    result = least_squares(
        residuals,
        p0,
        bounds=(lower, upper),
        method=&#x27;trf&#x27;,
        loss=&#x27;soft_l1&#x27;,
        f_scale=0.1,
        max_nfev=3000
    )

    return result.x if result.success else p0
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#5</span>
                    <span class="run-label">Run 4</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.991570
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-4">import numpy as np
from scipy.optimize import minimize

# EVOLVE-BLOCK-START
def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    4-parameter asymptotic power law:
       loss(D) = d + a * (D + c)^(-b)
    params = [a, b, c, d]
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel().astype(float)
    a, b, c, d = params
    return d + a * (X + c) ** (-b)

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit loss(D) = d + a*(D+c)^(-b) via multi-start L-BFGS-B
    with a log-linear warm start.
    Returns optimized [a, b, c, d].
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel().astype(float)
    y = np.asarray(loss_values).ravel().astype(float)
    x_min = max(X.min(), 1e-8)
    y_min, y_max = y.min(), y.max()

    # 1) Log-linear warm start: y - d0 ~ a*(X + c0)^(-b)
    d0 = y_min - 0.05 * (y_max - y_min)
    c0 = max(1e-9, 0.1 * x_min)
    Y = np.clip(y - d0, 1e-8, None)
    slope, intercept = np.polyfit(np.log(X + c0), np.log(Y), 1)
    b0 = max(-slope, 1e-8)
    a0 = max(np.exp(intercept), 1e-8)

    # 2) Build a small pool of initial guesses
    inits = [np.array([a0, b0, c0, d0], dtype=float)]
    for bg in (0.5, 1.0, 2.0):
        for frac in (1e-3, 1e-2, 1e-1):
            cg = x_min * frac + 1e-12
            ag = max(y_max - y_min, 1e-3) * (x_min + cg) ** bg
            dg = y_min
            inits.append(np.array([ag, bg, cg, dg], dtype=float))

    # 3) Define bounds and objective
    bounds = [
        (1e-12, None),  # a &gt; 0
        (1e-12, None),  # b &gt; 0
        (1e-12, None),  # c &gt; 0
        (None, None)    # d free
    ]
    def mse(p):
        return np.mean((scaling_law_func(X, p) - y) ** 2)

    # 4) Multi-start optimization
    best_loss, best_p = np.inf, None
    for p0 in inits:
        res = minimize(
            mse, p0,
            method=&#x27;L-BFGS-B&#x27;,
            bounds=bounds,
            options={&#x27;maxiter&#x27;: 500, &#x27;ftol&#x27;: 1e-12}
        )
        if res.success and res.fun &lt; best_loss:
            best_loss, best_p = res.fun, res.x

    # 5) Fallback to warm start if none succeeded
    return best_p if best_p is not None else inits[0]
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        </div>
        
        <footer class="footer">
            <p>SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> | <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a></p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleRun(header) {
            const content = header.nextElementSibling;
            const isExpanded = content.style.display === 'block';
            content.style.display = isExpanded ? 'none' : 'block';
            header.classList.toggle('expanded', !isExpanded);
        }
        
        function copyCode(event, codeId) {
            event.stopPropagation();
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }
        
        Prism.highlightAll();
    </script>
</body>
</html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLD - MoE Scaling Law - claude-code + claude-haiku-4-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --accent-primary: #2563eb;
            --accent-secondary: #3b82f6;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-subtle: rgba(0, 0, 0, 0.1);
            --glass-bg: rgba(0, 0, 0, 0.02);
            --success: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Sora', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .bg-pattern {
            display: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--accent-secondary);
        }
        
        .header {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .meta-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .meta-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .meta-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .r2-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .runs-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .run-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .run-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .run-card.best-run {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.02);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .run-header:hover {
            background: rgba(255, 255, 255, 0.04);
        }
        
        .run-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .run-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        
        .run-badge.best-badge {
            background: var(--success);
            color: white;
        }
        
        .run-label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .expand-icon {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .run-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .run-content {
            border-top: 1px solid var(--border-subtle);
        }
        
        .code-container {
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .copy-btn {
            padding: 0.35rem 0.75rem;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .copy-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }
        
        .code-container pre {
            margin: 0;
            padding: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-x: auto;
            background: transparent !important;
        }
        
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .meta-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .run-info {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <a href="sld_index.html" class="back-link">
            ← Back to Leaderboard
        </a>
        
        <div class="header">
            <h1>MoE Scaling Law</h1>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Agent:</span>
                    <span class="meta-value">claude-code</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Model:</span>
                    <span class="meta-value">claude-haiku-4-5</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best R²:</span>
                    <span class="r2-badge" style="background-color: #DAA520; color: white;">
                        0.690013
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Mean R²:</span>
                    <span class="meta-value">0.394290</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Min R²:</span>
                    <span class="meta-value">-0.121429</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Runs:</span>
                    <span class="meta-value">5</span>
                </div>
            </div>
        </div>
        
        <h2 class="section-title">All Runs (sorted by R²)</h2>
        
        <div class="runs-container">
            
        <div class="run-card best-run">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge best-badge">Best</span>
                    <span class="run-label">Run 1</span>
                    <span class="r2-badge" style="background-color: #DAA520; color: white;">
                        R² = 0.690013
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: block;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-0">import math


def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    This function implements a power law with an interaction term discovered through analysis
    of Mixture-of-Experts (MoE) architecture scaling.

    The mathematical formula is:
        log(loss_validation) = a*log(num_experts) + b*log(dense_parameter_count)
                               + c*(log(num_experts)*log(dense_parameter_count)) + const

    Where:
        - a = -0.100962
        - b = -0.084521
        - c = 0.004064
        - const = 2.563144

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values. Expected keys: &#x27;num_experts&#x27;, &#x27;dense_parameter_count&#x27;
        group: The name of the experimental group for which to make predictions.
               The functional form of the law is the same for all groups,
               but parameters can differ per group. For this dataset, only &#x27;all_data&#x27; exists.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable &#x27;loss_validation&#x27;.
    &quot;&quot;&quot;
    # Parameters extracted from the fitted model
    # These coefficients work for all groups in this dataset (only &#x27;all_data&#x27; exists)
    params = {
        &#x27;all_data&#x27;: {
            &#x27;a&#x27;: -0.10096209505615544,
            &#x27;b&#x27;: -0.08452076489156325,
            &#x27;c&#x27;: 0.004064472374478456,
            &#x27;const&#x27;: 2.56314364064211
        }
    }

    # Use parameters for the specified group; fall back to &#x27;all_data&#x27; if group not found
    if group not in params:
        group = &#x27;all_data&#x27;

    group_params = params[group]
    a = group_params[&#x27;a&#x27;]
    b = group_params[&#x27;b&#x27;]
    c = group_params[&#x27;c&#x27;]
    const = group_params[&#x27;const&#x27;]

    # Make predictions for each input
    results = []
    for data_point in input_data:
        num_experts = data_point[&#x27;num_experts&#x27;]
        dense_parameter_count = data_point[&#x27;dense_parameter_count&#x27;]

        # Compute log-space prediction
        log_experts = math.log(num_experts)
        log_dense = math.log(dense_parameter_count)
        interaction = log_experts * log_dense

        log_loss = a * log_experts + b * log_dense + c * interaction + const

        # Convert back to linear space
        loss_validation = math.exp(log_loss)

        results.append({&#x27;loss_validation&#x27;: loss_validation})

    return results</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#2</span>
                    <span class="run-label">Run 2</span>
                    <span class="r2-badge" style="background-color: #D2691E; color: white;">
                        R² = 0.467622
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-1">def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    # Parameters fitted to the data
    # The discovered scaling law is: loss = 10^a * experts^b * dense^c
    # In log space: log10(loss) = a + b*log10(experts) + c*log10(dense)

    group_params = {
        &#x27;all_data&#x27;: {
            &#x27;intercept&#x27;: 1.002994070146366,
            &#x27;coef_experts&#x27;: -0.02740192252755339,
            &#x27;coef_dense&#x27;: -0.0705124860796179
        }
    }

    # Get parameters for the specified group
    if group not in group_params:
        # If group not found, use the &#x27;all_data&#x27; parameters as fallback
        params = group_params.get(&#x27;all_data&#x27;, group_params[list(group_params.keys())[0]])
    else:
        params = group_params[group]

    results = []
    for data_point in input_data:
        num_experts = data_point[&#x27;num_experts&#x27;]
        dense_parameter_count = data_point[&#x27;dense_parameter_count&#x27;]

        # Apply the scaling law formula in log space
        # log10(loss) = intercept + coef_experts*log10(num_experts) + coef_dense*log10(dense_parameter_count)
        import math
        log_loss = (
            params[&#x27;intercept&#x27;]
            + params[&#x27;coef_experts&#x27;] * math.log10(num_experts)
            + params[&#x27;coef_dense&#x27;] * math.log10(dense_parameter_count)
        )

        # Convert back to linear scale
        loss_prediction = 10 ** log_loss

        results.append({
            &#x27;loss_validation&#x27;: loss_prediction
        })

    return results</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#3</span>
                    <span class="run-label">Run 3</span>
                    <span class="r2-badge" style="background-color: #D2691E; color: white;">
                        R² = 0.467622
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-2">def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    The scaling law discovered is a multiplicative power law:
    loss_validation = A * num_experts^α * dense_parameter_count^β

    Where:
    - A = 10.0691792031
    - α = -0.0274019225 (exponent for num_experts)
    - β = -0.0705124861 (exponent for dense_parameter_count)

    This formula was derived from fitting a log-linear model in log-log space:
    log(loss) = log(A) + α*log(num_experts) + β*log(dense_parameter_count)

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law is the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    import math

    # Parameters fitted from the data
    # These are the same across all groups as only one group exists in the dataset
    params = {
        &#x27;all_data&#x27;: {
            &#x27;A&#x27;: 10.0691792031,
            &#x27;alpha&#x27;: -0.0274019225,
            &#x27;beta&#x27;: -0.0705124861
        }
    }

    # Use the group-specific parameters if available, otherwise use &#x27;all_data&#x27;
    if group in params:
        param_set = params[group]
    else:
        # Default to all_data parameters for unknown groups
        param_set = params[&#x27;all_data&#x27;]

    A = param_set[&#x27;A&#x27;]
    alpha = param_set[&#x27;alpha&#x27;]
    beta = param_set[&#x27;beta&#x27;]

    results = []
    for data_point in input_data:
        num_experts = data_point[&#x27;num_experts&#x27;]
        dense_param_count = data_point[&#x27;dense_parameter_count&#x27;]

        # Calculate predicted loss using the power law
        # loss = A * num_experts^alpha * dense_parameter_count^beta
        predicted_loss = A * (num_experts ** alpha) * (dense_param_count ** beta)

        results.append({&#x27;loss_validation&#x27;: predicted_loss})

    return results</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#4</span>
                    <span class="run-label">Run 4</span>
                    <span class="r2-badge" style="background-color: #D2691E; color: white;">
                        R² = 0.467621
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-3">def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    # Discovered scaling law: loss = C * num_experts^alpha * dense_parameter_count^beta
    # Where the parameters are fitted from the data

    # Group-specific parameters (currently only &#x27;all_data&#x27; group in dataset)
    # The mathematical form remains the same across groups, only coefficients change
    group_params = {
        &#x27;all_data&#x27;: {
            &#x27;C&#x27;: 10.06917920,           # Constant coefficient: 10^1.00299407
            &#x27;alpha&#x27;: -0.02740192,        # Exponent for num_experts
            &#x27;beta&#x27;: -0.07051249          # Exponent for dense_parameter_count
        }
    }

    # Use parameters for the requested group, or default to &#x27;all_data&#x27;
    params = group_params.get(group, group_params[&#x27;all_data&#x27;])
    C = params[&#x27;C&#x27;]
    alpha = params[&#x27;alpha&#x27;]
    beta = params[&#x27;beta&#x27;]

    results = []
    for data_point in input_data:
        num_experts = data_point[&#x27;num_experts&#x27;]
        dense_parameter_count = data_point[&#x27;dense_parameter_count&#x27;]

        # Apply the power law: loss = C * num_experts^alpha * dense_parameter_count^beta
        loss_validation = C * (num_experts ** alpha) * (dense_parameter_count ** beta)

        results.append({
            &#x27;loss_validation&#x27;: loss_validation
        })

    return results</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#5</span>
                    <span class="run-label">Run 5</span>
                    <span class="r2-badge" style="background-color: #B22222; color: white;">
                        R² = -0.121429
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-4">def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    import math

    # Coefficients fitted to the MoE scaling law
    # Mathematical form:
    # Loss = a + b*log10(num_experts) + c*log10(dense_parameter_count)
    #        + d*log10(num_experts)*log10(dense_parameter_count)

    # Group-specific parameters (currently only &#x27;all_data&#x27; group exists in training set)
    params = {
        &#x27;all_data&#x27;: {
            &#x27;a&#x27;: 7.02938669,
            &#x27;b&#x27;: -0.80004463,
            &#x27;c&#x27;: -0.53603608,
            &#x27;d&#x27;: 0.08089269,
        }
    }

    # Use provided group parameters, or fall back to &#x27;all_data&#x27; if group not found
    if group in params:
        coeff = params[group]
    else:
        # Use all_data as default parameters
        coeff = params[&#x27;all_data&#x27;]

    a = coeff[&#x27;a&#x27;]
    b = coeff[&#x27;b&#x27;]
    c = coeff[&#x27;c&#x27;]
    d = coeff[&#x27;d&#x27;]

    results = []

    for data_point in input_data:
        num_experts = data_point[&#x27;num_experts&#x27;]
        dense_parameter_count = data_point[&#x27;dense_parameter_count&#x27;]

        # Compute log10 values
        log10_experts = math.log10(num_experts)
        log10_params = math.log10(dense_parameter_count)

        # Apply the scaling law
        loss_validation = (
            a +
            b * log10_experts +
            c * log10_params +
            d * log10_experts * log10_params
        )

        results.append({&#x27;loss_validation&#x27;: loss_validation})

    return results</code></pre>
                </div>
            </div>
        </div>
        
        </div>
        
        <footer class="footer">
            <p>SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> | <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a></p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleRun(header) {
            const content = header.nextElementSibling;
            const isExpanded = content.style.display === 'block';
            content.style.display = isExpanded ? 'none' : 'block';
            header.classList.toggle('expanded', !isExpanded);
        }
        
        function copyCode(event, codeId) {
            event.stopPropagation();
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }
        
        Prism.highlightAll();
    </script>
</body>
</html>
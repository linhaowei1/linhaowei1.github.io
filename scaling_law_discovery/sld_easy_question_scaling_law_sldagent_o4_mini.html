<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLD - U-shaped Scaling Law - SLDAgent + o4-mini</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --accent-primary: #2563eb;
        --accent-secondary: #3b82f6;
        --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
        --text-primary: #1f2937;
        --text-secondary: #4b5563;
        --border-subtle: rgba(0, 0, 0, 0.1);
        --glass-bg: rgba(0, 0, 0, 0.02);
        --success: #10b981;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          "Sora",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
      }

      .bg-pattern {
        display: none;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--accent-primary);
        text-decoration: none;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
        transition: color 0.2s;
      }

      .back-link:hover {
        color: var(--accent-secondary);
      }

      .header {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .meta-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .meta-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .r2-badge {
        display: inline-block;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", monospace;
      }

      .section-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .runs-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .run-card {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        overflow: hidden;
        transition: border-color 0.2s;
      }

      .run-card:hover {
        border-color: rgba(99, 102, 241, 0.3);
      }

      .run-card.best-run {
        border-color: var(--success);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
      }

      .run-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        transition: background 0.2s;
      }

      .run-header:hover {
        background: rgba(255, 255, 255, 0.04);
      }

      .run-info {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .run-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-secondary);
      }

      .run-badge.best-badge {
        background: var(--success);
        color: white;
      }

      .run-label {
        font-weight: 500;
        color: var(--text-primary);
      }

      .expand-icon {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: transform 0.2s;
      }

      .run-header.expanded .expand-icon {
        transform: rotate(180deg);
      }

      .run-content {
        border-top: 1px solid var(--border-subtle);
      }

      .code-container {
        overflow: hidden;
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.25rem;
        background: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid var(--border-subtle);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .copy-btn {
        padding: 0.35rem 0.75rem;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--accent-primary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-container pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        background: transparent !important;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid var(--border-subtle);
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .footer a {
        color: var(--accent-primary);
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .meta-row {
          flex-direction: column;
          gap: 0.75rem;
        }

        .run-info {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <a href="index.html" class="back-link"> ← Back to Leaderboard </a>

      <div class="header">
        <h1>U-shaped Scaling Law</h1>
        <div class="meta-row">
          <div class="meta-item">
            <span class="meta-label">Agent:</span>
            <span class="meta-value">SLDAgent</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Model:</span>
            <span class="meta-value">o4-mini</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Best R²:</span>
            <span class="r2-badge" style="background-color: #228b22; color: white"> 0.933141 </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Mean R²:</span>
            <span class="meta-value">0.928994</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Min R²:</span>
            <span class="meta-value">0.922070</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Runs:</span>
            <span class="meta-value">5</span>
          </div>
        </div>
      </div>

      <h2 class="section-title">All Runs (sorted by R²)</h2>

      <div class="runs-container">
        <div class="run-card best-run">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge best-badge">Best</span>
              <span class="run-label">Run 2</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.933141 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: block">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-0">import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    # EVOLVE-BLOCK-START
    &quot;&quot;&quot;
    U-shaped scaling law: convex parabola + Gaussian dip + linear tilt + offset.
    params: [p0,p1,p2,p3,p4,p5]
      α = exp(p0)   &gt;0 parabola curvature
      β = -exp(p1)  &lt;0 dip amplitude
      γ = exp(p2)   &gt;0 dip width
      δ = p3        shift
      θ = p4        tilt
      ε = p5        offset
    y(x) = α*(x+δ)^2 + β*exp(-γ*(x+δ)^2) + θ*(x+δ) + ε
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel()
    p = np.asarray(params).ravel()
    α = np.exp(p[0])
    β = -np.exp(p[1])
    γ = np.exp(p[2])
    δ, θ, ε = p[3], p[4], p[5]
    Z = X + δ
    # clamp exponent to avoid overflow
    expo = -np.minimum(γ * Z*Z, 50.0)
    return α * Z*Z + β * np.exp(expo) + θ * Z + ε
    # EVOLVE-BLOCK-END

def fit_scaling_law(data_points, loss_values):
    # EVOLVE-BLOCK-START
    &quot;&quot;&quot;
    Fit U-shaped law via global Differential Evolution + local L-BFGS-B.
    &quot;&quot;&quot;
    from scipy.optimize import differential_evolution

    X = np.asarray(data_points).ravel()
    y = np.asarray(loss_values).ravel()

    def mse(p):
        pred = scaling_law_func(X, p)
        return np.mean((pred - y)**2)

    # bounds for log-params and shifts
    xmin, xmax = X.min(), X.max()
    ymin, ymax = y.min(), y.max()
    bounds = [
        (-5, 5), (-5, 5), (-5, 5),
        (xmin - xmax, xmax - xmin),
        (-(abs(ymax)+abs(ymin)), abs(ymax)+abs(ymin)),
        (ymin - abs(ymax - ymin), ymax + abs(ymax - ymin))
    ]

    # global search
    try:
        de = differential_evolution(mse, bounds, maxiter=50, popsize=10, tol=1e-3, polish=False)
        p0 = de.x
    except Exception:
        p0 = np.zeros(6)

    # local refinement
    res = minimize(mse, p0, method=&#x27;L-BFGS-B&#x27;, bounds=bounds,
                   options={&#x27;maxiter&#x27;:500, &#x27;ftol&#x27;:1e-12})
    return res.x if res.success else p0
    # EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#2</span>
              <span class="run-label">Run 3</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.931929 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-1">import numpy as np
from scipy.optimize import minimize

# EVOLVE-BLOCK-START

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    6-parameter U-shaped scaling law:
      y(x) = offset + α·(x−δ)^2 + β·exp(−γ·(x−δ)^2) + θ·(x−δ)
    with α&gt;0, β&lt;0, γ&gt;0 enforced via exponentials.
    params = [offset, log α, δ, log|β|, log γ, θ]
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel()
    p = np.asarray(params).ravel()
    offset = p[0]
    alpha  = np.exp(p[1])
    delta  = p[2]
    beta   = -np.exp(p[3])
    gamma  = np.exp(p[4]) + 1e-12
    tilt   = p[5]
    Z = X - delta
    return offset + alpha * Z**2 + beta * np.exp(-gamma * Z**2) + tilt * Z

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 6-parameter law by minimizing MSE with data-informed
    initialization plus a few restarts.
    Returns the best parameter vector of length 6.
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel()
    y = np.asarray(loss_values).ravel()

    # 1) Data-informed initial guess
    offset0 = np.median(y)
    i_peak  = np.argmax(y)                 # worst loss → center of dip
    delta0  = X[i_peak]
    beta0   = max(y[i_peak] - offset0, 1e-3)
    half_h  = offset0 + beta0 * 0.5
    left    = X[(X &lt; delta0) &amp; (y &gt; half_h)]
    right   = X[(X &gt; delta0) &amp; (y &gt; half_h)]
    x1      = left[-1]  if left.size  else X.min()
    x2      = right[0]  if right.size else X.max()
    span    = abs(x2 - x1)
    sigma0  = span/2 if span&gt;1e-8 else (X.max() - X.min())/4
    gamma0  = 1.0 / (2 * sigma0**2 + 1e-6)
    span_sq = max((X.max()-delta0)**2, (delta0-X.min())**2)
    alpha0  = beta0 / (span_sq + 1e-6)
    tilt0   = 0.5 * (y.max() - y.min()) / (X.max() - X.min() + 1e-6)

    init0 = np.array([
        offset0,
        np.log(alpha0),
        delta0,
        np.log(beta0),
        np.log(gamma0),
        tilt0
    ])
    # 2) Zero fallback
    init1 = np.zeros(6)
    # 3) A few small random restarts
    rng = np.random.RandomState(0)
    inits = [init0, init1] + [init0 + rng.randn(6)*0.1 for _ in range(3)]

    # Bound δ within the observed X range
    bounds = [
        (None, None),         # offset
        (None, None),         # log α
        (X.min(), X.max()),   # δ
        (None, None),         # log|β|
        (None, None),         # log γ
        (None, None)          # tilt
    ]

    def mse_obj(p):
        pred = scaling_law_func(X, p)
        return np.mean((pred - y)**2)

    best_p, best_loss = None, np.inf
    for init in inits:
        res = minimize(
            mse_obj, init, method=&#x27;L-BFGS-B&#x27;,
            bounds=bounds,
            options={&#x27;maxiter&#x27;: 500, &#x27;ftol&#x27;: 1e-12}
        )
        if res.success and res.fun &lt; best_loss:
            best_loss, best_p = res.fun, res.x

    return best_p if best_p is not None else init1

# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#3</span>
              <span class="run-label">Run 1</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.931495 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-2"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import differential_evolution, minimize

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    6-parameter U-shaped law:
      y(x) = a*(x - h)^2 + B / (1 + ((x - mu)/s)^2) + c

    params:
      p[0] = log(a)      (a &gt; 0)
      p[1] = h           (parabola center)
      p[2] = B           (bump amplitude, can be + or -)
      p[3] = mu          (bump center)
      p[4] = log(s)      (s &gt; 0, bump width)
      p[5] = c           (vertical offset)
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel()
    p = np.asarray(params).ravel()
    a  = np.exp(p[0])
    h  = p[1]
    B  = p[2]
    mu = p[3]
    s  = np.exp(p[4]) + 1e-12
    c  = p[5]
    z  = (X - mu) / s
    return a * (X - h)**2 + B / (1.0 + z*z) + c

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 6-parameter U-shape law by:
      1) Robust global search (Tukey&#x27;s biweight via Differential Evolution)
      2) Local robust refinement (L-BFGS-B on Tukey loss)
      3) Final MSE refinement (L-BFGS-B on MSE)
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel()
    y = np.asarray(loss_values).ravel()
    y_std = np.std(y) + 1e-12

    # Tukey&#x27;s biweight loss for robustness
    def tukey_obj(p):
        r    = scaling_law_func(X, p) - y
        c0   = 4.685 * y_std
        absr = np.abs(r)
        t    = r / c0
        rho  = np.empty_like(r)
        mask = absr &lt;= c0
        rho[mask]  = (c0**2 / 6.0) * (1.0 - (1.0 - t[mask]**2)**3)
        rho[~mask] = (c0**2 / 6.0)
        return np.mean(rho)

    # Mean-squared-error for final polishing
    def mse_obj(p):
        r = scaling_law_func(X, p) - y
        return np.mean(r*r)

    # parameter bounds based on data ranges
    xmin, xmax = X.min(), X.max()
    ymin, ymax = y.min(), y.max()
    b = 2 * y_std
    bounds = [
        (-10.0, 10.0),               # log(a)
        (xmin - 1.0, xmax + 1.0),    # h
        (ymin - b, ymax + b),        # B
        (xmin - 1.0, xmax + 1.0),    # mu
        (-10.0,  5.0),               # log(s)
        (ymin - b, ymax + b)         # c
    ]

    # 1) Global search with Tukey loss
    de_res = differential_evolution(
        tukey_obj, bounds,
        maxiter=80, popsize=20,
        tol=1e-6, polish=True
    )

    # 2) Local robust refinement
    local_robust = minimize(
        tukey_obj, de_res.x,
        method=&#x27;L-BFGS-B&#x27;, bounds=bounds,
        options={&#x27;ftol&#x27;:1e-12, &#x27;maxiter&#x27;:2000}
    )
    best_p = local_robust.x if local_robust.success else de_res.x

    # 3) Final MSE polishing
    final = minimize(
        mse_obj, best_p,
        method=&#x27;L-BFGS-B&#x27;, bounds=bounds,
        options={&#x27;ftol&#x27;:1e-12, &#x27;maxiter&#x27;:1000}
    )
    return final.x if final.success else best_p
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#4</span>
              <span class="run-label">Run 5</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.926337 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-3">import numpy as np
from scipy.optimize import minimize

# EVOLVE-BLOCK-START
def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    6-parameter U-shaped model: convex parabola + Cauchy bump
      f(x) = a*(x - mu)^2 + d*x + e + b / (1 + (|x - mu|/c)^2)
    params = [log_a, mu, b, log_c, d, e]
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel()
    p = np.asarray(params).ravel()
    a  = np.exp(p[0])
    mu = p[1]
    b  = p[2]
    c  = np.exp(p[3]) + 1e-12
    d  = p[4]
    e  = p[5]
    dx = X - mu
    # convex parabola + Cauchy-style bump
    return a * dx * dx + d * X + e + b / (1.0 + (np.abs(dx) / c)**2)

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 6-parameter Cauchy-bump U-shaped model:
      1) Quadratic baseline (a, d, e) via least squares on [X^2, X, 1]
      2) Bump center mu &amp; amplitude b from largest positive residual
      3) Bump width c from IQR of X
      4) Multi-start L-BFGS-B to refine all parameters
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel()
    y = np.asarray(loss_values).ravel()

    # 1) Quadratic baseline init: y ≈ a*X^2 + d*X + e
    A = np.vstack([X**2, X, np.ones_like(X)]).T
    coef, *_ = np.linalg.lstsq(A, y, rcond=None)
    a0 = max(coef[0], 1e-8)
    d0 = coef[1]
    e0 = coef[2]

    # 2) Residuals for bump init
    baseline = a0 * X**2 + d0 * X + e0
    resid    = y - baseline
    idx      = np.argmax(resid)
    mu0      = X[idx]
    b0       = resid[idx]

    # 3) Width init via interquartile range
    iqr = np.percentile(X, 75) - np.percentile(X, 25)
    c0  = max(iqr, 1e-6)

    # Pack into params: [log_a, mu, b, log_c, d, e]
    p0 = np.array([np.log(a0), mu0, b0, np.log(c0), d0, e0])

    # Parameter bounds
    bounds = [
        (-20, 20),             # log_a
        (X.min(), X.max()),    # mu
        (None, None),          # b
        (-20, 20),             # log_c
        (None, None),          # d
        (None, None)           # e
    ]

    # Objective: mean squared error
    def mse(p):
        return np.mean((scaling_law_func(X, p) - y)**2)

    # 4) Multi-start L-BFGS-B refinement
    best_p   = p0.copy()
    best_val = mse(best_p)
    # one baseline start + several small perturbations
    for init in [p0] + [p0 + np.random.randn(6) * 0.1 for _ in range(6)]:
        res = minimize(mse, init, method=&#x27;L-BFGS-B&#x27;,
                       bounds=bounds,
                       options={&#x27;maxiter&#x27;: 1000, &#x27;ftol&#x27;: 1e-9})
        if res.success and res.fun &lt; best_val:
            best_val, best_p = res.fun, res.x

    return best_p
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#5</span>
              <span class="run-label">Run 4</span>
              <span class="r2-badge" style="background-color: #228b22; color: white"> R² = 0.922070 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-4"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import least_squares

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    6-parameter U-shaped law: quadratic baseline + skewed Gaussian dip/hump.
    y(x) = C + A*(x - M)^2 + B*(x - μ)*exp(-0.5*((x - μ)/σ)^2)
    params = [C, logA, M, B, μ, logσ]
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel()
    C, logA, M, B, mu, logS = params
    A = np.exp(logA)
    S = np.exp(logS) + 1e-8
    # Quadratic baseline plus skewed Gaussian term for U-shape flexibility
    return C + A * (X - M)**2 + B * (X - mu) * np.exp(-0.5 * ((X - mu) / S)**2)

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 6-parameter U-shaped law via robust least-squares with multiple starts.
    Uses a soft-L1 loss (pseudo-Huber) for outlier resilience.
    &quot;&quot;&quot;
    X = np.asarray(data_points).ravel()
    y = np.asarray(loss_values).ravel()
    # Basic statistics for initialization and bounds
    XR = max(X.max() - X.min(), 1e-6)
    yr = max(y.max() - y.min(), 1e-6)
    C0     = np.median(y)
    logA0  = np.log(yr / (XR**2 + 1e-6) + 1e-6)
    M0     = X[np.argmax(y)]
    B0     = 0.0
    mu0    = X.mean()
    logS0  = np.log(XR / 4 + 1e-6)
    p0     = np.array([C0, logA0, M0, B0, mu0, logS0], dtype=float)

    # Parameter bounds
    lower = [y.min(),   -20, X.min() - XR, -2*yr, X.min() - XR, -10]
    upper = [y.max(),    20, X.max() + XR,  2*yr, X.max() + XR,  10]
    bounds = (lower, upper)

    # Residual function for least_squares
    def residuals(p):
        return scaling_law_func(X, p) - y

    # Multi-start to avoid local minima
    best_p, best_cost = p0, np.inf
    rng = np.random.default_rng(42)
    # try the base init plus a few noisy restarts
    for noise in np.vstack([np.zeros(6), rng.normal(scale=0.1, size=(4, 6))]):
        p_init = p0 + noise
        try:
            res = least_squares(
                residuals,
                p_init,
                bounds=bounds,
                loss=&#x27;soft_l1&#x27;,
                f_scale=yr * 0.5,
                max_nfev=1000
            )
            if res.success and res.cost &lt; best_cost:
                best_cost, best_p = res.cost, res.x
        except Exception:
            pass

    return best_p
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> |
          <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a>
        </p>
      </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      function toggleRun(header) {
        const content = header.nextElementSibling;
        const isExpanded = content.style.display === "block";
        content.style.display = isExpanded ? "none" : "block";
        header.classList.toggle("expanded", !isExpanded);
      }

      function copyCode(event, codeId) {
        event.stopPropagation();
        const code = document.getElementById(codeId).textContent;
        navigator.clipboard.writeText(code).then(() => {
          const btn = event.target;
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 2000);
        });
      }

      Prism.highlightAll();
    </script>
  </body>
</html>

<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLD - SFT Scaling Law - SLDAgent + GPT-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --accent-primary: #2563eb;
        --accent-secondary: #3b82f6;
        --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
        --text-primary: #1f2937;
        --text-secondary: #4b5563;
        --border-subtle: rgba(0, 0, 0, 0.1);
        --glass-bg: rgba(0, 0, 0, 0.02);
        --success: #10b981;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          "Sora",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
      }

      .bg-pattern {
        display: none;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--accent-primary);
        text-decoration: none;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
        transition: color 0.2s;
      }

      .back-link:hover {
        color: var(--accent-secondary);
      }

      .header {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .meta-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .meta-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .r2-badge {
        display: inline-block;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", monospace;
      }

      .section-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .runs-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .run-card {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        overflow: hidden;
        transition: border-color 0.2s;
      }

      .run-card:hover {
        border-color: rgba(99, 102, 241, 0.3);
      }

      .run-card.best-run {
        border-color: var(--success);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
      }

      .run-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        transition: background 0.2s;
      }

      .run-header:hover {
        background: rgba(255, 255, 255, 0.04);
      }

      .run-info {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .run-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-secondary);
      }

      .run-badge.best-badge {
        background: var(--success);
        color: white;
      }

      .run-label {
        font-weight: 500;
        color: var(--text-primary);
      }

      .expand-icon {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: transform 0.2s;
      }

      .run-header.expanded .expand-icon {
        transform: rotate(180deg);
      }

      .run-content {
        border-top: 1px solid var(--border-subtle);
      }

      .code-container {
        overflow: hidden;
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.25rem;
        background: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid var(--border-subtle);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .copy-btn {
        padding: 0.35rem 0.75rem;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--accent-primary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-container pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        background: transparent !important;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid var(--border-subtle);
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .footer a {
        color: var(--accent-primary);
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .meta-row {
          flex-direction: column;
          gap: 0.75rem;
        }

        .run-info {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <a href="sld_index.html" class="back-link"> ← Back to Leaderboard </a>

      <div class="header">
        <h1>SFT Scaling Law</h1>
        <div class="meta-row">
          <div class="meta-item">
            <span class="meta-label">Agent:</span>
            <span class="meta-value">SLDAgent</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Model:</span>
            <span class="meta-value">GPT-5</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Best R²:</span>
            <span class="r2-badge" style="background-color: #006400; color: white"> 0.995030 </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Mean R²:</span>
            <span class="meta-value">0.993132</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Min R²:</span>
            <span class="meta-value">0.991851</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Runs:</span>
            <span class="meta-value">5</span>
          </div>
        </div>
      </div>

      <h2 class="section-title">All Runs (sorted by R²)</h2>

      <div class="runs-container">
        <div class="run-card best-run">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge best-badge">Best</span>
              <span class="run-label">Run 4</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.995030 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: block">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-0"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import least_squares, minimize

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points, float)); n = X[:, 0]
    p = np.asarray(params, float); 
    if p.ndim == 1: p = p[None, :]
    T, P = p.shape
    if P == 4:
        L_inf, A, n0, alpha = p[:, 0], p[:, 1], np.maximum(p[:, 2], 1e-12), p[:, 3]
        ratio = np.maximum(n[:, None] / n0[None, :], 1e-300)
        z = np.exp(np.clip(np.log(ratio) * alpha[None, :], -700, 700))
        pred = L_inf[None, :] + A[None, :] / (1.0 + z)
    elif P == 3:
        L_inf, A, alpha = p[:, 0], p[:, 1], p[:, 2]
        z = np.exp(np.clip(-np.log(np.maximum(n[:, None], 1e-300)) * alpha[None, :], -700, 700))
        pred = L_inf[None, :] + A[None, :] * z
    else:
        raise ValueError(&quot;params must have length 3 or 4&quot;)
    return pred[:, 0] if pred.shape[1] == 1 else pred

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points, float)); n = X[:, 0]
    y = np.asarray(loss_values, float); Y = y[:, None] if y.ndim == 1 else y
    N, T = Y.shape
    logn = np.log(np.maximum(n, 1e-300))
    nmin, nmax = float(np.min(n)), float(np.max(n))
    gm = float(np.exp(np.mean(np.log(np.maximum(n, 1.0)))))

    lb = np.array([0.1, np.log(1e-8), np.log(10.0), np.log(0.05)])
    ub = np.array([10.0, np.log(10.0), np.log(1e7), np.log(2.5)])

    lam = 0.02
    idx = np.argsort(n); logn_s = logn[idx]

    params_all = np.zeros((T, 4), float)

    for t in range(T):
        yt = Y[:, t]
        ymin, ymax = float(np.min(yt)), float(np.max(yt))
        Linf0 = np.clip(ymin - 0.05, lb[0], ub[0])
        A0 = np.clip(max(0.1, ymax - Linf0), np.exp(lb[1]), np.exp(ub[1]))

        u = (yt - Linf0) / max(A0, 1e-8)
        u = np.clip(u, 1e-4, 1.0 - 1e-4)
        zlin = np.log(u) - np.log1p(-u)
        w = (n / nmax) ** 0.4
        wls = np.sqrt(np.maximum(w, 1e-3))
        Xlin = np.vstack([logn, np.ones_like(logn)]).T
        alpha0, n00 = 0.6, gm
        try:
            Xw = Xlin * wls[:, None]; zw = zlin * wls
            slope, intercept = np.linalg.lstsq(Xw, zw, rcond=None)[0]
            slope, intercept = float(slope), float(intercept)
            alpha0 = float(np.clip(-slope if np.isfinite(slope) else 0.6, np.exp(lb[3]), np.exp(ub[3])))
            n00 = float(np.clip(np.exp(intercept / max(alpha0, 1e-6)) if np.isfinite(intercept) else gm,
                                np.exp(lb[2]), np.exp(ub[2])))
        except Exception:
            pass

        ymid = Linf0 + 0.5 * A0
        n0_mid = float(np.clip(n[int(np.argmin(np.abs(yt - ymid)))], 10.0, 1e7))

        seeds = [
            np.array([Linf0, np.log(A0), np.log(n00), np.log(alpha0)]),
            np.array([Linf0, np.log(A0), np.log(n0_mid), np.log(max(alpha0 * 0.8, 0.1))]),
            np.array([Linf0, np.log(A0), np.log(gm), np.log(0.5)]),
            np.array([min(9.9, Linf0 + 0.15), np.log(min(1.2 * A0, 10.0)), np.log(max(nmax / 3.0, 10.0)), np.log(1.1)]),
            np.array([max(0.1, Linf0 - 0.15), np.log(max(0.7 * A0, 0.1)), np.log(max(nmin, 10.0)), np.log(0.3)]),
        ]

        def resid_z(theta_z):
            Lf, a, b, c = np.clip(theta_z, lb, ub)
            A = np.exp(a); alpha = np.exp(c); ln0 = b
            r = np.exp(np.clip(alpha * (logn - ln0), -700, 700))
            pred = Lf + A / (1.0 + r)
            main = wls * (pred - yt)
            r2 = np.exp(np.clip(alpha * (logn_s - ln0), -700, 700))
            pred_s = Lf + A / (1.0 + r2)
            pen = lam * np.maximum(pred_s[1:] - pred_s[:-1], 0.0)
            return np.concatenate([main, pen])

        best_cost, best_z = np.inf, np.clip(seeds[0], lb, ub)
        for x0 in seeds:
            try:
                res = least_squares(resid_z, np.clip(x0, lb, ub),
                                    bounds=(lb, ub), loss=&#x27;soft_l1&#x27;, f_scale=0.5, max_nfev=1500)
                if res.cost &lt; best_cost and np.all(np.isfinite(res.x)):
                    best_cost, best_z = res.cost, res.x
            except Exception:
                continue

        if not np.isfinite(best_cost) or best_cost &gt; 1e3:
            lb3 = np.array([0.1, np.log(1e-8), np.log(1e-4)])
            ub3 = np.array([10.0, np.log(10.0), np.log(3.0)])
            def resid3(th):
                Lf, a, c = th
                A = np.exp(a); alpha = np.exp(c)
                e = np.exp(np.clip(-alpha * logn, -700, 700))
                return (Lf + A * e) - yt
            x03 = np.clip(np.array([Linf0, np.log(A0), np.log(alpha0)]), lb3, ub3)
            try:
                r3 = least_squares(resid3, x03, bounds=(lb3, ub3), loss=&#x27;soft_l1&#x27;, f_scale=0.5, max_nfev=800)
                seed_ref = np.array([r3.x[0], r3.x[1], np.log(gm), np.clip(r3.x[2], lb[3], ub[3])])
                res = least_squares(resid_z, np.clip(seed_ref, lb, ub),
                                    bounds=(lb, ub), loss=&#x27;soft_l1&#x27;, f_scale=0.5, max_nfev=1200)
                if np.all(np.isfinite(res.x)):
                    best_z = res.x
            except Exception:
                pass

        def mse_obj(z):
            zc = np.clip(z, lb, ub)
            r = resid_z(zc)
            return float(np.mean(r * r))

        try:
            res2 = minimize(mse_obj, best_z, method=&#x27;L-BFGS-B&#x27;, bounds=list(zip(lb, ub)))
            if res2.success and np.isfinite(res2.fun):
                best_z = res2.x
        except Exception:
            pass

        L_inf = best_z[0]; A = float(np.exp(best_z[1])); n0 = float(np.exp(best_z[2])); alpha = float(np.exp(best_z[3]))
        params_all[t, :] = np.array([L_inf, A, n0, alpha])

    return params_all[0] if T == 1 else params_all
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#2</span>
              <span class="run-label">Run 3</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.994167 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-1"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def _ensure_2d(a):
    a = np.asarray(a)
    return a if a.ndim == 2 else a.reshape(-1, 1)

def scaling_law_func(data_points, params):
    # L + B / (1 + (x/s)^a) with stable exponentiation
    X = _ensure_2d(data_points)
    x = X[:, 0][:, None].astype(float)
    p = np.asarray(params, dtype=float)
    if p.ndim == 1:
        p = p[None, :]
    T, P = p.shape
    L = p[:, 0][None, :]
    B = (p[:, 1][None, :] if P &gt; 1 else np.ones((1, T)))
    a = (p[:, 2][None, :] if P &gt; 2 else np.full((1, T), 0.5))
    s = (p[:, 3][None, :] if P &gt; 3 else np.ones((1, T)))
    B = np.maximum(B, 1e-12)
    a = np.maximum(a, 1e-12)
    s = np.maximum(s, 1e-12)
    u = np.log(np.maximum(x, 1e-12)) - np.log(s)
    z = np.exp(np.clip(a * u, -60.0, 60.0))
    g = 1.0 / (1.0 + z)
    pred = L + B * g
    return pred[:, 0] if pred.shape[1] == 1 else pred

def fit_scaling_law(data_points, loss_values):
    X = _ensure_2d(data_points)
    y = np.asarray(loss_values, dtype=float)
    Y = y[:, None] if y.ndim == 1 else y
    x = X[:, 0].astype(float)
    xmin, xmax = float(np.min(x)), float(np.max(x))

    def init_params(xv, yv):
        ymin, ymax = float(np.min(yv)), float(np.max(yv))
        rng = max(ymax - ymin, 1e-8)
        best = (np.inf, None)
        xs = np.log(np.maximum(xv, 1.0))
        for f in (0.0, 0.05, 0.15):
            L0 = float(np.clip(ymin - f * rng, ymin - 1.0, ymin - 1e-3))
            z = np.log(np.maximum(yv - L0, 1e-12))
            xm, zm = xs.mean(), z.mean()
            den = np.sum((xs - xm) ** 2) + 1e-12
            m = np.sum((xs - xm) * (z - zm)) / den
            b = zm - m * xm
            a0 = max(-m, 1e-6)
            A0 = float(np.exp(b))
            B0 = max(ymax - L0, 1e-6)
            s0 = float(np.clip((A0 / B0) ** (1.0 / a0), xmin, xmax))
            for sf in (0.5, 1.0, 2.0):
                p0 = np.array([L0, B0, a0, np.clip(s0 * sf, xmin, xmax)], dtype=float)
                mse = np.mean((scaling_law_func(xv.reshape(-1, 1), p0) - yv) ** 2)
                if mse &lt; best[0]:
                    best = (mse, p0)
        return best[1]

    def fit_one(yv):
        p0 = init_params(x, yv)
        th0 = np.array([
            p0[0],
            np.log(max(p0[1], 1e-12)),
            np.log(max(p0[2], 1e-12)),
            np.log(max(p0[3], 1e-12))
        ], dtype=float)
        rng = float(np.max(yv) - np.min(yv))
        d1 = max(0.1 * rng, 1e-3)
        d2 = 0.25  # relative residual scale
        w1, w2 = 0.5, 0.5
        epsD = 1e-6

        def obj_grad(th):
            L, lb, la, ls = th
            B = np.exp(lb); a = np.exp(la); s = np.exp(ls)
            B = max(B, 1e-12); a = max(a, 1e-12); s = max(s, 1e-12)
            u = np.log(np.maximum(x, 1e-12)) - ls
            au = np.clip(a * u, -60.0, 60.0)
            z = np.exp(au)
            g = 1.0 / (1.0 + z)
            G = B * g
            pred = L + G
            r = pred - yv
            # pseudo-Huber on absolute residual
            q1 = np.sqrt(1.0 + (r / d1) ** 2)
            loss1 = d1 * d1 * (np.mean(q1 - 1.0))
            coeff1 = r / q1
            # relative residual wrt (y - L), with clipping for stability
            D = np.maximum(yv - L, epsD)
            rr = r / D
            q2 = np.sqrt(1.0 + (rr / d2) ** 2)
            loss2 = d2 * d2 * (np.mean(q2 - 1.0))
            coeff2 = (rr / q2)
            # derivatives
            dg_dlb = g * B  # via dB/dlb
            dg_dla = -B * a * g * g * z * u
            dg_dls =  B * a * g * g * z
            dr_dL  = 1.0
            dr_dlb = dg_dlb
            dr_dla = dg_dla
            dr_dls = dg_dls
            # grad absolute
            grad_L  = np.mean(coeff1 * dr_dL)
            grad_lb = np.mean(coeff1 * dr_dlb)
            grad_la = np.mean(coeff1 * dr_dla)
            grad_ls = np.mean(coeff1 * dr_dls)
            # grad relative
            drr_dL  = G / (D * D)
            drr_dlb = dr_dlb / D
            drr_dla = dr_dla / D
            drr_dls = dr_dls / D
            grad_L  = w1 * grad_L  + w2 * np.mean(coeff2 * drr_dL)
            grad_lb = w1 * grad_lb + w2 * np.mean(coeff2 * drr_dlb)
            grad_la = w1 * grad_la + w2 * np.mean(coeff2 * drr_dla)
            grad_ls = w1 * grad_ls + w2 * np.mean(coeff2 * drr_dls)
            # regularization on transformed params to prevent extremes
            reg = 1e-8 * (lb * lb + la * la + ls * ls)
            grad_lb += 2e-8 * lb
            grad_la += 2e-8 * la
            grad_ls += 2e-8 * ls
            loss = w1 * loss1 + w2 * loss2 + reg
            return loss, np.array([grad_L, grad_lb, grad_la, grad_ls], dtype=float)

        def run_opt(th_start):
            res = minimize(lambda th: obj_grad(th)[0], th_start, method=&quot;L-BFGS-B&quot;,
                           jac=lambda th: obj_grad(th)[1])
            return res.x if res.success else th_start

        # multi-start around s and a for robustness
        starts = [th0,
                  th0 + np.array([0.0, 0.0, np.log(1.2), 0.0]),
                  th0 + np.array([0.0, 0.0, np.log(0.8), 0.0]),
                  th0 + np.array([0.0, 0.0, 0.0,  np.log(1.5)]),
                  th0 + np.array([0.0, 0.0, 0.0,  np.log(0.67)])]
        best = (np.inf, None)
        for st in starts:
            th = run_opt(st)
            val = obj_grad(th)[0]
            if val &lt; best[0]:
                best = (val, th)
        th = best[1]
        return np.array([th[0], float(np.exp(th[1])), float(np.exp(th[2])), float(np.exp(th[3]))], dtype=float)

    out = np.vstack([fit_one(Y[:, t]) for t in range(Y.shape[1])])
    return out[0] if Y.shape[1] == 1 else out
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#3</span>
              <span class="run-label">Run 1</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.992402 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-2"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    X = np.atleast_2d(np.asarray(data_points)); s = X[:,0].astype(float)
    p = np.asarray(params); 
    if p.ndim == 1: p = p[None,:]
    T, P = p.shape
    L = p[:,0]
    A = p[:,1] if P&gt;1 else np.ones(T)
    a = p[:,2] if P&gt;2 else 0.5*np.ones(T)
    C = p[:,3] if P&gt;3 else np.ones(T)
    s0 = 1024.0
    sn = np.maximum(s[:,None]/s0, 1e-12)
    lg = np.log(sn)
    powt = np.exp(np.clip(a[None,:],1e-9,10.0)*(lg - np.log(np.maximum(C[None,:],1e-12))))
    y = L[None,:] + A[None,:]/(1.0 + powt)
    return y[:,0] if y.shape[1]==1 else y

def fit_scaling_law(data_points, loss_values):
    s = np.atleast_2d(np.asarray(data_points))[:,0].astype(float)
    y = np.asarray(loss_values).astype(float)
    Y = y[:,None] if y.ndim==1 else y
    T = Y.shape[1]
    s0 = 1024.0
    sn = np.maximum(s/s0, 1e-12)
    lg = np.log(sn)

    def phuber(r,d): return d*d*(np.sqrt(1.0 + (r/d)**2) - 1.0)

    def init_one(yt):
        a_grid = np.array([0.1,0.2,0.3,0.5,0.8,1.0,1.3,1.6])
        C_grid = np.array([0.25,0.5,1.0,2.0,4.0,8.0,16.0,32.0,64.0,128.0,256.0])
        best = None
        for a in a_grid:
            for C in C_grid:
                f = 1.0/(1.0 + np.exp(a*(lg - np.log(C))))
                D = np.stack([np.ones_like(f), f], 1)
                try:
                    sol,_,_,_ = np.linalg.lstsq(D, yt, rcond=None)
                    L0,A0 = float(sol[0]), float(sol[1])
                except Exception:
                    L0,A0 = max(yt.min(),0.0), 1.0
                pred = L0 + A0*f
                sse = np.mean((pred - yt)**2)
                if (best is None) or (sse &lt; best[0]): best = (sse,L0,A0,a,C)
        return np.array([best[1],best[2],best[3],best[4]], float)

    def fit_one(yt):
        p0 = init_one(yt)
        r0 = scaling_law_func(s[:,None], p0) - yt
        mad = np.median(np.abs(r0 - np.median(r0))) if r0.size else 0.0
        d = float(np.clip(1.4826*mad, 0.1, 0.5))
        bnds = ((0.0,10.0),(1e-9,10.0),(1e-3,3.0),(1e-6,1e6))
        def obj(p):
            yhat = scaling_law_func(s[:,None], p)
            r = yhat - yt
            l1 = np.mean(phuber(r,d))
            gt = np.maximum(yt - p[0], 1e-8)
            gp = np.maximum(yhat - p[0], 1e-8)
            l2 = np.mean((np.log(gt)-np.log(gp))**2)
            dy = np.diff(yhat)
            mono = np.mean(np.square(np.maximum(dy,0.0))) if dy.size else 0.0
            return l1 + 0.1*l2 + 1e-4*mono + 1e-8*np.sum(p*p)
        starts = [
            p0,
            np.array([p0[0],p0[1],p0[2]*0.8,p0[3]],float),
            np.array([p0[0],p0[1],p0[2]*1.2,max(p0[3]*0.5,1e-6)],float),
            np.array([p0[0],p0[1],p0[2],p0[3]*2.0+1e-6],float),
        ]
        best = None
        for st in starts:
            res = minimize(obj, st, method=&#x27;L-BFGS-B&#x27;, bounds=bnds, options={&#x27;maxiter&#x27;:300})
            cand = res.x if res.success else st
            val = obj(cand)
            if (best is None) or (val &lt; best[0]): best = (val,cand)
        return best[1]

    P = np.vstack([fit_one(Y[:,t]) for t in range(T)])
    return P[0] if T==1 else P
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#4</span>
              <span class="run-label">Run 2</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.992212 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-3"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

_NS = 1000.0  # normalization for data_size

def scaling_law_func(data_points, params):
    # L(N) = L_inf + A / (1 + (k * (N/_NS))^alpha)
    X = np.atleast_2d(np.asarray(data_points))
    n = X[:, 0] / _NS
    p = np.asarray(params)
    if p.ndim == 1: p = p[None, :]
    T, P = p.shape
    L, A, alpha = p[:, 0], p[:, 1], p[:, 2]
    k = p[:, 3] if P &gt; 3 else np.ones(T)
    k = np.maximum(k, 0.0)
    base = np.maximum(k[None, :] * n[:, None], 1e-12)
    t = np.exp(alpha[None, :] * np.log(base))
    phi = 1.0 / (1.0 + t)
    pred = L[None, :] + A[None, :] * phi
    return pred[:, 0] if pred.shape[1] == 1 else pred

def fit_scaling_law(data_points, loss_values):
    X = np.atleast_2d(np.asarray(data_points))
    y = np.asarray(loss_values)
    n = X[:, 0] / _NS
    Y = y[:, None] if y.ndim == 1 else y
    N, T = Y.shape

    bounds = [(0.5, 6.0), (1e-6, 20.0), (0.01, 2.5), (1e-6, 10.0)]
    lam, eps = 0.20, 1e-8
    results = []

    def ls_LA(phi, yt):
        Xd = np.vstack((np.ones_like(phi), phi)).T
        XtX = Xd.T @ Xd
        XtY = Xd.T @ yt
        XtX[0, 0] += 1e-12
        XtX[1, 1] += 1e-12
        sol = np.linalg.solve(XtX, XtY)
        return float(sol[0]), float(sol[1])

    for t_idx in range(T):
        yt = Y[:, t_idx]
        order = np.argsort(n)
        ns, ys = n[order], yt[order]
        tail = max(3, int(0.25 * N))
        tail_mean = float(np.mean(ys[-tail:]))

        # L_inf candidates near empirical floor
        Lc = [np.clip(np.min(yt) - 0.05, bounds[0][0], bounds[0][1]),
              np.clip(tail_mean - 0.02, bounds[0][0], bounds[0][1]),
              np.clip(tail_mean - 0.15, bounds[0][0], bounds[0][1])]

        # k grid from inverse quantiles plus log-spaced coverage
        qs = np.clip(np.percentile(n, [10, 30, 50, 70, 90]), 1e-6, None)
        k_grid = np.unique(np.clip(1.0 / qs, bounds[3][0], bounds[3][1]))
        k_grid = np.concatenate((k_grid, np.exp(np.linspace(np.log(1e-3), np.log(8.0), 6))))
        k_grid = np.clip(k_grid, bounds[3][0], bounds[3][1])

        # alpha candidates from heuristics and slope estimates
        alpha_set = {0.05, 0.12, 0.25, 0.5, 0.8, 1.2}
        for L0 in Lc:
            resid = np.maximum(yt - L0, eps)
            xb = np.log(np.maximum(n, eps))
            tb = np.log(resid)
            xm, tm = xb.mean(), tb.mean()
            varx = np.sum((xb - xm) ** 2)
            if varx &gt; 1e-16:
                m = np.sum((xb - xm) * (tb - tm)) / varx
                alpha_set.add(float(np.clip(-m, bounds[2][0], bounds[2][1])))
        alphas = np.array(sorted(alpha_set), dtype=float)

        # Multi-start: grid over (alpha, k), solve L and A by least squares
        best_p0, best_err = None, np.inf
        for a0 in alphas:
            for k0 in k_grid:
                base = np.maximum(k0 * n, 1e-12)
                tpow = np.exp(a0 * np.log(base))
                phi = 1.0 / (1.0 + tpow)
                L0, A0 = ls_LA(phi, yt)
                L0 = float(np.clip(L0, bounds[0][0], bounds[0][1]))
                A0 = float(np.clip(A0, bounds[1][0], bounds[1][1]))
                p0 = np.array([L0, A0, a0, k0], dtype=float)
                err = np.mean((scaling_law_func(X, p0) - yt) ** 2)
                if err &lt; best_err:
                    best_err, best_p0 = err, p0

        # Objective: MSE + lam * log-MSE with analytic gradients
        def obj_grad(p):
            L0, A0, a0, k0 = p
            base = np.maximum(k0 * n, 1e-12)
            s = np.log(base)
            tpow = np.exp(a0 * s)
            phi = 1.0 / (1.0 + tpow)
            pred = L0 + A0 * phi
            e = pred - yt

            dL = np.ones_like(n)
            dA = phi
            dphi_da = -(tpow * s) / (1.0 + tpow) ** 2
            dphi_dk = -(a0 * tpow / np.maximum(k0, 1e-12)) / (1.0 + tpow) ** 2
            da = A0 * dphi_da
            dk = A0 * dphi_dk

            f1 = np.mean(e * e)
            g1 = np.array([
                2.0 * np.mean(e * dL),
                2.0 * np.mean(e * dA),
                2.0 * np.mean(e * da),
                2.0 * np.mean(e * dk)
            ], dtype=float)

            pred_s = np.maximum(pred, 1e-6)
            lp = np.log(pred_s)
            ly = np.log(np.maximum(yt, 1e-6))
            r = lp - ly
            dlp = np.vstack((dL, dA, da, dk)) / pred_s
            f2 = np.mean(r * r)
            g2 = 2.0 * np.mean(r[None, :] * dlp, axis=1)

            return f1 + lam * f2, g1 + lam * g2

        res = minimize(lambda p: obj_grad(p)[0], best_p0, method=&#x27;L-BFGS-B&#x27;,
                       jac=lambda p: obj_grad(p)[1], bounds=bounds,
                       options={&#x27;maxiter&#x27;: 700, &#x27;ftol&#x27;: 1e-12, &#x27;gtol&#x27;: 1e-8})
        p_opt = res.x if res.success else best_p0

        # Final linear refit of L and A given optimized (alpha,k)
        base = np.maximum(p_opt[3] * n, 1e-12)
        tpow = np.exp(p_opt[2] * np.log(base))
        phi = 1.0 / (1.0 + tpow)
        Lf, Af = ls_LA(phi, yt)
        p_opt[0] = float(np.clip(Lf, bounds[0][0], bounds[0][1]))
        p_opt[1] = float(np.clip(Af, bounds[1][0], bounds[1][1]))

        results.append(p_opt)

    params_opt = np.vstack(results)
    return params_opt[0] if T == 1 else params_opt
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>

        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#5</span>
              <span class="run-label">Run 5</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.991851 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-4"># EVOLVE-BLOCK-START
import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    x = np.asarray(data_points, dtype=float).reshape(-1)
    p = np.asarray(params, dtype=float)

    def pred_single(pi):
        L = pi[0]
        A = np.exp(pi[1]) if pi.size &gt; 1 else 0.0
        Nc = np.exp(pi[2]) if pi.size &gt; 2 else 1.0
        beta = np.exp(pi[3]) if pi.size &gt; 3 else 1.0
        lnz = beta * (np.log(x + 1e-12) - np.log(Nc))
        z = np.exp(lnz)
        return L + A / (1.0 + z)

    if p.ndim == 1:
        return pred_single(p)
    else:
        return np.column_stack([pred_single(pi) for pi in p])

def fit_scaling_law(data_points, loss_values):
    x = np.asarray(data_points, dtype=float).reshape(-1)
    y = np.asarray(loss_values, dtype=float)
    Y = y[:, None] if y.ndim == 1 else y
    lnX = np.log(x + 1e-12)
    T = Y.shape[1]
    out = []

    for t in range(T):
        yy = Y[:, t].astype(float)
        L0 = float(np.min(yy) - 2e-2)
        ys = yy - L0
        if not np.all(ys &gt; 0):
            pos = ys[ys &gt; 0]
            floor = float(np.min(pos)) if pos.size else 1.0
            ys[ys &lt;= 0] = floor
        A0 = max(1e-6, 1.1 * float(np.max(ys)))
        s = A0 / ys - 1.0
        mask = s &gt; 1e-8
        beta0 = 1.0
        Nc0 = np.exp(np.mean(lnX))
        if np.any(mask):
            lnS = np.log(s[mask])
            lnN = lnX[mask]
            var_lnN = np.var(lnN) + 1e-12
            slope = (np.cov(lnN, lnS, bias=True)[0, 1]) / var_lnN
            if np.isfinite(slope) and slope &gt; 0:
                beta0 = np.clip(slope, 1e-3, 5.0)
                intercept = np.mean(lnS) - slope * np.mean(lnN)
                lnNc = -intercept / (beta0 + 1e-12)
                lnNc = np.clip(lnNc, np.min(lnX), np.max(lnX))
                Nc0 = np.exp(lnNc)

        p0 = np.array([L0, np.log(A0), np.log(Nc0), np.log(beta0)], dtype=float)

        def obj_grad(p):
            L, ua, un, ub = p
            A = np.exp(ua)
            Nc = np.exp(un)
            beta = np.exp(ub)
            lnz = beta * (np.log(x + 1e-12) - np.log(Nc))
            z = np.exp(lnz)
            dnm = 1.0 + z
            g = 1.0 / dnm
            pred = L + A * g
            r = pred - yy
            d = 0.3
            a = np.abs(r)
            w = np.where(a &lt;= d, r, d * np.sign(r))
            z_over = z / (dnm * dnm)
            safe_log = np.log(np.maximum(x / Nc, 1e-12))
            N = x.size
            reg = 1e-6
            loss = np.where(a &lt;= d, 0.5 * r * r, d * (a - 0.5 * d)).mean() + reg * np.sum(p * p)
            gL = np.mean(w)
            gau = np.mean(w * (A * g))
            gun = np.mean(w * (A * beta * z_over))
            gub = np.mean(w * (-A * beta * z_over * safe_log))
            grad = np.array([gL + 2 * reg * L, gau + 2 * reg * ua, gun + 2 * reg * un, gub + 2 * reg * ub], dtype=float)
            return loss, grad

        res = minimize(lambda q: obj_grad(q)[0], p0, jac=lambda q: obj_grad(q)[1],
                       method=&#x27;L-BFGS-B&#x27;, options={&#x27;maxiter&#x27;: 500, &#x27;ftol&#x27;: 1e-9})
        out.append(res.x if res.success else p0)

    P = np.vstack(out)
    return P[0] if T == 1 else P
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> |
          <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a>
        </p>
      </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      function toggleRun(header) {
        const content = header.nextElementSibling;
        const isExpanded = content.style.display === "block";
        content.style.display = isExpanded ? "none" : "block";
        header.classList.toggle("expanded", !isExpanded);
      }

      function copyCode(event, codeId) {
        event.stopPropagation();
        const code = document.getElementById(codeId).textContent;
        navigator.clipboard.writeText(code).then(() => {
          const btn = event.target;
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 2000);
        });
      }

      Prism.highlightAll();
    </script>
  </body>
</html>

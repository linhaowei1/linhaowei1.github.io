<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SLD - Parallel Scaling Law - SLDAgent + o4-mini</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
      :root {
        --bg-primary: #ffffff;
        --bg-secondary: #f8f9fa;
        --accent-primary: #2563eb;
        --accent-secondary: #3b82f6;
        --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
        --text-primary: #1f2937;
        --text-secondary: #4b5563;
        --border-subtle: rgba(0, 0, 0, 0.1);
        --glass-bg: rgba(0, 0, 0, 0.02);
        --success: #10b981;
      }

      * {
        box-sizing: border-box;
        margin: 0;
        padding: 0;
      }

      body {
        font-family:
          "Sora",
          -apple-system,
          BlinkMacSystemFont,
          sans-serif;
        background: var(--bg-primary);
        min-height: 100vh;
        color: var(--text-primary);
      }

      .bg-pattern {
        display: none;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
        position: relative;
        z-index: 1;
      }

      .back-link {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--accent-primary);
        text-decoration: none;
        font-size: 0.9rem;
        margin-bottom: 1.5rem;
        transition: color 0.2s;
      }

      .back-link:hover {
        color: var(--accent-secondary);
      }

      .header {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 16px;
        padding: 2rem;
        margin-bottom: 2rem;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 1.75rem;
        font-weight: 700;
        margin-bottom: 0.5rem;
        background: var(--accent-gradient);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }

      .meta-row {
        display: flex;
        flex-wrap: wrap;
        gap: 1.5rem;
        margin-top: 1rem;
      }

      .meta-item {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }

      .meta-label {
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .meta-value {
        font-weight: 600;
        color: var(--text-primary);
      }

      .r2-badge {
        display: inline-block;
        padding: 0.3rem 0.6rem;
        border-radius: 6px;
        font-weight: 600;
        font-size: 0.85rem;
        font-family: "JetBrains Mono", monospace;
      }

      .section-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 1rem;
        color: var(--text-primary);
      }

      .runs-container {
        display: flex;
        flex-direction: column;
        gap: 1rem;
      }

      .run-card {
        background: var(--glass-bg);
        border: 1px solid var(--border-subtle);
        border-radius: 12px;
        overflow: hidden;
        transition: border-color 0.2s;
      }

      .run-card:hover {
        border-color: rgba(99, 102, 241, 0.3);
      }

      .run-card.best-run {
        border-color: var(--success);
        box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
      }

      .run-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 1rem 1.25rem;
        background: rgba(255, 255, 255, 0.02);
        cursor: pointer;
        transition: background 0.2s;
      }

      .run-header:hover {
        background: rgba(255, 255, 255, 0.04);
      }

      .run-info {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .run-badge {
        padding: 0.25rem 0.6rem;
        border-radius: 6px;
        font-size: 0.75rem;
        font-weight: 600;
        background: rgba(255, 255, 255, 0.1);
        color: var(--text-secondary);
      }

      .run-badge.best-badge {
        background: var(--success);
        color: white;
      }

      .run-label {
        font-weight: 500;
        color: var(--text-primary);
      }

      .expand-icon {
        color: var(--text-muted);
        font-size: 0.8rem;
        transition: transform 0.2s;
      }

      .run-header.expanded .expand-icon {
        transform: rotate(180deg);
      }

      .run-content {
        border-top: 1px solid var(--border-subtle);
      }

      .code-container {
        overflow: hidden;
      }

      .code-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 0.75rem 1.25rem;
        background: rgba(0, 0, 0, 0.2);
        border-bottom: 1px solid var(--border-subtle);
        font-size: 0.8rem;
        color: var(--text-muted);
      }

      .copy-btn {
        padding: 0.35rem 0.75rem;
        background: rgba(99, 102, 241, 0.2);
        border: 1px solid rgba(99, 102, 241, 0.3);
        border-radius: 6px;
        color: var(--accent-primary);
        font-size: 0.75rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.2s;
        font-family: inherit;
      }

      .copy-btn:hover {
        background: rgba(99, 102, 241, 0.3);
      }

      .code-container pre {
        margin: 0;
        padding: 1.25rem;
        font-family: "JetBrains Mono", monospace;
        font-size: 0.8rem;
        line-height: 1.6;
        overflow-x: auto;
        background: transparent !important;
      }

      .footer {
        text-align: center;
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid var(--border-subtle);
        color: var(--text-secondary);
        font-size: 0.85rem;
      }

      .footer a {
        color: var(--accent-primary);
        text-decoration: none;
      }

      @media (max-width: 768px) {
        .container {
          padding: 1rem;
        }

        .header h1 {
          font-size: 1.25rem;
        }

        .meta-row {
          flex-direction: column;
          gap: 0.75rem;
        }

        .run-info {
          flex-wrap: wrap;
          gap: 0.5rem;
        }
      }
    </style>
  </head>
  <body>
    <div class="bg-pattern"></div>

    <div class="container">
      <a href="index.html" class="back-link"> ← Back to Leaderboard </a>

      <div class="header">
        <h1>Parallel Scaling Law</h1>
        <div class="meta-row">
          <div class="meta-item">
            <span class="meta-label">Agent:</span>
            <span class="meta-value">SLDAgent</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Model:</span>
            <span class="meta-value">o4-mini</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Best R²:</span>
            <span class="r2-badge" style="background-color: #006400; color: white"> 0.999958 </span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Mean R²:</span>
            <span class="meta-value">0.999955</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Min R²:</span>
            <span class="meta-value">0.999954</span>
          </div>
          <div class="meta-item">
            <span class="meta-label">Runs:</span>
            <span class="meta-value">5</span>
          </div>
        </div>
      </div>

      <h2 class="section-title">All Runs (sorted by R²)</h2>

      <div class="runs-container">

        <div class="run-card best-run">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge best-badge">Best</span>
              <span class="run-label">Run 2</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.999958 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: block">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-0">import numpy as np
from scipy.optimize import least_squares

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Four-parameter scaling law with diminishing-parallel returns:
      loss = b + a * (N/1e9)^(-alpha) * (1 + log2(P))^(-beta)
    where:
      N      = model size (num_params)
      P      = parallel_size
      P_eff  = 1 + log2(P) for diminishing returns
    params = [a, alpha, beta, b]
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    N = X[:, 0] / 1e9
    P = X[:, 1]
    # effective parallel factor
    eps = 1e-12
    P_eff = 1.0 + np.log2(np.clip(P, eps, None))
    a, alpha, beta, b = params
    # enforce minimal positivity for stability
    a     = max(a, eps)
    alpha = max(alpha, eps)
    beta  = max(beta, eps)
    b     = max(b, 0.0)
    return b + a * (N ** (-alpha)) * (P_eff ** (-beta))


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 4-parameter law
      loss = b + a*(N/1e9)^(-alpha)*(1+log2(P))^(-beta)
    via:
      1) init b near the lowest observed loss
      2) log-linear regression for [a, alpha, beta]
      3) robust non-linear least squares (Huber) with analytic Jacobian
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.asarray(loss_values, dtype=float).ravel()
    if X.shape[0] != y.size:
        raise ValueError(&quot;data_points and loss_values must match lengths&quot;)

    # preprocess features
    N = X[:, 0] / 1e9
    P = X[:, 1]
    eps = 1e-12
    P_eff = 1.0 + np.log2(np.clip(P, eps, None))
    y_min = float(np.min(y))

    # 1) initialize intercept b near the lower envelope
    b0 = max(0.0, 0.9 * y_min)

    # 2) log-linear initialization for a, alpha, beta
    y_shift = y - b0
    # clamp to positive
    y_shift = np.clip(y_shift, eps, None)
    logy   = np.log(y_shift)
    logN   = np.log(np.clip(N,   eps, None))
    logPe  = np.log(P_eff)

    # design matrix: logy ≈ C0 − alpha*logN − beta*logPe
    A = np.column_stack([np.ones_like(logy), -logN, -logPe])
    try:
        C0, alpha0, beta0 = np.linalg.lstsq(A, logy, rcond=None)[0]
        a0     = max(np.exp(C0),     eps)
        alpha0 = max(alpha0,         eps)
        beta0  = max(beta0,          eps)
    except Exception:
        span   = max(np.max(y) - y_min, eps)
        a0, alpha0, beta0 = span, 0.5, 0.2

    init_params = np.array([a0, alpha0, beta0, b0], dtype=float)

    # residuals for least_squares (raw domain)
    def residuals(p):
        return scaling_law_func(X, p) - y

    # analytic Jacobian ∂r/∂p
    def jac(p):
        a, alpha, beta, _ = p
        M = (N ** (-alpha)) * (P_eff ** (-beta))
        da     = M
        dalpha = -a * M * np.log(np.clip(N, eps, None))
        dbeta  = -a * M * np.log(P_eff)
        db     = np.ones_like(M)
        return np.vstack([da, dalpha, dbeta, db]).T

    # bounds: a,alpha,beta ≥ eps; b in [0, y_min]
    lower = [eps, eps, eps, 0.0]
    upper = [np.inf, np.inf, np.inf, y_min]

    # 3) robust fitting with Huber loss
    result = least_squares(
        residuals,
        init_params,
        jac=jac,
        bounds=(lower, upper),
        loss=&#x27;huber&#x27;,
        f_scale=1e-3,
        xtol=1e-12,
        ftol=1e-12,
        gtol=1e-12
    )

    p_opt = result.x if result.success else init_params
    # ensure intercept never exceeds the observed minimum
    p_opt[3] = min(p_opt[3], y_min)
    return p_opt</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#2</span>
              <span class="run-label">Run 1</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.999954 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-1">import numpy as np
from scipy.optimize import least_squares

# EVOLVE-BLOCK-START
def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Predict loss as:
      loss = b + a * num_params^(−alpha) * parallel_size^(−beta)
    using a stable exp(·) form.
    params = [a, alpha, beta, b] (4 parameters)
    &quot;&quot;&quot;
    D = np.atleast_2d(np.asarray(data_points, dtype=float))
    n, s = D[:, 0], D[:, 1]
    a, alpha, beta, b = params
    # add small eps inside logs for numerical stability
    return b + a * np.exp(-alpha * np.log(n + 1e-12)
                          - beta  * np.log(s + 1e-12))

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 4-parameter scaling law via:
      1) three baseline offsets b₀ ∈ {0.0, 0.5·min(y), 0.9·min(y)}
      2) log-linear least squares to initialize [loga, α, β]
      3) refine all [a, α, β, b] by Levenberg-Marquardt (least_squares)
         with analytic Jacobian on residuals f(data; p) − y
    Returns optimized params [a, alpha, beta, b].
    &quot;&quot;&quot;
    D = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.ravel(np.asarray(loss_values, dtype=float))
    n, s = D[:, 0], D[:, 1]
    # precompute logs
    ln_n = np.log(n + 1e-12)
    ln_s = np.log(s + 1e-12)
    y_min = y.min()
    eps = 1e-12

    best_cost = np.inf
    best_params = None

    # Multi-start on baseline guesses for b
    for frac in (0.0, 0.5, 0.9):
        b0 = max(0.0, frac * y_min)
        # prepare for log-linear init
        y_adj = np.clip(y - b0, eps, None)
        L     = np.log(y_adj)
        A     = np.vstack([np.ones_like(L), -ln_n, -ln_s]).T
        sol, *_ = np.linalg.lstsq(A, L, rcond=None)
        loga0, alpha0, beta0 = sol
        a0 = np.exp(loga0)
        p0 = np.array([max(a0, eps),
                       max(alpha0, 0.0),
                       max(beta0,  0.0),
                       b0], dtype=float)

        # bounds: a&gt;0, α≥0, β≥0, b≥0
        lb = [eps, 0.0, 0.0, 0.0]
        ub = [np.inf, 10.0, 10.0, y_min]

        # residuals and Jacobian for least_squares
        def residuals(p):
            a, alpha, beta, b = p
            # f = b + a * exp(−α ln n − β ln s)
            exp_term = np.exp(-alpha * ln_n - beta * ln_s)
            return b + a * exp_term - y

        def jac(p):
            a, alpha, beta, b = p
            exp_term = np.exp(-alpha * ln_n - beta * ln_s)
            # df/da, df/dα, df/dβ, df/db
            df_da     = exp_term
            df_dalpha = -a * exp_term * ln_n
            df_dbeta  = -a * exp_term * ln_s
            df_db     = np.ones_like(y)
            # stack columns
            return np.vstack([df_da, df_dalpha, df_dbeta, df_db]).T

        try:
            res = least_squares(residuals,
                                p0,
                                jac=jac,
                                bounds=(lb, ub),
                                xtol=1e-12,
                                ftol=1e-12)
            if res.success and res.cost &lt; best_cost:
                best_cost   = res.cost
                best_params = res.x
        except Exception:
            continue

    # fallback if all starts fail
    if best_params is None:
        return np.array([1e-3, 0.5, 0.1, eps], dtype=float)
    return best_params
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#3</span>
              <span class="run-label">Run 3</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.999954 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-2">import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Predict loss using a power‐law in model size and parallelism:
      loss = b + a * (num_params/1e9)^(-alpha) * (parallel_size)^(-beta)
    params: [a, alpha, beta, b]
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points))
    N = X[:, 0] / 1e9
    P = X[:, 1]
    a, alpha, beta, b = params
    return b + a * (N ** (-alpha)) * (P ** (-beta))


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit a 4-parameter scaling law:
      loss = b + a * (num_params/1e9)^(-alpha) * (parallel_size)^(-beta)
    Steps:
      1) Estimate offset b0 from lower end of the losses.
      2) Solve a log-linear regression with a small ridge to get ln(a), alpha, beta.
      3) Refine offset b0 from residuals.
      4) Jointly optimize [a, alpha, beta, b] by minimizing MSE with L-BFGS-B.
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points))
    y = np.ravel(loss_values)
    N = X[:, 0] / 1e9
    P = X[:, 1]

    # 1) initial offset estimate
    y_min, y_max = y.min(), y.max()
    b0 = max(0.0, y_min - 0.1 * (y_max - y_min))

    # 2) log-linear regression for ln(a), alpha, beta
    r = np.clip(y - b0, 1e-8, None)
    lnN, lnP = np.log(N), np.log(P)
    # Design matrix: [1, -ln(N), -ln(P)]
    Z = np.vstack([np.ones_like(r), -lnN, -lnP]).T
    t = np.log(r)
    ridge = 1e-6 * np.eye(3)
    theta = np.linalg.solve(Z.T @ Z + ridge, Z.T @ t)
    ln_a0, alpha0, beta0 = theta
    a0 = np.exp(ln_a0)

    # 3) refine b0 from residuals
    pred0 = a0 * (N ** (-alpha0)) * (P ** (-beta0))
    b0 = max(0.0, float(np.mean(y - pred0)))

    init = np.array([a0, alpha0, beta0, b0], dtype=float)

    # 4) final joint optimization on MSE
    def mse_loss(p):
        pred = scaling_law_func(X, p)
        return np.mean((pred - y) ** 2)

    bounds = [(1e-12, None), (1e-8, None), (1e-8, None), (0.0, None)]
    res = minimize(mse_loss, init, method=&#x27;L-BFGS-B&#x27;, bounds=bounds)

    return res.x if res.success else init</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#4</span>
              <span class="run-label">Run 4</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.999954 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-3">import numpy as np
from scipy.optimize import differential_evolution, least_squares

# EVOLVE-BLOCK-START
def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    4-parameter parallel scaling law:
      loss = b + a * n^{-alpha} * s^{-beta}
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    n, s = X[:, 0], X[:, 1]
    a, alpha, beta, b = params
    # direct power‐law form
    return b + a * n**(-alpha) * s**(-beta)

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Global‐to‐local fit:
      1) coarse global search via differential evolution minimizing MSE
      2) local refinement via bounded least_squares
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    y = np.asarray(loss_values, dtype=float).ravel()
    y_min, y_max = y.min(), y.max()

    # MSE objective for DE
    def mse_obj(p):
        pred = scaling_law_func(X, p)
        return np.mean((pred - y)**2)

    # parameter bounds: a∈[0,10·Δy], α∈[0,2], β∈[0,1], b∈[0,0.9·y_min]
    bounds = [
        (0.0, 10.0*(y_max-y_min)),
        (0.0, 2.0),
        (0.0, 1.0),
        (0.0, 0.9*y_min)
    ]

    # 1) global search
    de_result = differential_evolution(
        mse_obj,
        bounds,
        maxiter=200,
        popsize=10,
        polish=False
    )
    p0 = de_result.x

    # 2) local refinement
    lb = [1e-12, 0.0, 0.0, 0.0]
    ub = [np.inf, 2.0, 1.0, 0.9*y_min]
    ls_result = least_squares(
        lambda p: scaling_law_func(X, p) - y,
        p0,
        bounds=(lb, ub),
        xtol=1e-12,
        ftol=1e-12,
        max_nfev=2000
    )

    return ls_result.x if ls_result.success else p0
# EVOLVE-BLOCK-END</code></pre>
            </div>
          </div>
        </div>
        <div class="run-card">
          <div class="run-header" onclick="toggleRun(this)">
            <div class="run-info">
              <span class="run-badge">#5</span>
              <span class="run-label">Run 5</span>
              <span class="r2-badge" style="background-color: #006400; color: white"> R² = 0.999954 </span>
            </div>
            <span class="expand-icon">▼</span>
          </div>
          <div class="run-content" style="display: none">
            <div class="code-container">
              <div class="code-header">
                <span>Python</span>
                <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
              </div>
              <pre><code class="language-python" id="code-4">import numpy as np
from scipy.optimize import minimize

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    4‐parameter parallel scaling law:
      loss = b + a * (num_params/1e9)^(-alpha) * parallel_size^(-beta)
    params = [a, alpha, beta, b]
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    # normalize model size (in billions) for numerical stability
    N = X[:, 0] / 1e9
    s = X[:, 1]
    a, alpha, beta, b = params
    return b + a * (N ** (-alpha)) * (s ** (-beta))


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 4-parameter form
      loss = b + a * (N/1e9)^(-alpha) * s^(-beta)
    by a two‐stage procedure:
      1) grid‐search b in [0, 0.8*min(y)] and solve
         log(y-b) ≈ log(a) - alpha*log(N) - beta*log(s)
         via linear least squares to get initial (a,alpha,beta,b).
      2) refine all four parameters by L-BFGS-B minimizing MSE.
    &quot;&quot;&quot;
    # prepare data
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.asarray(loss_values, dtype=float).ravel()
    # normalized feature
    N = X[:, 0] / 1e9
    s = X[:, 1]
    # logs for linear solve
    logN = np.log(N + 1e-12)
    logs = np.log(s + 1e-12)

    y_min = y.min()
    best_err = np.inf
    best_init = None

    # coarse grid for baseline b
    for b in np.linspace(0.0, 0.8 * y_min, 30):
        y_adj = y - b
        # skip invalid offsets
        if np.any(y_adj &lt;= 0):
            continue
        L = np.log(y_adj)
        # design matrix: L = c0 - alpha*logN - beta*logs
        A = np.vstack([np.ones_like(L), -logN, -logs]).T
        # solve for [c0, alpha, beta]
        coeffs, *_ = np.linalg.lstsq(A, L, rcond=None)
        c0, alpha, beta = coeffs
        a = np.exp(c0)
        # compute MSE in original space
        pred = b + a * (N ** (-alpha)) * (s ** (-beta))
        err = np.mean((pred - y) ** 2)
        if err &lt; best_err:
            best_err = err
            best_init = np.array([a, alpha, beta, b], dtype=float)

    # fallback if grid search failed
    if best_init is None:
        best_init = np.array([1.0, 0.5, 0.2, 0.0], dtype=float)

    # refine all parameters with bounded L-BFGS-B on original MSE
    def objective(p):
        pred = scaling_law_func(X, p)
        return np.mean((pred - y) ** 2)

    # bounds: a&gt;0, alpha&gt;=0, beta&gt;=0, 0&lt;=b&lt;=min(y)
    bounds = [
        (1e-12, None),    # a
        (0.0, None),      # alpha
        (0.0, None),      # beta
        (0.0, y_min)      # b
    ]

    res = minimize(objective, best_init, method=&#x27;L-BFGS-B&#x27;, bounds=bounds)
    if res.success:
        return res.x
    else:
        return best_init</code></pre>
            </div>
          </div>
        </div>
      </div>

      <footer class="footer">
        <p>
          SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> |
          <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a>
        </p>
      </footer>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
      function toggleRun(header) {
        const content = header.nextElementSibling;
        const isExpanded = content.style.display === "block";
        content.style.display = isExpanded ? "none" : "block";
        header.classList.toggle("expanded", !isExpanded);
      }

      function copyCode(event, codeId) {
        event.stopPropagation();
        const code = document.getElementById(codeId).textContent;
        navigator.clipboard.writeText(code).then(() => {
          const btn = event.target;
          btn.textContent = "Copied!";
          setTimeout(() => (btn.textContent = "Copy"), 2000);
        });
      }

      Prism.highlightAll();
    </script>
  </body>
</html>
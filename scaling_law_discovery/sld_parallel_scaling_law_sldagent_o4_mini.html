<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLD - Parallel Scaling Law - SLDAgent + o4-mini</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --accent-primary: #2563eb;
            --accent-secondary: #3b82f6;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-subtle: rgba(0, 0, 0, 0.1);
            --glass-bg: rgba(0, 0, 0, 0.02);
            --success: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Sora', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .bg-pattern {
            display: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--accent-secondary);
        }
        
        .header {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .meta-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .meta-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .meta-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .r2-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .runs-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .run-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .run-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .run-card.best-run {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.02);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .run-header:hover {
            background: rgba(255, 255, 255, 0.04);
        }
        
        .run-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .run-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        
        .run-badge.best-badge {
            background: var(--success);
            color: white;
        }
        
        .run-label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .expand-icon {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .run-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .run-content {
            border-top: 1px solid var(--border-subtle);
        }
        
        .code-container {
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .copy-btn {
            padding: 0.35rem 0.75rem;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .copy-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }
        
        .code-container pre {
            margin: 0;
            padding: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-x: auto;
            background: transparent !important;
        }
        
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .meta-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .run-info {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <a href="sld_index.html" class="back-link">
            ← Back to Leaderboard
        </a>
        
        <div class="header">
            <h1>Parallel Scaling Law</h1>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Agent:</span>
                    <span class="meta-value">SLDAgent</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Model:</span>
                    <span class="meta-value">o4-mini</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best R²:</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        0.999667
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Mean R²:</span>
                    <span class="meta-value">0.999660</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Min R²:</span>
                    <span class="meta-value">0.999658</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Runs:</span>
                    <span class="meta-value">5</span>
                </div>
            </div>
        </div>
        
        <h2 class="section-title">All Runs (sorted by R²)</h2>
        
        <div class="runs-container">
            
        <div class="run-card best-run">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge best-badge">Best</span>
                    <span class="run-label">Run 2</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.999667
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: block;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-0">import numpy as np
from scipy.optimize import least_squares

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    4-parameter parallel scaling law:
      loss = b + a * (num_params)^(-alpha) * (parallel_size)^(-beta)
    params = [a, alpha, beta, b]
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    N = X[:, 0]
    P = X[:, 1]
    a, alpha, beta, b = params
    return b + a * np.power(N, -alpha) * np.power(P, -beta)

def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit the 4-parameter law:
      loss ≈ b + a * N^{-alpha} * P^{-beta}
    1) initialize b just below the minimum observed loss
    2) log-linear least squares to estimate [a, alpha, beta]
    3) refine all four parameters with a robust bounded solver
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points, dtype=float))
    y = np.ravel(np.asarray(loss_values, dtype=float))
    N = X[:, 0]
    P = X[:, 1]

    # 1) floor b slightly below the smallest loss
    y_min = y.min()
    b0 = max(0.0, 0.9 * y_min)

    # Prepare positive targets for log-linear init
    y_adj = y - b0
    eps = 1e-8
    if np.any(y_adj &lt;= 0):
        mask = y_adj &gt; 0
        if mask.any():
            minpos = np.min(y_adj[mask])
        else:
            minpos = eps
        y_adj = np.where(mask, y_adj, minpos)
    log_y = np.log(y_adj)

    # 2) solve log_y = log(a) - alpha*log(N) - beta*log(P)
    A = np.column_stack([np.ones_like(log_y), -np.log(N), -np.log(P)])
    coeffs, *_ = np.linalg.lstsq(A, log_y, rcond=None)
    loga0, alpha0, beta0 = coeffs
    a0 = np.exp(loga0)
    p0 = np.array([a0, alpha0, beta0, b0], dtype=float)

    # 3) refine with robust bounded least squares
    def residuals(p):
        return scaling_law_func(X, p) - y

    # analytic Jacobian for speed &amp; stability
    logN = np.log(N)
    logP = np.log(P)
    def jac(p):
        a, alpha, beta, _ = p
        S = np.power(N, -alpha) * np.power(P, -beta)
        J = np.empty((N.size, 4), dtype=float)
        J[:, 0] = S
        J[:, 1] = -a * S * logN
        J[:, 2] = -a * S * logP
        J[:, 3] = 1.0
        return J

    # bounds: a&gt;0, alpha&gt;=0, beta&gt;=0, 0&lt;=b&lt;=y_min
    lb = [1e-12, 0.0,    0.0,    0.0]
    ub = [np.inf,  np.inf, np.inf, y_min]

    result = least_squares(
        residuals,
        p0,
        jac=jac,
        bounds=(lb, ub),
        loss=&#x27;soft_l1&#x27;,
        f_scale=1e-3,
        xtol=1e-12,
        ftol=1e-12,
        gtol=1e-12,
        max_nfev=5000
    )

    return result.x if result.success else p0</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#2</span>
                    <span class="run-label">Run 3</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.999660
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-1">import numpy as np
from scipy.optimize import minimize

# EVOLVE-BLOCK-START
def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    4‐parameter scaling law:
      L(n, s) = b + a * (n/1e9)^(-p) * s^(-q)
    where params = [a, p, q, b].
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    a, p, q, b = params
    # normalize and clip for stability
    n = np.maximum(X[:, 0] / 1e9, 1e-12)
    s = np.maximum(X[:, 1],       1e-12)
    return b + a * n**(-p) * s**(-q)


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit [a, p, q, b] in three phases:
      1) Baseline b₀ ≈ 0.9*min(y), adjusted if needed to keep (y-b₀)&gt;0
      2) Linear least‐squares on ln(y - b₀) = ln(a) - p*ln(n) - q*ln(s)
      3) Refinement via L‐BFGS‐B minimizing MSE + small ridge on p,q
         using analytic gradients for stability.
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    y = np.asarray(loss_values, dtype=float).ravel()

    # feature preprocessing
    n = np.maximum(X[:, 0] / 1e9, 1e-12)
    s = np.maximum(X[:, 1],       1e-12)
    ln_n = np.log(n)
    ln_s = np.log(s)
    y_min, y_max = y.min(), y.max()

    # 1) Initialize baseline b0 just below the smallest loss
    b0 = max(0.0, 0.9 * y_min)
    y_off = y - b0
    if np.any(y_off &lt;= 0):
        b0 = y_min - 0.1 * (y_max - y_min)
        y_off = y - b0
    y_off = np.maximum(y_off, 1e-12)
    ln_y = np.log(y_off)

    # 2) Solve ln(y_off) = ln(a) - p*ln(n) - q*ln(s)
    A = np.vstack([np.ones_like(ln_y), -ln_n, -ln_s]).T
    theta, *_ = np.linalg.lstsq(A, ln_y, rcond=None)
    ln_a0, p0, q0 = theta
    a0 = max(np.exp(ln_a0), 1e-8)
    p0 = max(p0, 0.0)
    q0 = max(q0, 0.0)
    init = np.array([a0, p0, q0, b0], dtype=float)

    # 3) Refinement: minimize MSE + small ridge on exponents
    N = y.size
    ridge = 1e-6

    def obj_and_grad(params):
        a, p, q, b = params
        expo = -p * ln_n - q * ln_s
        E = np.exp(expo)
        pred = b + a * E
        resid = pred - y
        # objective: MSE + ridge*(p^2 + q^2)
        mse = np.mean(resid**2) + ridge * (p**2 + q**2)

        # analytic gradients
        coef = 2.0 / N
        tmp = coef * resid
        g_a = np.sum(tmp * E)
        g_p = np.sum(tmp * (-a * E * ln_n)) + 2 * ridge * p
        g_q = np.sum(tmp * (-a * E * ln_s)) + 2 * ridge * q
        g_b = np.sum(tmp)
        return mse, np.array([g_a, g_p, g_q, g_b], dtype=float)

    bounds = [
        (1e-12, None),  # a &gt; 0
        (0.0,      None),  # p &gt;= 0
        (0.0,      None),  # q &gt;= 0
        (0.0,      y_min)  # 0 &lt;= b &lt;= min(y)
    ]
    result = minimize(
        fun=lambda w: obj_and_grad(w)[0],
        x0=init,
        jac=lambda w: obj_and_grad(w)[1],
        method=&#x27;L-BFGS-B&#x27;,
        bounds=bounds
    )

    return result.x if result.success else init
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#3</span>
                    <span class="run-label">Run 5</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.999658
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-2">import numpy as np
from scipy.optimize import least_squares

# EVOLVE-BLOCK-START
def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Predict loss using a 4-parameter power law:
      loss = b + a * (N/1e9)^(-alpha) * P^(-beta)
    params = [a, alpha, beta, b]
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points))
    # normalize model size to billions for numerical stability
    N = X[:, 0] / 1e9
    P = X[:, 1]
    a, alpha, beta, b = params
    return b + a * (N ** (-alpha)) * (P ** (-beta))


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit loss ≈ b + a*(N/1e9)^(-alpha)*P^(-beta)
    using log-linear initialization and robust non-linear least squares.
    &quot;&quot;&quot;
    X = np.atleast_2d(np.asarray(data_points))
    y = np.asarray(loss_values).ravel()
    N = X[:, 0] / 1e9
    P = X[:, 1]

    # 1) Initialize baseline b near the lower envelope (5th percentile)
    try:
        p5 = np.percentile(y, 5)
        b0 = max(0.0, p5 * 0.9)
    except Exception:
        b0 = max(0.0, 0.9 * y.min())

    # 2) Shift and clamp y for log-domain regression
    eps = 1e-8
    y_shift = np.clip(y - b0, eps, None)
    logy = np.log(y_shift)

    # 3) Solve log(y−b0) ≈ C - alpha*ln(N) - beta*ln(P)
    M = np.column_stack([np.ones_like(logy), -np.log(N), -np.log(P)])
    try:
        C, alpha0, beta0 = np.linalg.lstsq(M, logy, rcond=None)[0]
        a0 = max(np.exp(C), eps)
        alpha0 = max(alpha0, eps)
        beta0 = max(beta0, eps)
    except Exception:
        a0, alpha0, beta0 = (y.max() - b0), 0.5, 0.1

    init_params = np.array([a0, alpha0, beta0, b0], dtype=float)

    # 4) Refine via robust least squares (soft L1) to reduce outlier influence
    def residuals(p):
        return scaling_law_func(X, p) - y

    lower = [eps, eps, eps, 0.0]   # a&gt;0, alpha&gt;0, beta&gt;0, b&gt;=0
    upper = [np.inf, np.inf, np.inf, np.inf]
    result = least_squares(
        residuals,
        init_params,
        bounds=(lower, upper),
        loss=&#x27;soft_l1&#x27;,
        f_scale=0.1,
        ftol=1e-10,
        xtol=1e-10,
        gtol=1e-10
    )

    return result.x if result.success else init_params
# EVOLVE-BLOCK-END</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#4</span>
                    <span class="run-label">Run 4</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.999658
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-3">import numpy as np
from scipy.optimize import least_squares

def scaling_law_func(data_points, params):
    # Predict loss = b + a * num_params^(-alpha) * parallel_size^(-beta)
    D = np.asarray(data_points, dtype=float)
    n, s = D[:, 0], D[:, 1]
    a, alpha, beta, b = params
    return b + a * n**(-alpha) * s**(-beta)

def fit_scaling_law(data_points, loss_values):
    # Convert inputs
    D = np.asarray(data_points, dtype=float)
    y = np.asarray(loss_values, dtype=float).ravel()
    n, s = D[:, 0], D[:, 1]

    # Baseline offset just below minimum observed loss
    y_min, y_max = y.min(), y.max()
    b0 = max(0.0, 0.9 * y_min)

    # Prepare for log‐linear initial guess
    y_adj = np.clip(y - b0, 1e-12, None)
    M = np.vstack([np.ones_like(n), -np.log(n), -np.log(s)]).T

    # Solve log(y_adj) = log(a) - alpha·log(n) - beta·log(s)
    try:
        loga0, alpha0, beta0 = np.linalg.lstsq(M, np.log(y_adj), rcond=None)[0]
    except Exception:
        loga0, alpha0, beta0 = np.log(y_adj.mean()), 0.5, 0.5

    a0 = np.exp(loga0)
    # Ensure positive exponents
    alpha0 = max(alpha0, 1e-8)
    beta0  = max(beta0,  1e-8)
    init = [a0, alpha0, beta0, b0]

    # Bounds: a&gt;0, alpha&gt;=0, beta&gt;=0, 0&lt;=b&lt;=y_min
    lower = [1e-12, 0.0, 0.0, 0.0]
    upper = [np.inf, 10.0, 10.0, y_min]

    # Robust nonlinear refinement with Cauchy loss
    res = least_squares(
        lambda p: scaling_law_func(D, p) - y,
        init,
        bounds=(lower, upper),
        loss=&#x27;cauchy&#x27;,
        f_scale=0.1,
        max_nfev=5000,
        xtol=1e-12,
        ftol=1e-12
    )

    return res.x if res.success else np.array(init)</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#5</span>
                    <span class="run-label">Run 1</span>
                    <span class="r2-badge" style="background-color: #006400; color: white;">
                        R² = 0.999658
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-4">import numpy as np
from scipy.optimize import curve_fit

def scaling_law_func(data_points, params):
    &quot;&quot;&quot;
    Four-parameter power‐law scaling:
      loss ≈ b + a * num_params^{-alpha} * parallel_size^{-beta}
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    N, P = X[:, 0], X[:, 1]
    a, alpha, beta, b = params
    return b + a * (N ** (-alpha)) * (P ** (-beta))


def fit_scaling_law(data_points, loss_values):
    &quot;&quot;&quot;
    Fit loss = b + a*N^{-alpha}*P^{-beta} with 4 parameters [a, alpha, beta, b].
    1) Initialize via log‐domain linearization.
    2) Refine with bounded nonlinear least squares (curve_fit).
    &quot;&quot;&quot;
    X = np.asarray(data_points, dtype=float)
    N, P = X[:, 0], X[:, 1]
    y = np.asarray(loss_values, dtype=float).ravel()

    # 1) Initialize plateau b0 near 90% of the min observed loss
    b0 = max(0.0, 0.9 * y.min())

    # 2) Shift/clamp for positivity
    y_shift = np.clip(y - b0, 1e-8, None)
    logy = np.log(y_shift)

    # 3) Linear proxy: log(y-b0) ≈ C0 - alpha*log(N) - beta*log(P)
    A = np.vstack([np.ones_like(logy), -np.log(N), -np.log(P)]).T
    try:
        C0, alpha0, beta0 = np.linalg.lstsq(A, logy, rcond=None)[0]
        a0 = np.exp(C0)
    except Exception:
        a0, alpha0, beta0 = 1.0, 0.5, 0.1

    # 4) Prepare initial guess and bounds
    init = [a0, max(alpha0, 1e-8), max(beta0, 1e-8), b0]
    lower = [1e-8, 1e-8, 1e-8, 0.0]
    upper = [np.inf, np.inf, np.inf, np.inf]

    # 5) Refine with scipy.curve_fit
    def model(x, a, alpha, beta, b):
        Np, Pp = x
        return b + a * (Np ** (-alpha)) * (Pp ** (-beta))

    popt, _ = curve_fit(
        model,
        (N, P),
        y,
        p0=init,
        bounds=(lower, upper),
        max_nfev=20000
    )
    return popt</code></pre>
                </div>
            </div>
        </div>
        
        </div>
        
        <footer class="footer">
            <p>SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> | <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a></p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleRun(header) {
            const content = header.nextElementSibling;
            const isExpanded = content.style.display === 'block';
            content.style.display = isExpanded ? 'none' : 'block';
            header.classList.toggle('expanded', !isExpanded);
        }
        
        function copyCode(event, codeId) {
            event.stopPropagation();
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }
        
        Prism.highlightAll();
    </script>
</body>
</html>
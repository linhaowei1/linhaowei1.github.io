<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLD - MoE Scaling Law - mini-swe-agent + GPT-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --accent-primary: #2563eb;
            --accent-secondary: #3b82f6;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-subtle: rgba(0, 0, 0, 0.1);
            --glass-bg: rgba(0, 0, 0, 0.02);
            --success: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Sora', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .bg-pattern {
            display: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--accent-secondary);
        }
        
        .header {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .meta-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .meta-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .meta-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .r2-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .runs-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .run-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .run-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .run-card.best-run {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.02);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .run-header:hover {
            background: rgba(255, 255, 255, 0.04);
        }
        
        .run-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .run-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        
        .run-badge.best-badge {
            background: var(--success);
            color: white;
        }
        
        .run-label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .expand-icon {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .run-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .run-content {
            border-top: 1px solid var(--border-subtle);
        }
        
        .code-container {
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .copy-btn {
            padding: 0.35rem 0.75rem;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .copy-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }
        
        .code-container pre {
            margin: 0;
            padding: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-x: auto;
            background: transparent !important;
        }
        
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .meta-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .run-info {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <a href="sld_index.html" class="back-link">
            ← Back to Leaderboard
        </a>
        
        <div class="header">
            <h1>MoE Scaling Law</h1>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Agent:</span>
                    <span class="meta-value">mini-swe-agent</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Model:</span>
                    <span class="meta-value">GPT-5</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best R²:</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        0.808867
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Mean R²:</span>
                    <span class="meta-value">0.352085</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Min R²:</span>
                    <span class="meta-value">-0.217412</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Runs:</span>
                    <span class="meta-value">5</span>
                </div>
            </div>
        </div>
        
        <h2 class="section-title">All Runs (sorted by R²)</h2>
        
        <div class="runs-container">
            
        <div class="run-card best-run">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge best-badge">Best</span>
                    <span class="run-label">Run 1</span>
                    <span class="r2-badge" style="background-color: #228B22; color: white;">
                        R² = 0.808867
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: block;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-0">def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    # learned parameters per group for the scaling law:
    # loss_validation = L_inf + k * (dense_parameter_count ** -a) * (num_experts ** -b)
    COEFFS = {
  &quot;all_data&quot;: {
    &quot;L_inf&quot;: 1.089119235508997,
    &quot;ln_k&quot;: 2.783892522808186,
    &quot;a&quot;: 0.1238983859205747,
    &quot;b&quot;: 0.047610349087410624
  },
  &quot;__default__&quot;: {
    &quot;L_inf&quot;: 1.089119235508997,
    &quot;ln_k&quot;: 2.783892522808186,
    &quot;a&quot;: 0.1238983859205747,
    &quot;b&quot;: 0.047610349087410624
  }
}
    gkey = group
    if gkey not in COEFFS:
        gkey = &#x27;__default__&#x27; if &#x27;__default__&#x27; in COEFFS else next(iter(COEFFS.keys()))
    p = COEFFS[gkey]
    L_inf = float(p[&#x27;L_inf&#x27;])
    ln_k = float(p[&#x27;ln_k&#x27;])
    a = float(p[&#x27;a&#x27;])
    b = float(p[&#x27;b&#x27;])
    import math as _m
    k = float(_m.exp(ln_k))
    out = []
    for row in input_data:
        D = float(row.get(&#x27;dense_parameter_count&#x27;, 0.0))
        E = float(row.get(&#x27;num_experts&#x27;, 0.0))
        if D &lt;= 0 or E &lt;= 0:
            y = float(&#x27;nan&#x27;)
        else:
            y = L_inf + k * (D ** (-a)) * (E ** (-b))
        out.append({&#x27;loss_validation&#x27;: float(y)})
    return out</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#2</span>
                    <span class="run-label">Run 2</span>
                    <span class="r2-badge" style="background-color: #D2691E; color: white;">
                        R² = 0.467622
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-1">def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    import math
    # Model: loss_validation = k * num_experts**a * dense_parameter_count**b
    COEFFS = {&quot;ALL&quot;: {&quot;a&quot;: -0.027401922527553482, &quot;b&quot;: -0.07051248607961777, &quot;k&quot;: 10.069179203081301}, &quot;all_data&quot;: {&quot;a&quot;: -0.027401922527553482, &quot;b&quot;: -0.07051248607961777, &quot;k&quot;: 10.069179203081301}}
    c = COEFFS.get(group, COEFFS.get(&quot;ALL&quot;, {&quot;k&quot;: 1.0, &quot;a&quot;: 0.0, &quot;b&quot;: 0.0}))
    k = float(c[&quot;k&quot;])
    a = float(c[&quot;a&quot;])
    b = float(c[&quot;b&quot;])
    out: list[dict[str, float]] = []
    for row in input_data:
        ne = float(row.get(&quot;num_experts&quot;, 0.0))
        dp = float(row.get(&quot;dense_parameter_count&quot;, 0.0))
        if not (ne &gt; 0.0 and dp &gt; 0.0 and math.isfinite(ne) and math.isfinite(dp)):
            pred = float(&quot;nan&quot;)
        else:
            pred = k * (ne ** a) * (dp ** b)
        out.append({&quot;loss_validation&quot;: float(pred)})
    return out</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#3</span>
                    <span class="run-label">Run 3</span>
                    <span class="r2-badge" style="background-color: #D2691E; color: white;">
                        R² = 0.363070
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-2"># Auto-generated scaling law for MoE validation loss
# Formula: loss_validation = L + a * dp^(-p) + b * ne^(-q) + c * (dp*ne)^(-r)
# where dp = dense_parameter_count, ne = num_experts
from __future__ import annotations
from typing import List, Dict

PARAMS = {
  &quot;GLOBAL&quot;: {
    &quot;L&quot;: 1.834176305371023,
    &quot;a&quot;: 35.997827556214766,
    &quot;b&quot;: -0.20801752620041014,
    &quot;c&quot;: 67.47418074483771,
    &quot;n&quot;: 193,
    &quot;p&quot;: 0.25,
    &quot;q&quot;: 1.0,
    &quot;r&quot;: 0.25,
    &quot;rmse&quot;: 0.05406499663123175
  },
  &quot;all_data&quot;: {
    &quot;L&quot;: 1.834176305371023,
    &quot;a&quot;: 35.997827556214766,
    &quot;b&quot;: -0.20801752620041014,
    &quot;c&quot;: 67.47418074483771,
    &quot;n&quot;: 193,
    &quot;p&quot;: 0.25,
    &quot;q&quot;: 1.0,
    &quot;r&quot;: 0.25,
    &quot;rmse&quot;: 0.05406499663123175
  }
}

def _predict_one(dp: float, ne: float, pars: dict) -&gt; float:
    if dp &lt;= 0 or ne &lt;= 0:
        return float(&#x27;nan&#x27;)
    L = pars[&quot;L&quot;]; a = pars[&quot;a&quot;]; b = pars[&quot;b&quot;]; c = pars[&quot;c&quot;]
    p = pars[&quot;p&quot;]; q = pars[&quot;q&quot;]; r = pars[&quot;r&quot;]
    return L + a * (dp ** (-p)) + b * (ne ** (-q)) + c * ((dp * ne) ** (-r))

def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    pars = PARAMS.get(group, PARAMS.get(&quot;GLOBAL&quot;))
    out: list[dict[str, float]] = []
    for row in input_data:
        dp = float(row.get(&quot;dense_parameter_count&quot;, float(&#x27;nan&#x27;)))
        ne = float(row.get(&quot;num_experts&quot;, float(&#x27;nan&#x27;)))
        pred = _predict_one(dp, ne, pars)
        out.append({&quot;loss_validation&quot;: float(pred)})
    return out</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#4</span>
                    <span class="run-label">Run 4</span>
                    <span class="r2-badge" style="background-color: #D2691E; color: white;">
                        R² = 0.338276
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-3"># Auto-generated scaling law implementation
# Model form: log-quadratic
# Features: 1, logE, logD, logE2, logD2, logE_logD

from math import log10

_COEFFICIENTS = {
  &quot;all_data&quot;: {
    &quot;weights&quot;: [
      13.849928930727911,
      -0.7685396744020193,
      -2.266750584688975,
      -0.005468530952045237,
      0.10924879564098447,
      0.0786451523043135
    ],
    &quot;r2&quot;: 0.9613252957444444,
    &quot;bic&quot;: -1120.0506497593492,
    &quot;n&quot;: 193
  },
  &quot;_default_&quot;: {
    &quot;weights&quot;: [
      13.849928930727911,
      -0.7685396744020193,
      -2.266750584688975,
      -0.005468530952045237,
      0.10924879564098447,
      0.0786451523043135
    ],
    &quot;r2&quot;: 0.9613252957444444,
    &quot;bic&quot;: -1120.0506497593492,
    &quot;n&quot;: 193
  }
}

_FEATURES = [&quot;1&quot;, &quot;logE&quot;, &quot;logD&quot;, &quot;logE2&quot;, &quot;logD2&quot;, &quot;logE_logD&quot;]

def _predict_one(num_experts: float, dense_parameter_count: float, weights: list[float]) -&gt; float:
    # Guard against non-positive inputs for log
    e = max(float(num_experts), 1e-12)
    d = max(float(dense_parameter_count), 1e-12)
    le = log10(e)
    ld = log10(d)

    # X = [1, le, ld, le^2, ld^2, le*ld]
    x = [1.0, le, ld, le*le, ld*ld, le*ld]

    return sum(w*v for w,v in zip(weights, x))

def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law is the same for all groups, but
                the coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    coeffs = _COEFFICIENTS.get(group)
    if coeffs is None:
        coeffs = _COEFFICIENTS.get(&quot;_default_&quot;)
    weights = coeffs[&quot;weights&quot;]
    outputs = []
    for row in input_data:
        ne = float(row.get(&quot;num_experts&quot;, 0.0))
        dp = float(row.get(&quot;dense_parameter_count&quot;, 0.0))
        yhat = _predict_one(ne, dp, weights)
        outputs.append({&quot;loss_validation&quot;: float(yhat)})
    return outputs</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#5</span>
                    <span class="run-label">Run 5</span>
                    <span class="r2-badge" style="background-color: #B22222; color: white;">
                        R² = -0.217412
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-4"># Auto-generated scaling law for MoE validation loss
# Formula: loss_validation = a_g + b_g * dense_parameter_count^(-ALPHA) + c_g * num_experts^(-BETA)

from typing import List, Dict
import math

ALPHA = 0.23950000000000005
BETA = 0.01

COEFFS: Dict[str, Dict[str, float]] = {
  &quot;all_data&quot;: {
    &quot;a&quot;: -5.4067970077023535,
    &quot;b&quot;: 58.73130251056639,
    &quot;c&quot;: 7.426966606414652
  }
}
DEFAULT_COEFFS = {&quot;a&quot;: -5.406797007702353, &quot;b&quot;: 58.73130251056639, &quot;c&quot;: 7.426966606414652}

def _predict_one(dense_parameter_count: float, num_experts: float, a: float, b: float, c: float) -&gt; float:
    D = float(dense_parameter_count)
    E = float(num_experts)
    # Clamp to positive to avoid invalid power usage
    if not math.isfinite(D) or D &lt;= 0:
        D = 1.0
    if not math.isfinite(E) or E &lt;= 0:
        E = 1.0
    return float(a + b * (D ** (-ALPHA)) + c * (E ** (-BETA)))

def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    coeff = COEFFS.get(group, DEFAULT_COEFFS)
    a = float(coeff.get(&quot;a&quot;, DEFAULT_COEFFS[&quot;a&quot;]))
    b = float(coeff.get(&quot;b&quot;, DEFAULT_COEFFS[&quot;b&quot;]))
    c = float(coeff.get(&quot;c&quot;, DEFAULT_COEFFS[&quot;c&quot;]))
    outputs: list[dict[str, float]] = []
    for row in input_data:
        D = row.get(&quot;dense_parameter_count&quot;, 0.0)
        E = row.get(&quot;num_experts&quot;, 0.0)
        pred = _predict_one(D, E, a, b, c)
        outputs.append({&quot;loss_validation&quot;: pred})
    return outputs</code></pre>
                </div>
            </div>
        </div>
        
        </div>
        
        <footer class="footer">
            <p>SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> | <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a></p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleRun(header) {
            const content = header.nextElementSibling;
            const isExpanded = content.style.display === 'block';
            content.style.display = isExpanded ? 'none' : 'block';
            header.classList.toggle('expanded', !isExpanded);
        }
        
        function copyCode(event, codeId) {
            event.stopPropagation();
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }
        
        Prism.highlightAll();
    </script>
</body>
</html>
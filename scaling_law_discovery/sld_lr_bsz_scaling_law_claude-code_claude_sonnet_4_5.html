<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SLD - LR & Batch Size Scaling Law - claude-code + claude-sonnet-4-5</title>
    <link rel="icon" type="image/png" href="assets/sld_logo.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Sora:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
    <style>
        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --accent-primary: #2563eb;
            --accent-secondary: #3b82f6;
            --accent-gradient: linear-gradient(135deg, #2563eb 0%, #3b82f6 50%, #60a5fa 100%);
            --text-primary: #1f2937;
            --text-secondary: #4b5563;
            --border-subtle: rgba(0, 0, 0, 0.1);
            --glass-bg: rgba(0, 0, 0, 0.02);
            --success: #10b981;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Sora', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            min-height: 100vh;
            color: var(--text-primary);
        }
        
        .bg-pattern {
            display: none;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }
        
        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            color: var(--accent-primary);
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 1.5rem;
            transition: color 0.2s;
        }
        
        .back-link:hover {
            color: var(--accent-secondary);
        }
        
        .header {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 16px;
            padding: 2rem;
            margin-bottom: 2rem;
            backdrop-filter: blur(10px);
        }
        
        .header h1 {
            font-size: 1.75rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
            background: var(--accent-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .meta-row {
            display: flex;
            flex-wrap: wrap;
            gap: 1.5rem;
            margin-top: 1rem;
        }
        
        .meta-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .meta-label {
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .meta-value {
            font-weight: 600;
            color: var(--text-primary);
        }
        
        .r2-badge {
            display: inline-block;
            padding: 0.3rem 0.6rem;
            border-radius: 6px;
            font-weight: 600;
            font-size: 0.85rem;
            font-family: 'JetBrains Mono', monospace;
        }
        
        .section-title {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }
        
        .runs-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }
        
        .run-card {
            background: var(--glass-bg);
            border: 1px solid var(--border-subtle);
            border-radius: 12px;
            overflow: hidden;
            transition: border-color 0.2s;
        }
        
        .run-card:hover {
            border-color: rgba(99, 102, 241, 0.3);
        }
        
        .run-card.best-run {
            border-color: var(--success);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.1);
        }
        
        .run-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.25rem;
            background: rgba(255, 255, 255, 0.02);
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .run-header:hover {
            background: rgba(255, 255, 255, 0.04);
        }
        
        .run-info {
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .run-badge {
            padding: 0.25rem 0.6rem;
            border-radius: 6px;
            font-size: 0.75rem;
            font-weight: 600;
            background: rgba(255, 255, 255, 0.1);
            color: var(--text-secondary);
        }
        
        .run-badge.best-badge {
            background: var(--success);
            color: white;
        }
        
        .run-label {
            font-weight: 500;
            color: var(--text-primary);
        }
        
        .expand-icon {
            color: var(--text-muted);
            font-size: 0.8rem;
            transition: transform 0.2s;
        }
        
        .run-header.expanded .expand-icon {
            transform: rotate(180deg);
        }
        
        .run-content {
            border-top: 1px solid var(--border-subtle);
        }
        
        .code-container {
            overflow: hidden;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem 1.25rem;
            background: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid var(--border-subtle);
            font-size: 0.8rem;
            color: var(--text-muted);
        }
        
        .copy-btn {
            padding: 0.35rem 0.75rem;
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.3);
            border-radius: 6px;
            color: var(--accent-primary);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            font-family: inherit;
        }
        
        .copy-btn:hover {
            background: rgba(99, 102, 241, 0.3);
        }
        
        .code-container pre {
            margin: 0;
            padding: 1.25rem;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            line-height: 1.6;
            overflow-x: auto;
            background: transparent !important;
        }
        
        .footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border-subtle);
            color: var(--text-secondary);
            font-size: 0.85rem;
        }
        
        .footer a {
            color: var(--accent-primary);
            text-decoration: none;
        }
        
        @media (max-width: 768px) {
            .container {
                padding: 1rem;
            }
            
            .header h1 {
                font-size: 1.25rem;
            }
            
            .meta-row {
                flex-direction: column;
                gap: 0.75rem;
            }
            
            .run-info {
                flex-wrap: wrap;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="container">
        <a href="sld_index.html" class="back-link">
            ← Back to Leaderboard
        </a>
        
        <div class="header">
            <h1>LR & Batch Size Scaling Law</h1>
            <div class="meta-row">
                <div class="meta-item">
                    <span class="meta-label">Agent:</span>
                    <span class="meta-value">claude-code</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Model:</span>
                    <span class="meta-value">claude-sonnet-4-5</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Best R²:</span>
                    <span class="r2-badge" style="background-color: #B22222; color: white;">
                        -0.500295
                    </span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Mean R²:</span>
                    <span class="meta-value">-0.845783</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Min R²:</span>
                    <span class="meta-value">-1.000000</span>
                </div>
                <div class="meta-item">
                    <span class="meta-label">Runs:</span>
                    <span class="meta-value">5</span>
                </div>
            </div>
        </div>
        
        <h2 class="section-title">All Runs (sorted by R²)</h2>
        
        <div class="runs-container">
            
        <div class="run-card best-run">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge best-badge">Best</span>
                    <span class="run-label">Run 1</span>
                    <span class="r2-badge" style="background-color: #B22222; color: white;">
                        R² = -0.500295
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: block;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-0')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-0">import numpy as np


def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;

    # Fitted parameters for each group
    # These were discovered through nonlinear regression on the training data
    params = {
        &#x27;all_data&#x27;: {
            &#x27;A&#x27;: 9.995778,
            &#x27;alpha&#x27;: 0.094913,
            &#x27;B&#x27;: 19.996945,
            &#x27;beta&#x27;: 0.133021,
            &#x27;C&#x27;: -0.028150,
            &#x27;E&#x27;: 0.025909,
            &#x27;lr_opt&#x27;: 1.290894e-03,
            &#x27;F&#x27;: 0.018372,
            &#x27;bsz_opt&#x27;: 199.999997
        }
    }

    # Get parameters for this group
    if group not in params:
        raise ValueError(f&quot;Unknown group: {group}. Available groups: {list(params.keys())}&quot;)

    p = params[group]

    # Extract parameters
    A = p[&#x27;A&#x27;]
    alpha = p[&#x27;alpha&#x27;]
    B = p[&#x27;B&#x27;]
    beta = p[&#x27;beta&#x27;]
    C = p[&#x27;C&#x27;]
    E = p[&#x27;E&#x27;]
    lr_opt = p[&#x27;lr_opt&#x27;]
    F = p[&#x27;F&#x27;]
    bsz_opt = p[&#x27;bsz_opt&#x27;]

    # Make predictions for each input data point
    results = []
    for data_point in input_data:
        # Extract input variables
        N = data_point[&#x27;non_embedding_param_size&#x27;]
        D = data_point[&#x27;data_size&#x27;]
        lr = data_point[&#x27;lr&#x27;]
        bsz = data_point[&#x27;bsz&#x27;]

        # Apply the scaling law formula:
        # L = A/N^alpha + B/D^beta + C + E*(log(lr/lr_opt))^2 + F*(log(bsz/bsz_opt))^2

        # Base loss from model size and data size (power law terms)
        base_loss = A / (N ** alpha) + B / (D ** beta) + C

        # Learning rate penalty (quadratic in log space)
        lr_penalty = E * (np.log(lr / lr_opt)) ** 2

        # Batch size penalty (quadratic in log space)
        bsz_penalty = F * (np.log(bsz / bsz_opt)) ** 2

        # Total predicted loss
        lm_loss = base_loss + lr_penalty + bsz_penalty

        results.append({&#x27;lm_loss&#x27;: float(lm_loss)})

    return results</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#2</span>
                    <span class="run-label">Run 2</span>
                    <span class="r2-badge" style="background-color: #B22222; color: white;">
                        R² = -0.818347
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-1')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-1">import numpy as np

def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;

    # Parameters fitted for group &quot;all_data&quot;
    # These were obtained by fitting the model to the full training dataset
    params = {
        &#x27;all_data&#x27;: {
            &#x27;L_inf&#x27;: -72.685162,
            &#x27;A&#x27;: 77.20122239,
            &#x27;alpha&#x27;: 0.001655,
            &#x27;B&#x27;: 577.703742,
            &#x27;beta&#x27;: 0.314307,
            &#x27;C&#x27;: 0.0247540,
            &#x27;lr_opt&#x27;: 0.001185395,
            &#x27;E&#x27;: 0.002184469
        }
    }

    # Get parameters for the specified group
    # If group is not found, use all_data parameters as default
    if group not in params:
        group_params = params[&#x27;all_data&#x27;]
    else:
        group_params = params[group]

    L_inf = group_params[&#x27;L_inf&#x27;]
    A = group_params[&#x27;A&#x27;]
    alpha = group_params[&#x27;alpha&#x27;]
    B = group_params[&#x27;B&#x27;]
    beta = group_params[&#x27;beta&#x27;]
    C = group_params[&#x27;C&#x27;]
    lr_opt = group_params[&#x27;lr_opt&#x27;]
    E = group_params[&#x27;E&#x27;]

    # Make predictions for each data point
    predictions = []

    for data_point in input_data:
        # Extract input features
        lr = data_point[&#x27;lr&#x27;]
        bsz = data_point[&#x27;bsz&#x27;]
        data_size = data_point[&#x27;data_size&#x27;]
        non_embedding_param_size = data_point[&#x27;non_embedding_param_size&#x27;]

        # Apply the scaling law formula:
        # L = L_inf + A/(N^α) + B/(D^β) + C*(log(lr/lr_opt))^2 + E*log(bsz)
        # where:
        #   N = non_embedding_param_size (model size)
        #   D = data_size (training data size)
        #   lr = learning rate
        #   bsz = batch size

        # Model size term (power law)
        model_term = A / (non_embedding_param_size ** alpha)

        # Data size term (power law)
        data_term = B / (data_size ** beta)

        # Learning rate term (quadratic penalty from optimal)
        lr_term = C * (np.log(lr / lr_opt)) ** 2

        # Batch size term (logarithmic)
        bsz_term = E * np.log(bsz)

        # Combine all terms
        lm_loss = L_inf + model_term + data_term + lr_term + bsz_term

        # Return prediction
        predictions.append({&#x27;lm_loss&#x27;: lm_loss})

    return predictions</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#3</span>
                    <span class="run-label">Run 3</span>
                    <span class="r2-badge" style="background-color: #B22222; color: white;">
                        R² = -0.940444
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-2')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-2">def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;

    # Parameters fitted for the &#x27;all_data&#x27; group
    # These were obtained through differential evolution optimization
    # to minimize the mean squared error between predicted and actual loss values
    params = {
        &#x27;all_data&#x27;: {
            &#x27;E&#x27;: 1.07127324,           # Irreducible loss (minimum achievable loss)
            &#x27;A&#x27;: 12.32047451,          # Model size scaling coefficient
            &#x27;alpha&#x27;: 0.13428613,       # Model size scaling exponent
            &#x27;B&#x27;: 96.03044736,          # Data size scaling coefficient
            &#x27;beta&#x27;: 0.22927593,        # Data size scaling exponent
            &#x27;gamma&#x27;: -0.21145263,      # Learning rate exponent
            &#x27;delta&#x27;: -0.04056945,      # Batch size exponent
            &#x27;lr_0&#x27;: 0.00010000,        # Reference learning rate
            &#x27;bsz_0&#x27;: 1056.52577403,    # Reference batch size
        }
    }

    # Get parameters for the specified group
    if group not in params:
        raise ValueError(f&quot;Unknown group: {group}. Available groups: {list(params.keys())}&quot;)

    p = params[group]

    # Apply the scaling law to each data point
    results = []
    for data_point in input_data:
        # Extract input variables
        N = data_point[&#x27;non_embedding_param_size&#x27;]
        D = data_point[&#x27;data_size&#x27;]
        lr = data_point[&#x27;lr&#x27;]
        bsz = data_point[&#x27;bsz&#x27;]

        # Calculate effective data size
        # The learning rate and batch size affect how effectively the model
        # utilizes the training data
        D_eff = D * ((lr / p[&#x27;lr_0&#x27;]) ** p[&#x27;gamma&#x27;]) * ((bsz / p[&#x27;bsz_0&#x27;]) ** p[&#x27;delta&#x27;])

        # Apply the scaling law:
        # L = E + A/N^alpha + B/D_eff^beta
        #
        # Where:
        # - E is the irreducible loss (theoretical minimum)
        # - A/N^alpha captures the effect of model size (larger models → lower loss)
        # - B/D_eff^beta captures the effect of data size (more data → lower loss)
        # - D_eff adjusts data size based on training hyperparameters
        lm_loss = p[&#x27;E&#x27;] + p[&#x27;A&#x27;] / (N ** p[&#x27;alpha&#x27;]) + p[&#x27;B&#x27;] / (D_eff ** p[&#x27;beta&#x27;])

        results.append({&#x27;lm_loss&#x27;: lm_loss})

    return results</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#4</span>
                    <span class="run-label">Run 4</span>
                    <span class="r2-badge" style="background-color: #B22222; color: white;">
                        R² = -0.969830
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-3')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-3">import numpy as np


def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    # Group-specific parameters
    # These were fitted using differential evolution on the training data
    group_params = {
        &#x27;all_data&#x27;: {
            &#x27;E&#x27;: 1.50388274e+00,
            &#x27;A&#x27;: 4.79640622e+01,
            &#x27;alpha&#x27;: 2.31705082e-01,
            &#x27;B&#x27;: 4.96341790e+01,
            &#x27;beta&#x27;: 1.87783075e-01,
            &#x27;C&#x27;: 2.68264892e-02,
            &#x27;lr_scale&#x27;: 9.70220088e-03,
            &#x27;lr_exp&#x27;: -1.04437884e-01,
            &#x27;F&#x27;: 5.62388220e-03,
            &#x27;bsz_scale&#x27;: 4.05875928e-09,
            &#x27;bsz_exp&#x27;: -4.83464543e-01,
        }
    }

    # Get parameters for the specified group
    if group not in group_params:
        # If group not found, use &#x27;all_data&#x27; as default
        params = group_params[&#x27;all_data&#x27;]
    else:
        params = group_params[group]

    # Extract parameters
    E = params[&#x27;E&#x27;]
    A = params[&#x27;A&#x27;]
    alpha = params[&#x27;alpha&#x27;]
    B = params[&#x27;B&#x27;]
    beta = params[&#x27;beta&#x27;]
    C = params[&#x27;C&#x27;]
    lr_scale = params[&#x27;lr_scale&#x27;]
    lr_exp = params[&#x27;lr_exp&#x27;]
    F = params[&#x27;F&#x27;]
    bsz_scale = params[&#x27;bsz_scale&#x27;]
    bsz_exp = params[&#x27;bsz_exp&#x27;]

    # Make predictions for each data point
    results = []
    for data_point in input_data:
        # Extract input features
        N = data_point[&#x27;non_embedding_param_size&#x27;]
        D = data_point[&#x27;data_size&#x27;]
        lr = data_point[&#x27;lr&#x27;]
        bsz = data_point[&#x27;bsz&#x27;]

        # Calculate optimal learning rate (scales with model size)
        lr_opt = lr_scale * (N ** lr_exp)

        # Calculate optimal batch size (scales with model size)
        bsz_opt = bsz_scale * (N ** bsz_exp)

        # Compute the scaling law:
        # L = E + A/N^alpha + B/D^beta + C*(log(lr/lr_opt))^2 + F*log(bsz_opt/bsz)

        # Base loss (irreducible loss)
        base_loss = E

        # Model size scaling term (larger models achieve lower loss)
        model_term = A / (N ** alpha)

        # Data size scaling term (more data achieves lower loss)
        data_term = B / (D ** beta)

        # Learning rate penalty (quadratic in log space, penalizes deviation from optimal)
        lr_penalty = C * ((np.log(lr) - np.log(lr_opt)) ** 2)

        # Batch size effect (logarithmic penalty for suboptimal batch size)
        bsz_effect = F * np.log(bsz_opt / bsz)

        # Total predicted loss
        lm_loss = base_loss + model_term + data_term + lr_penalty + bsz_effect

        # Return prediction
        results.append({&#x27;lm_loss&#x27;: float(lm_loss)})

    return results</code></pre>
                </div>
            </div>
        </div>
        
        <div class="run-card ">
            <div class="run-header" onclick="toggleRun(this)">
                <div class="run-info">
                    <span class="run-badge ">#5</span>
                    <span class="run-label">Run 5</span>
                    <span class="r2-badge" style="background-color: #B22222; color: white;">
                        R² = -1.000000
                    </span>
                </div>
                <span class="expand-icon">▼</span>
            </div>
            <div class="run-content" style="display: none;">
                <div class="code-container">
                    <div class="code-header">
                        <span>Python</span>
                        <button class="copy-btn" onclick="copyCode(event, 'code-4')">Copy</button>
                    </div>
                    <pre><code class="language-python" id="code-4">import numpy as np


def law(input_data: list[dict[str, float]], group: str) -&gt; list[dict[str, float]]:
    &quot;&quot;&quot;
    Predicts output variables based on input variables according to a discovered scaling law.

    Args:
        input_data: A list of dictionaries, where each dictionary is a single data
                    point containing input variable names as keys and their
                    corresponding values.
        group: The name of the experimental group for which to make predictions.
                The functional form of the law must be the same for all groups,
                but the constant parameters/coefficients can differ per group.

    Returns:
        A list of dictionaries, corresponding to the input_data list, with each
        dictionary containing the predicted output variable(s).
    &quot;&quot;&quot;
    # Parameters fitted for the &#x27;all_data&#x27; group
    # The scaling law has the form:
    # L = E + A/N^α + B/D^β + C*(log(lr) - log(lr_opt))^2 + G/bsz^γ
    # where lr_opt = lr_base * bsz^lr_scale

    params = {
        &#x27;all_data&#x27;: {
            &#x27;E&#x27;: 1.32668496,
            &#x27;A&#x27;: 41.31399135,
            &#x27;alpha&#x27;: 0.21844815,
            &#x27;B&#x27;: 86.93092370,
            &#x27;beta&#x27;: 0.21783959,
            &#x27;C&#x27;: 0.02543848,
            &#x27;lr_base&#x27;: 0.00026245,
            &#x27;lr_scale&#x27;: 0.30984192,
            &#x27;G&#x27;: 14.21523916,
            &#x27;gamma&#x27;: 1.97068429
        }
    }

    # Get parameters for the specified group
    if group not in params:
        raise ValueError(f&quot;Unknown group: {group}. Available groups: {list(params.keys())}&quot;)

    p = params[group]

    # Process each data point
    results = []
    for data_point in input_data:
        # Extract input variables
        N = data_point[&#x27;non_embedding_param_size&#x27;]
        D = data_point[&#x27;data_size&#x27;]
        lr = data_point[&#x27;lr&#x27;]
        bsz = data_point[&#x27;bsz&#x27;]

        # Compute the scaling law
        # Base loss components from model size and data size
        base_loss = p[&#x27;E&#x27;] + p[&#x27;A&#x27;] / (N ** p[&#x27;alpha&#x27;]) + p[&#x27;B&#x27;] / (D ** p[&#x27;beta&#x27;])

        # Learning rate penalty (quadratic around optimal learning rate)
        lr_opt = p[&#x27;lr_base&#x27;] * (bsz ** p[&#x27;lr_scale&#x27;])
        lr_penalty = p[&#x27;C&#x27;] * (np.log(lr) - np.log(lr_opt)) ** 2

        # Batch size penalty (smaller batch sizes hurt performance)
        bsz_penalty = p[&#x27;G&#x27;] / (bsz ** p[&#x27;gamma&#x27;])

        # Total predicted loss
        lm_loss = base_loss + lr_penalty + bsz_penalty

        results.append({&#x27;lm_loss&#x27;: lm_loss})

    return results</code></pre>
                </div>
            </div>
        </div>
        
        </div>
        
        <footer class="footer">
            <p>SLDBench | <a href="https://arxiv.org/abs/2507.21184" target="_blank">arXiv:2507.21184</a> | <a href="https://github.com/linhaowei1/SLD" target="_blank">GitHub</a></p>
        </footer>
    </div>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script>
        function toggleRun(header) {
            const content = header.nextElementSibling;
            const isExpanded = content.style.display === 'block';
            content.style.display = isExpanded ? 'none' : 'block';
            header.classList.toggle('expanded', !isExpanded);
        }
        
        function copyCode(event, codeId) {
            event.stopPropagation();
            const code = document.getElementById(codeId).textContent;
            navigator.clipboard.writeText(code).then(() => {
                const btn = event.target;
                btn.textContent = 'Copied!';
                setTimeout(() => btn.textContent = 'Copy', 2000);
            });
        }
        
        Prism.highlightAll();
    </script>
</body>
</html>